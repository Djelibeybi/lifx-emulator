{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"LIFX Emulator","text":"<p>Test your LIFX LAN protocol libraries without physical devices.</p>"},{"location":"#overview","title":"Overview","text":"<p>LIFX Emulator is a Python project for testing LIFX LAN protocol client libraries. It implements the complete binary UDP protocol from lan.developer.lifx.com.</p>"},{"location":"#packages","title":"Packages","text":"<p>This project provides two packages for different use cases:</p> Package PyPI Name Import Name Description Standalone <code>lifx-emulator</code> <code>lifx_emulator_app</code> CLI tool + HTTP management API Core Library <code>lifx-emulator-core</code> <code>lifx_emulator</code> Embeddable Python library"},{"location":"#which-package-do-i-need","title":"Which Package Do I Need?","text":"<p>Install <code>lifx-emulator</code> if you want:</p> <ul> <li>A ready-to-run CLI tool</li> <li>HTTP REST API for device management</li> <li>Web dashboard for monitoring</li> <li>Quick testing without writing code</li> </ul> <pre><code>pip install lifx-emulator\nlifx-emulator --api --verbose\n</code></pre> <p>Install <code>lifx-emulator-core</code> if you want:</p> <ul> <li>To embed emulation in your own Python application</li> <li>Programmatic control for pytest or other test frameworks</li> <li>To build custom tooling around LIFX emulation</li> </ul> <pre><code>pip install lifx-emulator-core\n</code></pre> <pre><code>from lifx_emulator import create_color_light, EmulatedLifxServer\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"CLI (lifx-emulator)Python Library (lifx-emulator-core) <pre><code># Install\npip install lifx-emulator\n\n# Start with default configuration\nlifx-emulator\n\n# Multiple devices with web dashboard\nlifx-emulator --color 2 --multizone 1 --api --verbose\n</code></pre> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n    device_manager = DeviceManager(DeviceRepository())\n\n    async with EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    ) as server:\n        print(f\"Emulating: {device.state.label}\")\n        await asyncio.Event().wait()\n\nasyncio.run(main())\n</code></pre>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Complete Protocol Support: All packet types from the LIFX LAN protocol</li> <li>Multiple Device Types: Color lights, infrared, HEV, multizone strips, and matrix tiles</li> <li>Product Registry: 137+ official LIFX product definitions</li> <li>Testing Scenarios: Configurable packet loss, delays, malformed responses</li> <li>HTTP Management API: OpenAPI 3.1.0 compliant REST API (standalone package)</li> <li>Web Dashboard: Real-time monitoring interface (standalone package)</li> <li>Persistent Storage: Save device state across sessions</li> </ul>"},{"location":"#documentation","title":"Documentation","text":""},{"location":"#getting-started","title":"Getting Started","text":"<ul> <li>Installation - Install either package</li> <li>Quick Start - First steps with CLI or Python API</li> </ul>"},{"location":"#lifx-emulator-standalone-cli","title":"lifx-emulator (Standalone CLI)","text":"<ul> <li>Overview - CLI tool and HTTP management server</li> <li>CLI Reference - All CLI commands and options</li> <li>Web Interface - Browser-based monitoring dashboard</li> <li>Device Management API - REST API for devices</li> <li>Scenario API - REST API for test scenarios</li> <li>Persistent Storage - Save state across restarts</li> <li>Scenarios Guide - Comprehensive scenario configuration</li> </ul>"},{"location":"#lifx-emulator-core-python-library","title":"lifx-emulator-core (Python Library)","text":"<ul> <li>Python Library Reference - Complete library documentation</li> <li>Factory Functions - Device creation functions</li> <li>Server - EmulatedLifxServer configuration</li> <li>Device - EmulatedLifxDevice and DeviceState</li> <li>Protocol Types - LightHsbk and other types</li> <li>Storage - Persistent state management</li> <li>Product Registry - Product database</li> <li>Architecture - System design and internals</li> </ul>"},{"location":"#guides-shared","title":"Guides (Shared)","text":"<ul> <li>Device Types - Supported LIFX devices</li> <li>Products &amp; Specs - Product registry usage</li> <li>Testing Scenarios - Error simulation</li> <li>Framebuffers - Matrix device framebuffer support</li> <li>Integration Testing - Using in test suites</li> <li>Best Practices - Tips for effective testing</li> </ul>"},{"location":"#tutorials","title":"Tutorials","text":"<ul> <li>First Device - Your first emulated device</li> <li>Basic Usage - Multiple devices and basic testing</li> <li>Integration Testing - pytest integration</li> <li>Advanced Scenarios - Error injection</li> <li>CI/CD Integration - Automated testing pipelines</li> </ul>"},{"location":"#reference","title":"Reference","text":"<ul> <li>FAQ - Frequently asked questions</li> <li>Troubleshooting - Common issues and solutions</li> <li>Glossary - Terms and definitions</li> <li>Changelog - Version history</li> </ul>"},{"location":"#supported-device-types","title":"Supported Device Types","text":"Device Type Example Products Capabilities Color Lights LIFX A19, LIFX BR30 Full RGB color control Color Temperature LIFX Mini White to Warm Variable white temperature Infrared LIFX A19 Night Vision IR brightness control HEV LIFX Clean HEV cleaning cycle Multizone LIFX Z, LIFX Beam Linear zones (up to 82+) Matrix LIFX Tile, LIFX Candle 2D zone arrays Switch LIFX Switch Relay-based switches"},{"location":"#use-cases","title":"Use Cases","text":"<ul> <li>Library Testing: Test your LIFX library without physical devices</li> <li>CI/CD Integration: Run automated tests in pipelines</li> <li>Protocol Development: Experiment with LIFX protocol features</li> <li>Error Simulation: Test error handling with configurable scenarios</li> <li>Performance Testing: Test concurrent device handling</li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> </ul>"},{"location":"#project-links","title":"Project Links","text":"<ul> <li>GitHub Repository</li> <li>PyPI: lifx-emulator</li> <li>PyPI: lifx-emulator-core</li> <li>LIFX LAN Protocol Documentation</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":"<p>Common questions about the LIFX Emulator and their answers.</p>"},{"location":"faq/#quick-answers","title":"Quick Answers","text":""},{"location":"faq/#port-conflicts","title":"Port conflicts?","text":"<p>\u2192 See Best Practices - Port Management</p>"},{"location":"faq/#test-too-slow","title":"Test too slow?","text":"<p>\u2192 See Best Practices - Performance</p>"},{"location":"faq/#discovery-not-working","title":"Discovery not working?","text":"<p>\u2192 See Troubleshooting - Discovery Failures</p>"},{"location":"faq/#protocol-errors","title":"Protocol errors?","text":"<p>\u2192 See Troubleshooting - Protocol Errors</p>"},{"location":"faq/#need-examples","title":"Need examples?","text":"<p>\u2192 See Tutorials and Examples</p>"},{"location":"faq/#general-questions","title":"General Questions","text":""},{"location":"faq/#what-is-the-lifx-emulator","title":"What is the LIFX Emulator?","text":"<p>The LIFX Emulator is a virtual LIFX device implementation that speaks the LIFX LAN protocol. It allows you to test LIFX client libraries and applications without needing physical LIFX devices.</p>"},{"location":"faq/#why-use-the-emulator-instead-of-real-devices","title":"Why use the emulator instead of real devices?","text":"<p>Advantages of the emulator:</p> <ul> <li>Cost: No need to purchase physical devices (a single LIFX device costs $60-350+)</li> <li>Speed: Instant device creation, no setup time</li> <li>Availability: Always available, no dependency on hardware</li> <li>Scalability: Test with 100+ devices on one machine</li> <li>Control: Precise control over device state and behavior</li> <li>Error injection: Simulate network issues, firmware bugs, edge cases</li> <li>Reproducibility: Consistent test results, no flaky hardware</li> <li>CI/CD: Run tests in automated pipelines without hardware</li> </ul> <p>When to use real devices:</p> <ul> <li>Testing hardware-specific behavior</li> <li>Validating WiFi/network stack issues</li> <li>Final integration testing before release</li> <li>Testing firmware update mechanisms</li> <li>Verifying physical device interactions (buttons, etc.)</li> </ul> <p>See also: Best Practices - When to Use the Emulator</p>"},{"location":"faq/#why-lifx-emulator-vs-other-testing-approaches","title":"Why LIFX Emulator vs other testing approaches?","text":"<p>Comparison with alternatives:</p> Approach Speed Accuracy Setup Cost Error Testing LIFX Emulator \u26a1 Fast \u2705 High \ud83d\udfe2 Easy \ud83d\udcb0 Free \u2705 Excellent Mocking \u26a1\u26a1 Fastest \u26a0\ufe0f Low \ud83d\udfe2 Easy \ud83d\udcb0 Free \u26a0\ufe0f Limited VCR/Recording \u26a1 Fast \u2705 High \ud83d\udfe1 Medium \ud83d\udcb0 Free \u274c None Real Devices \ud83d\udc0c Slow \u2705\u2705 Perfect \ud83d\udd34 Hard \ud83d\udcb0\ud83d\udcb0 Expensive \u274c Difficult <p>Use the emulator when:</p> <ul> <li>Testing LIFX protocol implementation</li> <li>Integration testing your application</li> <li>Running tests in CI/CD</li> <li>Testing error handling and edge cases</li> </ul> <p>Use mocks when:</p> <ul> <li>Unit testing business logic</li> <li>Speed is critical</li> <li>Testing code that uses LIFX, not the protocol itself</li> </ul> <p>Use real devices when:</p> <ul> <li>Final validation before production release</li> <li>Testing hardware-specific features</li> <li>Verifying WiFi behavior</li> </ul>"},{"location":"faq/#what-protocol-version-is-supported","title":"What protocol version is supported?","text":"<p>The emulator implements the LIFX LAN Protocol as documented at https://lan.developer.lifx.com.</p> <p>Protocol compliance:</p> <ul> <li>\u2705 Full header support (36 bytes)</li> <li>\u2705 Device discovery (GetService, StateService)</li> <li>\u2705 Device messages (label, location, group, power, etc.)</li> <li>\u2705 Light messages (color, brightness, effects)</li> <li>\u2705 MultiZone messages (standard and extended)</li> <li>\u2705 Tile/Matrix messages (Get64, Set64)</li> <li>\u2705 HEV/Clean messages</li> <li>\u2705 Infrared messages</li> </ul> <p>Protocol version: Compatible with protocol as of November 2025</p>"},{"location":"faq/#how-accurate-is-the-emulation","title":"How accurate is the emulation?","text":"<p>What's accurate:</p> <ul> <li>\u2705 Binary protocol implementation (packet structure, types, serialization)</li> <li>\u2705 Device state management (color, power, zones, tiles)</li> <li>\u2705 Packet acknowledgment (ack_required, res_required)</li> <li>\u2705 Broadcast vs unicast handling</li> <li>\u2705 Multi-device support</li> <li>\u2705 Device capabilities (color, multizone, matrix, HEV, infrared)</li> </ul> <p>What's approximated:</p> <ul> <li>\u26a0\ufe0f Timing (real devices may have different response times)</li> <li>\u26a0\ufe0f Firmware behavior (emulator uses generalized logic)</li> <li>\u26a0\ufe0f Hardware limitations (real devices have memory/CPU constraints)</li> </ul> <p>What's not emulated:</p> <ul> <li>\u274c WiFi/network layer (emulator uses UDP directly)</li> <li>\u274c Firmware updates</li> <li>\u274c Physical buttons or sensors</li> <li>\u274c Actual light output (brightness, color rendering)</li> <li>\u274c Power consumption</li> </ul> <p>Accuracy rating: ~95% for protocol testing, ~70% for real-world behavior</p>"},{"location":"faq/#can-i-use-this-in-production","title":"Can I use this in production?","text":"<p>No, the emulator is for testing only.</p> <p>Appropriate uses:</p> <ul> <li>\u2705 Development and testing</li> <li>\u2705 CI/CD pipelines</li> <li>\u2705 Integration tests</li> <li>\u2705 Demonstrations (with disclaimers)</li> <li>\u2705 Protocol exploration and learning</li> </ul> <p>Not appropriate for:</p> <ul> <li>\u274c Production control systems</li> <li>\u274c Customer-facing deployments</li> <li>\u274c Critical infrastructure</li> <li>\u274c Safety-critical applications</li> </ul> <p>Why not production?</p> <ul> <li>No reliability guarantees</li> <li>May have undiscovered bugs</li> <li>Not validated against all edge cases</li> <li>No security hardening</li> <li>No official support from LIFX</li> </ul>"},{"location":"faq/#performance-questions","title":"Performance Questions","text":""},{"location":"faq/#how-many-devices-can-i-emulate","title":"How many devices can I emulate?","text":"<p>Practical limits:</p> <ul> <li>Typical usage: 1-10 devices (most common)</li> <li>Stress testing: 50-100 devices (depends on hardware)</li> <li>Maximum tested: 500+ devices (on powerful hardware)</li> </ul> <p>Limiting factors:</p> <ul> <li>Available RAM (each device uses ~1-5 MB)</li> <li>CPU for packet processing</li> <li>Network bandwidth (UDP packet throughput)</li> <li>Operating system limits (file descriptors, ports)</li> </ul> <p>Performance tips:</p> <ul> <li>Use a single server with multiple devices (not multiple servers)</li> <li>Minimize device state updates</li> <li>Use appropriate test fixture scopes</li> <li>Run tests in parallel with pytest-xdist</li> </ul>"},{"location":"faq/#how-many-packets-per-second-can-it-handle","title":"How many packets per second can it handle?","text":"<p>Typical performance:</p> <ul> <li>Single device: ~1,000-10,000 packets/sec</li> <li>10 devices: ~500-5,000 packets/sec</li> <li>100 devices: ~100-1,000 packets/sec</li> </ul> <p>Factors affecting performance:</p> <ul> <li>Hardware (CPU, RAM)</li> <li>Packet type (simple vs complex)</li> <li>Python interpreter (CPython vs PyPy)</li> <li>Operating system</li> <li>Concurrent clients</li> </ul> <p>Optimization:</p> <ul> <li>Emulator uses asyncio for concurrency</li> <li>Packet processing is lightweight</li> <li>Most time spent in serialization/deserialization</li> </ul>"},{"location":"faq/#platform-questions","title":"Platform Questions","text":""},{"location":"faq/#what-platforms-are-supported","title":"What platforms are supported?","text":"<p>Fully supported:</p> <ul> <li>\u2705 Linux (Ubuntu, Debian, Fedora, etc.)</li> <li>\u2705 macOS (Intel and Apple Silicon)</li> <li>\u2705 Windows (Windows 10/11)</li> <li>\u2705 WSL (Windows Subsystem for Linux)</li> </ul> <p>Requirements:</p> <ul> <li>Python 3.11 or newer</li> <li>asyncio support</li> <li>UDP networking</li> </ul> <p>Platform-specific notes:</p> <p>Windows:</p> <ul> <li>May need <code>WindowsProactorEventLoopPolicy</code> for asyncio</li> <li>Firewall may prompt for UDP access</li> <li>Use dynamic port allocation in tests</li> </ul> <p>macOS:</p> <ul> <li>Works on both Intel and Apple Silicon (M1/M2/M3)</li> <li>May need to allow Python through firewall</li> </ul> <p>WSL:</p> <ul> <li>Works well for development and testing</li> <li>UDP networking functions correctly</li> <li>Port conflicts rare</li> </ul>"},{"location":"faq/#does-it-work-in-docker","title":"Does it work in Docker?","text":"<p>Yes! The emulator works great in Docker.</p> <p>Example Dockerfile:</p> <pre><code>FROM python:3.13-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install -e .\n\nEXPOSE 56700/udp\n\nCMD [\"lifx-emulator\", \"--color\", \"3\"]\n</code></pre> <p>Docker tips:</p> <ul> <li>Expose UDP port 56700 (or your custom port)</li> <li>Bind to <code>0.0.0.0</code> for container networking</li> <li>Use Docker networks for multi-container testing</li> <li>Map volumes for persistent storage</li> </ul> <p>See also: CI/CD Integration Tutorial</p>"},{"location":"faq/#does-it-work-in-cicd","title":"Does it work in CI/CD?","text":"<p>Yes! Designed specifically for CI/CD.</p> <p>Supported CI platforms:</p> <ul> <li>\u2705 GitHub Actions</li> <li>\u2705 GitLab CI</li> <li>\u2705 CircleCI</li> <li>\u2705 Travis CI</li> <li>\u2705 Jenkins</li> <li>\u2705 Azure Pipelines</li> </ul> <p>CI/CD best practices:</p> <ul> <li>Use dynamic port allocation</li> <li>Run tests in parallel</li> <li>Cache pip/uv dependencies</li> <li>Use pytest-xdist for speed</li> <li>Set appropriate timeouts</li> </ul> <p>See also: CI/CD Integration Tutorial</p>"},{"location":"faq/#feature-questions","title":"Feature Questions","text":""},{"location":"faq/#can-i-emulate-specific-firmware-versions","title":"Can I emulate specific firmware versions?","text":"<p>Yes! Use the <code>firmware_version</code> scenario:</p> <pre><code>device = create_color_light(\"d073d5000001\")\n\n# Emulate firmware version 3.70\ndevice.scenarios = {\n    'firmware_version': (3, 70)\n}\n</code></pre> <p>Use cases:</p> <ul> <li>Test version detection logic</li> <li>Verify compatibility with old firmware</li> <li>Test upgrade/migration code</li> <li>Ensure graceful degradation</li> </ul> <p>Note: This only changes the reported version, not actual behavior.</p> <p>See also: Testing Scenarios Guide</p>"},{"location":"faq/#does-it-support-firmware-updates","title":"Does it support firmware updates?","text":"<p>No. The emulator does not support firmware update mechanisms.</p> <p>Why not:</p> <ul> <li>Firmware updates are hardware-specific</li> <li>Would require implementing entire update protocol</li> <li>Not needed for most testing scenarios</li> <li>Real devices needed for firmware testing</li> </ul>"},{"location":"faq/#can-i-test-device-discovery","title":"Can I test device discovery?","text":"<p>Yes! The emulator fully supports discovery.</p> <p>How it works:</p> <ul> <li>Emulator responds to GetService (type 2) broadcasts</li> <li>Returns StateService with port number</li> <li>Clients can discover devices as usual</li> </ul> <p>Example:</p> <pre><code># Emulator side\ndevice = create_color_light(\"d073d5000001\")\nserver = EmulatedLifxServer([device], \"0.0.0.0\", 56700)  # Bind to all interfaces\n\n# Client side (using any LIFX library)\n# Discovery will find the emulated device\n</code></pre> <p>Discovery tips:</p> <ul> <li>Bind to <code>0.0.0.0</code> for network-wide discovery</li> <li>Bind to <code>127.0.0.1</code> for localhost-only discovery</li> <li>Ensure firewall allows UDP traffic</li> <li>Use correct port (default: 56700)</li> </ul>"},{"location":"faq/#can-i-test-multizone-effects","title":"Can I test multizone effects?","text":"<p>Yes! Multizone effects are supported.</p> <p>Available effects:</p> <ul> <li>MOVE effect (packet type 510/511)</li> </ul> <p>Example: <pre><code>strip = create_multizone_light(\"d073d8000001\", zone_count=16)\n\n# Device responds to:\n# - GetColorZones (502) / SetColorZones (503)\n# - GetMultiZoneEffect (510) / SetMultiZoneEffect (511)\n# - GetExtendedColorZones (506) / SetExtendedColorZones (512)\n</code></pre></p>"},{"location":"faq/#can-i-test-tile-patterns","title":"Can I test tile patterns?","text":"<p>Yes! Tile/matrix devices are fully supported.</p> <p>Tile features:</p> <ul> <li>Multiple tiles per device (up to 5 or more)</li> <li>Get64/Set64 for zone updates</li> <li>GetDeviceChain for tile info</li> <li>Custom tile dimensions (8x8, 16x8, 5x6)</li> </ul> <p>Example:</p> <pre><code>tiles = create_tile_device(\"d073d9000001\", tile_count=5)\n\n# Each tile has 64 zones (8x8)\n# Responds to Get64 (707) and Set64 (715) packets\n</code></pre>"},{"location":"faq/#troubleshooting-questions","title":"Troubleshooting Questions","text":""},{"location":"faq/#why-cant-my-client-find-the-emulated-device","title":"Why can't my client find the emulated device?","text":"<p>Common causes:</p> <ol> <li>Wrong network interface</li> <li> <p>Solution: Bind to <code>0.0.0.0</code> instead of <code>127.0.0.1</code></p> </li> <li> <p>Port conflict</p> </li> <li> <p>Solution: Use dynamic port allocation or check for conflicts</p> </li> <li> <p>Firewall blocking UDP</p> </li> <li> <p>Solution: Allow Python through firewall (Windows/macOS)</p> </li> <li> <p>Client looking on wrong port</p> </li> <li> <p>Solution: Ensure client uses port 56700 (or your custom port)</p> </li> <li> <p>Emulator not running</p> </li> <li>Solution: Verify emulator started successfully</li> </ol> <p>See also: Troubleshooting Guide</p>"},{"location":"faq/#why-are-my-tests-slow","title":"Why are my tests slow?","text":"<p>Common causes:</p> <ol> <li>Too many devices</li> <li> <p>Solution: Use only devices you need</p> </li> <li> <p>Function-scoped fixtures</p> </li> <li> <p>Solution: Use module or session scope when appropriate</p> </li> <li> <p>Sequential test execution</p> </li> <li> <p>Solution: Use pytest-xdist for parallel tests</p> </li> <li> <p>Unnecessary delays</p> </li> <li> <p>Solution: Remove artificial sleep() calls</p> </li> <li> <p>Slow client library</p> </li> <li>Solution: Profile your client code</li> </ol> <p>See also: Best Practices - Performance Considerations</p>"},{"location":"faq/#how-do-i-debug-protocol-issues","title":"How do I debug protocol issues?","text":"<p>Debugging techniques:</p> <ol> <li> <p>Enable verbose logging: <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre></p> </li> <li> <p>Use --verbose flag: <pre><code>lifx-emulator --verbose\n</code></pre></p> </li> <li> <p>Check packet types: <pre><code>from lifx_emulator.protocol.packets import Light\nprint(f\"GetColor: {Light.GetColor.PKT_TYPE}\")\n</code></pre></p> </li> <li> <p>Inspect device state: <pre><code>print(f\"Device state: {device.state}\")\n</code></pre></p> </li> <li> <p>Use network sniffer:</p> </li> <li>Wireshark or tcpdump to see actual UDP packets</li> </ol> <p>See also: Troubleshooting Guide</p>"},{"location":"faq/#where-do-i-report-bugs","title":"Where do I report bugs?","text":"<p>Bug reports: - \ud83d\udc1b GitHub Issues: https://github.com/Djelibeybi/lifx-emulator/issues</p> <p>Before reporting:</p> <ol> <li>Check existing issues</li> <li>Update to latest version</li> <li>Reproduce with minimal example</li> <li>Collect relevant information:</li> <li>Python version</li> <li>Operating system</li> <li>lifx-emulator version</li> <li>Error messages</li> <li>Minimal reproduction code</li> </ol> <p>Good bug report includes:</p> <ul> <li>Clear description of issue</li> <li>Steps to reproduce</li> <li>Expected behavior</li> <li>Actual behavior</li> <li>Code example</li> <li>Error messages/stack traces</li> </ul>"},{"location":"faq/#version-compatibility","title":"Version Compatibility","text":""},{"location":"faq/#what-python-versions-are-supported","title":"What Python versions are supported?","text":"<p>Required: Python 3.11 or newer</p> <p>Tested on: - \u2705 Python 3.11 - \u2705 Python 3.12 - \u2705 Python 3.13 - \u2705 Python 3.14</p> <p>Not supported: - \u274c Python 3.10 and older</p> <p>Why Python 3.11+? - Modern async features - Performance improvements - Type hints improvements - Better error messages</p>"},{"location":"faq/#what-are-the-differences-from-real-devices","title":"What are the differences from real devices?","text":"<p>Protocol differences: - \u2705 Emulator implements protocol exactly as documented - \u26a0\ufe0f Real devices may have firmware quirks - \u26a0\ufe0f Real devices may have timing differences</p> <p>Behavioral differences: - \ud83d\udd34 Emulator responds instantly (no physical light transition) - \ud83d\udd34 Emulator has no memory/CPU constraints - \ud83d\udd34 Emulator doesn't model WiFi issues - \ud83d\udd34 Emulator doesn't have button inputs</p> <p>State differences: - \u2705 Color, power, zones, tiles: accurate - \u26a0\ufe0f Signal strength, WiFi info: stubbed - \u26a0\ufe0f Uptime, reboot count: simplified</p> <p>Best practice: Use emulator for protocol testing, real devices for final validation.</p>"},{"location":"faq/#getting-help","title":"Getting Help","text":""},{"location":"faq/#where-can-i-find-more-documentation","title":"Where can I find more documentation?","text":"<p>Documentation sections:</p> <ul> <li>\ud83d\udcd6 Getting Started</li> <li>\ud83d\udcd6 Tutorials</li> <li>\ud83d\udcd6 User Guide</li> <li>\ud83d\udcd6 API Reference</li> <li>\ud83d\udcd6 Troubleshooting</li> <li>\ud83d\udcd6 Glossary</li> </ul>"},{"location":"faq/#how-do-i-contribute","title":"How do I contribute?","text":"<p>Contributions welcome!</p> <ul> <li>\ud83c\udfaf GitHub: https://github.com/Djelibeybi/lifx-emulator</li> </ul> <p>Ways to contribute:</p> <ul> <li>Report bugs</li> <li>Suggest features</li> <li>Improve documentation</li> <li>Submit pull requests</li> <li>Help others in issues</li> </ul>"},{"location":"faq/#is-there-a-community","title":"Is there a community?","text":"<p>Official resources:</p> <ul> <li>GitHub Discussions: https://github.com/Djelibeybi/lifx-emulator/discussions</li> <li>GitHub Issues: https://github.com/Djelibeybi/lifx-emulator/issues</li> </ul>"},{"location":"faq/#still-have-questions","title":"Still Have Questions?","text":"<p>If your question isn't answered here:</p> <ol> <li>Check the Glossary for terminology</li> <li>Read the Troubleshooting Guide for common issues</li> <li>Browse the Tutorials for usage examples</li> <li>Search GitHub Issues for similar questions</li> <li>Ask in GitHub Discussions</li> </ol> <p>We're here to help! \ud83c\udf89</p>"},{"location":"architecture/","title":"Architecture","text":"<p>Deep dive into how the LIFX Emulator works internally.</p>"},{"location":"architecture/#overview","title":"Overview","text":"<p>This section explains the internal architecture of the LIFX Emulator. Understanding this helps you:</p> <ul> <li>Debug issues more effectively</li> <li>Contribute to the project</li> <li>Extend the emulator for custom use cases</li> <li>Understand protocol implementation details</li> </ul>"},{"location":"architecture/#prerequisites","title":"Prerequisites","text":"<p>Before reading this section, you should:</p> <ul> <li>Have used the emulator in basic scenarios</li> <li>Understand LIFX device types</li> <li>Have basic knowledge of networking (UDP)</li> <li>Be familiar with Python async/await</li> </ul>"},{"location":"architecture/#learning-path","title":"Learning Path","text":"<p>Read these pages in order from high-level to implementation details:</p> <ol> <li>Architecture Overview - System design and component interaction</li> <li>Architecture Decisions - Design rationale and ADRs (15 documented decisions)</li> <li>Packet Flow - How packets are received and processed</li> <li>Device State - State management and capabilities</li> <li>Protocol Details - Binary protocol implementation</li> </ol>"},{"location":"architecture/#quick-concepts","title":"Quick Concepts","text":""},{"location":"architecture/#layered-architecture","title":"Layered Architecture","text":"<p>The emulator uses a layered architecture:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  LIFX Client        \u2502  Your library/app\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n           \u2502 UDP\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25bc\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Server Layer       \u2502  Packet routing\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Device Layer       \u2502  Device logic\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Protocol Layer     \u2502  Binary packets\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  State Layer        \u2502  Device state\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"architecture/#key-components","title":"Key Components","text":"<ul> <li>EmulatedLifxServer: UDP server that routes packets to devices</li> <li>EmulatedLifxDevice: Individual virtual device with state and logic</li> <li>LifxHeader: 36-byte packet header parser/generator</li> <li>Packet Classes: 44+ packet type implementations</li> <li>DeviceState: Dataclass holding device state</li> </ul>"},{"location":"architecture/#protocol-implementation","title":"Protocol Implementation","text":"<p>The LIFX LAN protocol is a binary UDP protocol. The emulator:</p> <ol> <li>Receives UDP packets on port 56700</li> <li>Parses the 36-byte header</li> <li>Routes to target device(s) by serial</li> <li>Unpacks payload to packet object</li> <li>Executes device-specific handler</li> <li>Generates response packet(s)</li> <li>Sends UDP response(s)</li> </ol>"},{"location":"architecture/#next-steps","title":"Next Steps","text":"<p>Start with the Architecture Overview for a high-level understanding, then progress through the other pages for deeper details.</p>"},{"location":"architecture/decisions/","title":"Architectural Decision Records","text":"<p>Key architectural decisions and design patterns in the lifx-emulator project</p>"},{"location":"architecture/decisions/#overview","title":"Overview","text":"<p>This document captures the reasoning behind major architectural decisions in the lifx-emulator codebase. Understanding these decisions helps developers maintain consistency and make informed changes.</p>"},{"location":"architecture/decisions/#adr-001-monorepo-with-separate-packages","title":"ADR-001: Monorepo with Separate Packages","text":"<p>Status: Adopted</p> <p>Context: The emulator needs to serve two distinct audiences: 1. End users wanting a ready-to-run CLI tool 2. Library developers wanting to embed emulation in their test suites</p> <p>Decision: Use a monorepo with two separate packages: - <code>lifx-emulator</code> (standalone CLI + HTTP API) - <code>lifx-emulator-core</code> (embeddable library)</p> <p>Consequences: - \u2705 Clear separation of concerns - \u2705 Users don't install unnecessary dependencies (FastAPI, uvicorn for library users) - \u2705 Single codebase for maintenance - \u2705 Shared development tools (pytest, ruff, pyright) - \u26a0\ufe0f Requires careful dependency management - \u26a0\ufe0f Independent versioning (semantic-release with conventional-monorepo)</p> <p>Implementation: <code>pyproject.toml:1</code> - uv workspace configuration</p>"},{"location":"architecture/decisions/#adr-002-layered-architecture-with-dependency-injection","title":"ADR-002: Layered Architecture with Dependency Injection","text":"<p>Status: Adopted</p> <p>Context: The emulator needs to be testable, flexible, and maintainable with clear separation between network I/O, business logic, and persistence.</p> <p>Decision: Implement a 4-layer architecture with dependency injection:</p> <pre><code>Network Layer \u2192 Domain Layer \u2192 Repository Layer \u2192 Persistence Layer\n    \u2193               \u2193              \u2193                    \u2193\nEmulatedLifxServer  DeviceManager  DeviceRepository    AsyncFile\n                    ScenarioMgr    Interfaces          Storage\n</code></pre> <p>Consequences: - \u2705 Single Responsibility Principle - each layer has one clear purpose - \u2705 Testability - easy to inject mocks for unit testing - \u2705 Flexibility - can swap storage backends without changing domain logic - \u2705 Dependency Inversion - layers depend on Protocol interfaces, not implementations - \u26a0\ufe0f More complex initialization (requires explicit dependency wiring) - \u26a0\ufe0f Developers must understand layer boundaries</p> <p>Example (<code>server.py:1</code>): <pre><code># Constructor requires dependencies\nEmulatedLifxServer(\n    devices,\n    device_manager,  # REQUIRED - injected dependency\n    bind_address,\n    port\n)\n</code></pre></p> <p>Reference: <code>docs/architecture/overview.md:1</code> - Repository Pattern section</p>"},{"location":"architecture/decisions/#adr-003-protocol-interfaces-for-testability","title":"ADR-003: Protocol Interfaces for Testability","text":"<p>Status: Adopted</p> <p>Context: Need to enable unit testing with mocks while maintaining type safety.</p> <p>Decision: Define Protocol interfaces for all dependency boundaries: - <code>IDeviceManager</code> - Device lifecycle operations - <code>IDeviceRepository</code> - In-memory device collection - <code>IDeviceStorageBackend</code> - Device state persistence - <code>IScenarioStorageBackend</code> - Scenario persistence</p> <p>Consequences: - \u2705 Type-safe duck typing with Protocol classes - \u2705 Easy to create test doubles (no inheritance required) - \u2705 Clear contracts at layer boundaries - \u2705 Pyright validation of implementations - \u26a0\ufe0f Must keep Protocol in sync with implementations</p> <p>Implementation: <code>repositories/storage_backend.py:1</code></p>"},{"location":"architecture/decisions/#adr-004-auto-generated-protocol-code","title":"ADR-004: Auto-Generated Protocol Code","text":"<p>Status: Adopted</p> <p>Context: The LIFX LAN protocol has 44+ packet types with complex binary structures. Manual implementation is error-prone and hard to maintain.</p> <p>Decision: Auto-generate <code>protocol/packets.py</code> from LIFX YAML specification.</p> <p>Consequences: - \u2705 Guaranteed correctness with upstream protocol - \u2705 Easy to update when LIFX adds new packet types - \u2705 Eliminates manual struct packing errors - \u26a0\ufe0f Must regenerate when protocol changes - \u26a0\ufe0f Generated code is verbose and not human-editable - \u26a0\ufe0f Requires generator.py maintenance</p> <p>DO NOT EDIT: <code>protocol/packets.py:1</code></p> <p>Regenerate with: <pre><code>python -m lifx_emulator.protocol.generator\n</code></pre></p> <p>Reference: <code>protocol/generator.py:1</code></p>"},{"location":"architecture/decisions/#adr-005-auto-generated-product-registry","title":"ADR-005: Auto-Generated Product Registry","text":"<p>Status: Adopted</p> <p>Context: LIFX has 137+ products with varying capabilities, temperature ranges, and firmware requirements. Manual maintenance is infeasible.</p> <p>Decision: Auto-generate <code>products/registry.py</code> from official LIFX products.json on GitHub.</p> <p>Consequences: - \u2705 Always up-to-date with official LIFX products - \u2705 Accurate capability detection (extended multizone, IR, HEV, etc.) - \u2705 Firmware requirement tracking - \u26a0\ufe0f Must regenerate when new products are released - \u26a0\ufe0f Requires manual specs.yml updates for new multizone/matrix products</p> <p>DO NOT EDIT: <code>products/registry.py:1</code></p> <p>Regenerate with: <pre><code>python -m lifx_emulator.products.generator\n</code></pre></p> <p>Reference: <code>products/generator.py:1</code></p>"},{"location":"architecture/decisions/#adr-006-async-file-persistence-with-debouncing","title":"ADR-006: Async File Persistence with Debouncing","text":"<p>Status: Adopted</p> <p>Context: Device state changes frequently (color, power, zones). Synchronous I/O on every change would block the event loop and cause performance issues.</p> <p>Decision: Implement async file persistence with debouncing: - Queue state changes in memory - Debounce writes (100ms default) - Async file I/O (aiofiles) - Graceful shutdown flushes pending writes</p> <p>Consequences: - \u2705 Non-blocking I/O - doesn't slow down packet processing - \u2705 Reduced disk writes - batches rapid changes - \u2705 Automatic - no manual save() calls required - \u26a0\ufe0f State changes have eventual consistency (100ms delay) - \u26a0\ufe0f Must call shutdown() for clean exit</p> <p>Implementation: <code>devices/persistence.py:1</code> - <code>DevicePersistenceAsyncFile</code></p> <p>Usage: <pre><code>storage = DevicePersistenceAsyncFile()\ndevice = create_color_light(\"d073d5000001\", storage=storage)\n\n# State changes auto-save asynchronously\ndevice.state.label = \"My Light\"\n\n# Graceful shutdown\nawait storage.shutdown()\n</code></pre></p> <p>Reference: <code>docs/library/storage.md:1</code></p>"},{"location":"architecture/decisions/#adr-007-handler-registry-pattern","title":"ADR-007: Handler Registry Pattern","text":"<p>Status: Adopted</p> <p>Context: The emulator must handle 44+ different packet types with varying complexity. A single giant switch statement would violate Single Responsibility Principle.</p> <p>Decision: Use a handler registry pattern: - Separate handler modules by packet namespace (Device, Light, MultiZone, Tile) - Registry maps packet type \u2192 handler function - Handlers are pure functions (state in, responses out)</p> <p>Consequences: - \u2705 Separation of Concerns - each handler is independent - \u2705 Easy to add new packet types - \u2705 Testable - handlers are pure functions - \u2705 Organized by protocol namespace - \u26a0\ufe0f Must register new handlers in registry</p> <p>Implementation: <pre><code>handlers/\n\u251c\u2500\u2500 registry.py           # PacketHandlerRegistry\n\u251c\u2500\u2500 device_handlers.py    # Device.* packets (types 2-59)\n\u251c\u2500\u2500 light_handlers.py     # Light.* packets (types 101-149)\n\u251c\u2500\u2500 multizone_handlers.py # MultiZone.* packets (types 501-512)\n\u2514\u2500\u2500 tile_handlers.py      # Tile.* packets (types 701-720)\n</code></pre></p> <p>Reference: <code>docs/architecture/packet-flow.md:1</code></p>"},{"location":"architecture/decisions/#adr-008-dataclass-based-state-management","title":"ADR-008: Dataclass-Based State Management","text":"<p>Status: Adopted</p> <p>Context: Device state is complex and varies by device type. Need type-safe, validated state representation.</p> <p>Decision: Use nested dataclasses with capability flags:</p> <pre><code>@dataclass\nclass DeviceState:\n    core: CoreDeviceState           # Always present\n    color: ColorState | None        # Only for color devices\n    infrared: InfraredState | None\n    hev: HevState | None\n    multizone: MultiZoneState | None\n    matrix: MatrixState | None\n    relay: RelayState | None\n\n    # Capability flags\n    has_color: bool\n    has_infrared: bool\n    # ... etc\n</code></pre> <p>Consequences: - \u2705 Type-safe with Pyright validation - \u2705 Clear capability detection (has_color, has_multizone, etc.) - \u2705 Easy to serialize/deserialize - \u2705 Immutable-by-default with frozen=True option - \u26a0\ufe0f Must update serialization when adding fields - \u26a0\ufe0f Capability flags must stay in sync with state fields</p> <p>Implementation: <code>devices/states.py:1</code></p> <p>Reference: <code>docs/architecture/device-state.md:1</code></p>"},{"location":"architecture/decisions/#adr-009-hierarchical-scenario-management","title":"ADR-009: Hierarchical Scenario Management","text":"<p>Status: Adopted</p> <p>Context: Testing scenarios need to apply at different scopes (specific device, all multizone devices, entire server). Need a consistent resolution strategy.</p> <p>Decision: Implement 5-level hierarchical scenario system with precedence:</p> <ol> <li>Device-specific (serial)</li> <li>Device-type (color, multizone, matrix, hev, infrared, extended_multizone)</li> <li>Location-based (all devices in location)</li> <li>Group-based (all devices in group)</li> <li>Global (all devices)</li> </ol> <p>Higher precedence wins, with field-level merging.</p> <p>Consequences: - \u2705 Flexible test scenario targeting - \u2705 Clear precedence rules (no ambiguity) - \u2705 Field-level merging allows partial overrides - \u2705 Cache invalidation for performance - \u26a0\ufe0f Complex scenario resolution logic - \u26a0\ufe0f Developers must understand precedence rules</p> <p>Example: <pre><code>manager = HierarchicalScenarioManager()\n\n# Global: drop 50% of packets\nmanager.set_global_scenario(ScenarioConfig(drop_packets={101: 0.5}))\n\n# Type: all multizone devices delay responses\nmanager.set_type_scenario(\"multizone\", ScenarioConfig(response_delays={506: 0.2}))\n\n# Device: specific device drops 100% (overrides global)\nmanager.set_device_scenario(\"d073d5000001\", ScenarioConfig(drop_packets={101: 1.0}))\n</code></pre></p> <p>Implementation: <code>scenarios/manager.py:1</code></p> <p>Reference: <code>docs/guide/testing-scenarios.md:1</code>, <code>docs/cli/scenario-api.md:1</code></p>"},{"location":"architecture/decisions/#adr-010-factory-pattern-for-device-creation","title":"ADR-010: Factory Pattern for Device Creation","text":"<p>Status: Adopted</p> <p>Context: Creating devices requires complex configuration (product specs, firmware versions, zone counts, default colors). Direct instantiation is error-prone.</p> <p>Decision: Provide factory functions and builder pattern:</p> <p>Simple factories (<code>factories/factory.py:1</code>): <pre><code>create_color_light(serial, storage)\ncreate_multizone_light(serial, zone_count, extended_multizone, storage)\ncreate_tile_device(serial, tile_count, storage)\ncreate_device(product_id, serial, zone_count, tile_count, storage)\n</code></pre></p> <p>Builder pattern (<code>factories/builder.py:1</code>): <pre><code>device = (\n    DeviceBuilder()\n    .with_serial(\"d073d5000001\")\n    .with_product(27)\n    .with_color_support()\n    .build()\n)\n</code></pre></p> <p>Consequences: - \u2705 Encapsulates complex initialization logic - \u2705 Product defaults automatically applied - \u2705 Firmware version logic centralized - \u2705 Easy to test (no direct EmulatedLifxDevice construction) - \u26a0\ufe0f Must update factories when adding device types</p> <p>Reference: <code>docs/library/factories.md:1</code></p>"},{"location":"architecture/decisions/#adr-011-observer-pattern-for-state-changes","title":"ADR-011: Observer Pattern for State Changes","text":"<p>Status: Adopted</p> <p>Context: Multiple components need to react to device state changes (persistence, activity logging, metrics). Direct coupling would violate Open/Closed Principle.</p> <p>Decision: Implement observer pattern for device state changes:</p> <pre><code>class ActivityObserver(Protocol):\n    def on_packet_sent(self, event: PacketEvent): ...\n    def on_packet_received(self, event: PacketEvent): ...\n    def on_state_changed(self, device: EmulatedLifxDevice): ...\n</code></pre> <p>Consequences: - \u2705 Decoupled components - \u2705 Easy to add new observers (plugins, metrics, etc.) - \u2705 Type-safe with Protocol - \u26a0\ufe0f Must carefully manage observer lifecycle - \u26a0\ufe0f Performance impact with many observers</p> <p>Implementations: - <code>ActivityLogger</code> - Logs packet activity - <code>NullObserver</code> - No-op for testing - Custom observers can be added</p> <p>Reference: <code>devices/observers.py:1</code></p>"},{"location":"architecture/decisions/#adr-012-openapi-310-compliance-for-http-api","title":"ADR-012: OpenAPI 3.1.0 Compliance for HTTP API","text":"<p>Status: Adopted</p> <p>Context: The HTTP API needs to be discoverable, testable, and well-documented. Manual API documentation gets out of sync.</p> <p>Decision: Use FastAPI with Pydantic for automatic OpenAPI 3.1.0 schema generation: - Pydantic models for request/response validation - Automatic schema generation - Interactive Swagger UI at <code>/docs</code> - ReDoc documentation at <code>/redoc</code></p> <p>Consequences: - \u2705 Self-documenting API - \u2705 Type-safe request/response handling - \u2705 Interactive testing via Swagger UI - \u2705 Schema always in sync with code - \u26a0\ufe0f Must use Pydantic models (no plain dicts) - \u26a0\ufe0f OpenAPI limitations for complex scenarios</p> <p>Endpoints: - <code>/openapi.json</code> - OpenAPI 3.1.0 schema - <code>/docs</code> - Swagger UI - <code>/redoc</code> - ReDoc</p> <p>Implementation: <code>api/app.py:1</code>, <code>api/models.py:1</code></p> <p>Reference: <code>docs/cli/device-management-api.md:1</code></p>"},{"location":"architecture/decisions/#adr-013-capability-based-packet-filtering","title":"ADR-013: Capability-Based Packet Filtering","text":"<p>Status: Adopted</p> <p>Context: LIFX Switch devices have relays and buttons but no lighting control. Need to correctly reject unsupported packet types.</p> <p>Decision: Use capability flags to filter packets before processing: - Devices set capability flags: <code>has_color</code>, <code>has_multizone</code>, <code>has_matrix</code>, <code>has_relays</code>, <code>has_buttons</code> - Switch devices (<code>has_relays=True</code>, <code>has_buttons=True</code>) return <code>StateUnhandled</code> for Light/MultiZone/Tile packets - Device.* packets are handled normally</p> <p>Consequences: - \u2705 Accurate device behavior (switches don't handle light packets) - \u2705 Clear capability detection - \u2705 Easy to add new device types with different capabilities - \u26a0\ufe0f Must update filtering logic when adding capabilities</p> <p>Example (<code>devices/device.py:1</code>): <pre><code># Switches reject lighting packets\nif not self.state.has_color and pkt_type in LIGHT_PACKET_TYPES:\n    return StateUnhandled(unhandled_type=pkt_type)\n</code></pre></p> <p>Reference: <code>docs/guide/device-types.md:1</code></p>"},{"location":"architecture/decisions/#adr-014-lazy-initialization-for-tile-framebuffers","title":"ADR-014: Lazy Initialization for Tile Framebuffers","text":"<p>Status: Adopted</p> <p>Context: Matrix devices support 8 framebuffers (0-7), but most only use framebuffer 0. Pre-allocating all framebuffers wastes memory.</p> <p>Decision: Implement lazy initialization with <code>get_framebuffer(fb_index, width, height)</code>: - Framebuffer 0 stored in <code>tile_devices[i][\"colors\"]</code> (protocol-defined) - Framebuffers 1-7 lazily initialized on first access - Internal dataclass <code>TileFramebuffers</code> manages non-visible buffers</p> <p>Consequences: - \u2705 Memory efficient (only allocate what's used) - \u2705 Supports advanced rendering workflows - \u2705 Backwards compatible (framebuffer 0 always available) - \u26a0\ufe0f More complex state management - \u26a0\ufe0f Must handle CopyFrameBuffer with lazy init</p> <p>Implementation: <code>devices/states.py:1</code> - <code>MatrixState</code> class</p> <p>Reference: <code>docs/guide/framebuffers.md:1</code></p>"},{"location":"architecture/decisions/#adr-015-atomic-file-writes-for-scenario-persistence","title":"ADR-015: Atomic File Writes for Scenario Persistence","text":"<p>Status: Adopted</p> <p>Context: Scenario files must be consistent even if the process crashes during write. Partial writes would corrupt the scenario configuration.</p> <p>Decision: Use atomic file writes: 1. Write to temporary file 2. fsync() to flush to disk 3. Atomic rename to final path</p> <p>Consequences: - \u2705 Crash-safe writes - \u2705 No partial/corrupted files - \u2705 POSIX guarantees on rename atomicity - \u26a0\ufe0f Requires temp file cleanup on errors - \u26a0\ufe0f Slightly slower than direct writes</p> <p>Implementation: <code>scenarios/persistence.py:1</code> - <code>ScenarioPersistenceAsyncFile</code></p>"},{"location":"architecture/decisions/#summary-of-key-patterns","title":"Summary of Key Patterns","text":""},{"location":"architecture/decisions/#design-patterns-used","title":"Design Patterns Used","text":"<ul> <li>Repository Pattern - Storage abstraction</li> <li>Factory Pattern - Device creation</li> <li>Builder Pattern - Flexible configuration</li> <li>Observer Pattern - State change notifications</li> <li>Handler Registry - Packet type routing</li> <li>Dependency Injection - Testable architecture</li> <li>Protocol Interfaces - Type-safe contracts</li> </ul>"},{"location":"architecture/decisions/#architectural-principles","title":"Architectural Principles","text":"<ul> <li>Single Responsibility - Each layer/class has one purpose</li> <li>Dependency Inversion - Depend on interfaces, not implementations</li> <li>Open/Closed - Open for extension, closed for modification</li> <li>Separation of Concerns - Network, domain, persistence are independent</li> <li>DRY - Auto-generation for protocol and products</li> </ul>"},{"location":"architecture/decisions/#performance-optimizations","title":"Performance Optimizations","text":"<ul> <li>Async I/O with debouncing (persistence)</li> <li>Scenario caching (invalidation on config change)</li> <li>Lazy initialization (tile framebuffers)</li> <li>Pre-built product registry (no runtime parsing)</li> </ul>"},{"location":"architecture/decisions/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview</li> <li>Code Navigation Guide</li> <li>Library Reference</li> <li>Best Practices</li> </ul>"},{"location":"architecture/device-state/","title":"Device State","text":"<p>Coming soon.</p>"},{"location":"architecture/overview/","title":"Architecture Overview","text":"<p>The LIFX Emulator is built with a layered architecture that mirrors real LIFX devices.</p>"},{"location":"architecture/overview/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>graph TB\n    Client[LIFX Client Library]\n    Server[EmulatedLifxServer]\n    Device1[EmulatedLifxDevice]\n    Device2[EmulatedLifxDevice]\n    Device3[EmulatedLifxDevice]\n    Protocol[Protocol Layer]\n    State[DeviceState]\n\n    Client --&gt;|UDP Packets| Server\n    Server --&gt;|Route by Serial| Device1\n    Server --&gt;|Route by Serial| Device2\n    Server --&gt;|Route by Serial| Device3\n    Device1 --&gt;|Parse/Pack| Protocol\n    Device2 --&gt;|Parse/Pack| Protocol\n    Device3 --&gt;|Parse/Pack| Protocol\n    Device1 --&gt;|Read/Write| State\n    Device2 --&gt;|Read/Write| State\n    Device3 --&gt;|Read/Write| State</code></pre>"},{"location":"architecture/overview/#core-components","title":"Core Components","text":""},{"location":"architecture/overview/#1-server-layer-emulatedlifxserver","title":"1. Server Layer (<code>EmulatedLifxServer</code>)","text":"<p>The server layer handles:</p> <ul> <li>UDP socket management</li> <li>Packet reception and sending</li> <li>Device routing by serial (encoded in target field)</li> <li>Broadcast packet distribution</li> </ul> <p>Key Responsibilities: - Listen on configured IP and port - Parse packet headers to determine routing - Forward packets to appropriate devices - Send responses back to clients</p>"},{"location":"architecture/overview/#2-device-layer-emulatedlifxdevice","title":"2. Device Layer (<code>EmulatedLifxDevice</code>)","text":"<p>Each device instance represents a virtual LIFX device:</p> <ul> <li>Maintains device state</li> <li>Processes incoming packets</li> <li>Generates response packets</li> <li>Handles device-specific logic</li> </ul> <p>Key Responsibilities: - Process packet type routing - Update state based on commands - Generate appropriate responses - Implement device capabilities</p>"},{"location":"architecture/overview/#3-protocol-layer","title":"3. Protocol Layer","text":"<p>The protocol layer implements LIFX LAN protocol:</p> <ul> <li>Binary packet serialization/deserialization</li> <li>Header parsing and generation</li> <li>Packet type definitions</li> <li>Type conversions</li> </ul> <p>Components: - <code>LifxHeader</code> - 36-byte header structure - Packet classes - 44+ packet type definitions - <code>Serializer</code> - Binary packing/unpacking - Protocol types - <code>LightHsbk</code>, <code>TileStateDevice</code>, etc.</p>"},{"location":"architecture/overview/#4-state-layer-devicestate","title":"4. State Layer (<code>DeviceState</code>)","text":"<p>Device state is stored in a dataclass:</p> <ul> <li>Device identity (serial, label, product)</li> <li>Capability flags (color, infrared, multizone, etc.)</li> <li>Light state (power, color, zones, tiles)</li> <li>Firmware version</li> <li>Network configuration</li> </ul>"},{"location":"architecture/overview/#packet-flow","title":"Packet Flow","text":"<pre><code>sequenceDiagram\n    participant Client\n    participant Server\n    participant Device\n    participant Protocol\n    participant State\n\n    Client-&gt;&gt;Server: UDP Packet\n    Server-&gt;&gt;Protocol: Parse Header\n    Protocol--&gt;&gt;Server: LifxHeader\n    Server-&gt;&gt;Device: Route by target serial\n    Device-&gt;&gt;Protocol: Unpack Payload\n    Protocol--&gt;&gt;Device: Packet Object\n    Device-&gt;&gt;State: Update State\n    Device-&gt;&gt;Protocol: Generate Response\n    Protocol--&gt;&gt;Device: Packed Response\n    Device--&gt;&gt;Server: Response Packet(s)\n    Server-&gt;&gt;Client: UDP Response</code></pre>"},{"location":"architecture/overview/#detailed-flow","title":"Detailed Flow","text":"<ol> <li>Reception</li> <li>Client sends UDP packet to server</li> <li> <p>Server receives bytes on socket</p> </li> <li> <p>Header Parsing</p> </li> <li>Extract 36-byte header</li> <li>Parse: target (serial + padding), packet type, flags</li> <li> <p>Determine if broadcast or targeted</p> </li> <li> <p>Device Routing</p> </li> <li>If broadcast (tagged=True or target=000000000000): forward to all devices</li> <li>If targeted: find device by serial (encoded in target field)</li> <li> <p>If not found: ignore packet</p> </li> <li> <p>Packet Processing</p> </li> <li>Device unpacks payload using packet class</li> <li>Determines packet type (e.g., LightSetColor)</li> <li> <p>Routes to specific handler method</p> </li> <li> <p>State Update</p> </li> <li>Handler reads current state</li> <li>Applies command logic</li> <li> <p>Updates state fields</p> </li> <li> <p>Response Generation</p> </li> <li>If <code>res_required=True</code>: generate state response</li> <li>If <code>ack_required=True</code>: generate acknowledgment</li> <li> <p>Create response header with sequence number</p> </li> <li> <p>Response Sending</p> </li> <li>Pack response packets to bytes</li> <li>Send back to client via UDP</li> </ol>"},{"location":"architecture/overview/#layer-details","title":"Layer Details","text":""},{"location":"architecture/overview/#server-layer","title":"Server Layer","text":"<pre><code>class EmulatedLifxServer:\n    \"\"\"UDP server that routes packets to devices.\"\"\"\n\n    def __init__(self, devices, bind_address, port):\n        self._devices = {d.state.serial: d for d in devices}\n        self._bind_address = bind_address\n        self._port = port\n\n    async def start(self):\n        \"\"\"Start UDP server.\"\"\"\n        pass\n\n    def handle_packet(self, data, addr):\n        \"\"\"Route incoming packet to device(s).\"\"\"\n        # Parse header\n        # Find target device(s)\n        # Process and send responses\n        pass\n</code></pre>"},{"location":"architecture/overview/#device-layer","title":"Device Layer","text":"<pre><code>class EmulatedLifxDevice:\n    \"\"\"Virtual LIFX device with stateful behavior.\"\"\"\n\n    def __init__(self, state: DeviceState):\n        self.state = state\n        self.scenarios = {}  # Testing scenarios\n\n    def process_packet(self, header, packet):\n        \"\"\"Process incoming packet and generate responses.\"\"\"\n        # Handle acknowledgments\n        # Route to packet-specific handler\n        # Generate response packets\n        pass\n\n    def _handle_light_set_color(self, packet):\n        \"\"\"Handle LightSetColor command.\"\"\"\n        # Update self.state.color\n        # Return response if needed\n        pass\n</code></pre>"},{"location":"architecture/overview/#protocol-layer","title":"Protocol Layer","text":"<pre><code>class LifxHeader:\n    \"\"\"36-byte LIFX packet header.\"\"\"\n\n    def __init__(self, ...):\n        self.target = target        # 6-byte serial + 2 null bytes\n        self.source = source        # 4-byte identifier\n        self.sequence = sequence    # 1-byte sequence number\n        self.pkt_type = pkt_type    # Packet type number\n        self.tagged = tagged        # tagged\n        # ... more fields\n\n    def pack(self) -&gt; bytes:\n        \"\"\"Pack header to 36 bytes.\"\"\"\n        pass\n\n    @classmethod\n    def unpack(cls, data: bytes):\n        \"\"\"Parse 36 bytes to header.\"\"\"\n        pass\n</code></pre>"},{"location":"architecture/overview/#state-layer","title":"State Layer","text":"<pre><code>@dataclass\nclass DeviceState:\n    \"\"\"Device state storage.\"\"\"\n\n    # Identity\n    serial: str\n    label: str\n    vendor: int\n    product: int\n\n    # Capabilities\n    has_color: bool\n    has_infrared: bool\n    has_multizone: bool\n    has_matrix: bool\n    has_hev: bool\n\n    # Light state\n    power_level: int\n    color: LightHsbk\n    zone_colors: list[LightHsbk]\n    tile_devices: list[TileState]\n\n    # ... more fields\n</code></pre>"},{"location":"architecture/overview/#capability-flags","title":"Capability Flags","text":"<p>Devices advertise capabilities through boolean flags:</p> Flag Capability Example Products <code>has_color</code> Full RGB color LIFX A19, LIFX Beam <code>has_infrared</code> IR brightness LIFX A19 Night Vision <code>has_multizone</code> Linear zones LIFX Z, LIFX Beam <code>has_extended_multizone</code> &gt;16 zones LIFX Beam <code>has_matrix</code> 2D zone grid LIFX Tile, LIFX Candle <code>has_hev</code> HEV cleaning LIFX Clean"},{"location":"architecture/overview/#packet-types","title":"Packet Types","text":"<p>The emulator implements 44+ packet types across multiple domains:</p>"},{"location":"architecture/overview/#device-domain-1-45","title":"Device Domain (1-45)","text":"<ul> <li>GetService (2) / StateService (3)</li> <li>GetVersion (32) / StateVersion (33)</li> <li>GetLabel (23) / StateLabel (25)</li> <li>SetLabel (24)</li> <li>GetPower (20) / StatePower (22)</li> <li>SetPower (21)</li> </ul>"},{"location":"architecture/overview/#light-domain-100-122","title":"Light Domain (100-122)","text":"<ul> <li>LightGet (101) / LightState (107)</li> <li>LightSetColor (102)</li> <li>LightSetWaveform (103)</li> <li>LightGetInfrared (120) / LightStateInfrared (121)</li> <li>LightSetInfrared (122)</li> </ul>"},{"location":"architecture/overview/#multizone-domain-500-512","title":"MultiZone Domain (500-512)","text":"<ul> <li>GetColorZones (502) / StateZone (503)</li> <li>StateMultiZone (506)</li> <li>SetColorZones (501)</li> <li>GetMultiZoneEffect (507) / StateMultiZoneEffect (508)</li> <li>SetMultiZoneEffect (509)</li> <li>SetExtendedColorZones (510)</li> <li>GetExtendedColorZones (511) / StateExtendedColorZones (512)</li> </ul>"},{"location":"architecture/overview/#tile-domain-700-719","title":"Tile Domain (700-719)","text":"<ul> <li>GetDeviceChain (701) / StateDeviceChain (702)</li> <li>SetUserPosition (703)</li> <li>GetTileState64 (707) / StateTileState64 (711)</li> <li>SetTileState64 (715)</li> <li>GetTileEffect (718) / StateTileEffect (719)</li> </ul> <p>See Protocol Layer for complete packet documentation.</p>"},{"location":"architecture/overview/#design-patterns","title":"Design Patterns","text":""},{"location":"architecture/overview/#factory-pattern","title":"Factory Pattern","text":"<p>Factory functions encapsulate device creation:</p> <pre><code>def create_color_light(serial=None):\n    \"\"\"Create LIFX A19 with sensible defaults.\"\"\"\n    return create_device(27, serial=serial)\n</code></pre>"},{"location":"architecture/overview/#strategy-pattern","title":"Strategy Pattern","text":"<p>Packet handlers implement strategy pattern:</p> <pre><code>def process_packet(self, header, packet):\n    handler_map = {\n        LightSetColor: self._handle_light_set_color,\n        LightSetPower: self._handle_light_set_power,\n        # ... more handlers\n    }\n    handler = handler_map.get(type(packet))\n    if handler:\n        return handler(packet)\n</code></pre>"},{"location":"architecture/overview/#state-pattern","title":"State Pattern","text":"<p>Device state changes based on received commands:</p> <pre><code>def _handle_light_set_color(self, packet):\n    self.state.color = packet.color\n    self.state.power_level = packet.color.brightness\n</code></pre>"},{"location":"architecture/overview/#concurrency-model","title":"Concurrency Model","text":"<p>The emulator uses Python's asyncio:</p> <ul> <li>Single-threaded: All operations run in the event loop</li> <li>Non-blocking: Uses async/await for I/O</li> <li>Datagram protocol: UDP doesn't maintain connections</li> <li>Stateful devices: Each device maintains independent state</li> </ul> <pre><code>async with EmulatedLifxServer(devices, \"127.0.0.1\", 56700) as server:\n    # Server runs in background tasks\n    # Your test code runs concurrently\n    await asyncio.sleep(1)\n</code></pre>"},{"location":"architecture/overview/#testing-architecture","title":"Testing Architecture","text":"<p>The emulator supports advanced testing scenarios:</p> <pre><code>device.scenarios = {\n    'drop_packets': {101: 1.0},      # Drop all LightGet packets\n    'response_delays': {102: 0.5},   # Delay SetColor by 500ms\n    'malformed_packets': [107],      # Truncate StateLight\n    'invalid_field_values': [22],    # Send invalid StatePower\n    'partial_responses': [506],      # Incomplete multizone response\n}\n</code></pre>"},{"location":"architecture/overview/#next-steps","title":"Next Steps","text":"<ul> <li>Packet Flow - Detailed packet processing</li> <li>Protocol Layer - Protocol implementation details</li> <li>Device State - State management</li> <li>Server API - Server documentation</li> </ul>"},{"location":"architecture/packet-flow/","title":"Packet Flow","text":"<p>Coming soon.</p>"},{"location":"architecture/protocol/","title":"Protocol","text":"<p>Coming soon.</p>"},{"location":"changelogs/","title":"CHANGELOG","text":"<p>Note</p> <p>The lifx-emulator package was split into two packages after v2.4.0 and were release separately for the first time as v3.0.1.</p>"},{"location":"changelogs/#current","title":"Current","text":"<ul> <li><code>lifx-emulator-core</code></li> <li><code>lifx-emulator</code></li> </ul>"},{"location":"changelogs/#original","title":"Original","text":"<ul> <li><code>lifx-emulator</code></li> </ul>"},{"location":"changelogs/app-changelog/","title":"CHANGELOG","text":""},{"location":"changelogs/app-changelog/#v302-2025-12-24","title":"v3.0.2 (2025-12-24)","text":""},{"location":"changelogs/app-changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>api: Eliminate XSS vulnerabilities and extract dashboard JavaScript   (<code>8302a09</code>)</li> </ul>"},{"location":"changelogs/app-changelog/#v301-2025-11-26","title":"v3.0.1 (2025-11-26)","text":""},{"location":"changelogs/app-changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Adjust uv build for new monorepo layout   (<code>a0d5b7c</code>)</li> </ul>"},{"location":"changelogs/app-changelog/#v300-2025-11-26","title":"v3.0.0 (2025-11-26)","text":""},{"location":"changelogs/app-changelog/#refactoring","title":"Refactoring","text":"<ul> <li>Split into monorepo with separate library and CLI packages   (<code>402fe6e</code>)</li> </ul>"},{"location":"changelogs/app-changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The project is now split into two packages:</li> </ul>"},{"location":"changelogs/app-changelog/#v240-2025-11-26","title":"v2.4.0 (2025-11-26)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"changelogs/changelog/","title":"CHANGELOG","text":""},{"location":"changelogs/changelog/#v240-2025-11-19","title":"v2.4.0 (2025-11-19)","text":""},{"location":"changelogs/changelog/#features","title":"Features","text":"<ul> <li>Implement LIFX Switch device emulation with StateUnhandled responses   (<code>e2f9114</code>)</li> </ul>"},{"location":"changelogs/changelog/#v231-2025-11-18","title":"v2.3.1 (2025-11-18)","text":""},{"location":"changelogs/changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>tile: Implement backwards compatibility on tile and multizone devices   (<code>be473f7</code>)</li> </ul>"},{"location":"changelogs/changelog/#v230-2025-11-18","title":"v2.3.0 (2025-11-18)","text":""},{"location":"changelogs/changelog/#features_1","title":"Features","text":"<ul> <li>tile: Implement multi-framebuffer support for matrix devices   (<code>16a69ca</code>)</li> </ul>"},{"location":"changelogs/changelog/#v221-2025-11-18","title":"v2.2.1 (2025-11-18)","text":""},{"location":"changelogs/changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>tile: Preserve SUNRISE sky type in GetEffect responses   (<code>70b2d48</code>)</li> </ul>"},{"location":"changelogs/changelog/#v220-2025-11-18","title":"v2.2.0 (2025-11-18)","text":""},{"location":"changelogs/changelog/#features_2","title":"Features","text":"<ul> <li>products: Add per-product firmware version defaults to specs.yml   (<code>336692c</code>)</li> </ul>"},{"location":"changelogs/changelog/#v210-2025-11-18","title":"v2.1.0 (2025-11-18)","text":""},{"location":"changelogs/changelog/#documentation","title":"Documentation","text":"<ul> <li>Add mkdocs-llmstxt to generate llms.txt and llms-full.txt   (<code>4ddea81</code>)</li> </ul>"},{"location":"changelogs/changelog/#features_3","title":"Features","text":"<ul> <li>protocol: Add Sky Effect support and protocol quirks   (<code>09422ab</code>)</li> </ul>"},{"location":"changelogs/changelog/#v200-2025-11-12","title":"v2.0.0 (2025-11-12)","text":""},{"location":"changelogs/changelog/#documentation_1","title":"Documentation","text":"<ul> <li>Restructure docs to improve logical flow   (<code>3b412c0</code>)</li> </ul>"},{"location":"changelogs/changelog/#refactoring","title":"Refactoring","text":"<ul> <li>Implement layered architecture with repository pattern and modular organization   (<code>53bf62e</code>)</li> </ul>"},{"location":"changelogs/changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li><code>EmulatedLifxServer</code> now requires <code>DeviceManager</code> as second parameter instead of   <code>DeviceRepository</code></li> </ul>"},{"location":"changelogs/changelog/#v102-2025-11-10","title":"v1.0.2 (2025-11-10)","text":""},{"location":"changelogs/changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Extended_multizone added to products correctly by generator   (<code>b6c4f78</code>)</li> </ul>"},{"location":"changelogs/changelog/#v101-2025-11-10","title":"v1.0.1 (2025-11-10)","text":""},{"location":"changelogs/changelog/#bug-fixes_3","title":"Bug Fixes","text":"<ul> <li>Scenarios are now properly applied to initial devices   (<code>4808512</code>)</li> </ul>"},{"location":"changelogs/changelog/#documentation_2","title":"Documentation","text":"<ul> <li>Replace lifx-async with lifx-emulator and update README.md   (<code>64ab6b6</code>)</li> </ul>"},{"location":"changelogs/changelog/#v100-2025-11-06","title":"v1.0.0 (2025-11-06)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"changelogs/core-changelog/","title":"CHANGELOG","text":""},{"location":"changelogs/core-changelog/#v303-2025-11-27","title":"v3.0.3 (2025-11-27)","text":""},{"location":"changelogs/core-changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>core: Update device port to match server port when adding devices   (<code>db68eef</code>)</li> </ul>"},{"location":"changelogs/core-changelog/#v302-2025-11-27","title":"v3.0.2 (2025-11-27)","text":""},{"location":"changelogs/core-changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>core: Add missing pydantic dependency to lifx-emulator-core   (<code>7cd2309</code>)</li> </ul>"},{"location":"changelogs/core-changelog/#v301-2025-11-26","title":"v3.0.1 (2025-11-26)","text":""},{"location":"changelogs/core-changelog/#bug-fixes_2","title":"Bug Fixes","text":"<ul> <li>Adjust uv build for new monorepo layout   (<code>a0d5b7c</code>)</li> </ul>"},{"location":"changelogs/core-changelog/#v300-2025-11-26","title":"v3.0.0 (2025-11-26)","text":""},{"location":"changelogs/core-changelog/#refactoring","title":"Refactoring","text":"<ul> <li>Split into monorepo with separate library and CLI packages   (<code>402fe6e</code>)</li> </ul>"},{"location":"changelogs/core-changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The project is now split into two packages:</li> </ul>"},{"location":"changelogs/core-changelog/#v240-2025-11-26","title":"v2.4.0 (2025-11-26)","text":"<ul> <li>Initial Release</li> </ul>"},{"location":"cli/","title":"lifx-emulator (Standalone CLI)","text":"<p>The <code>lifx-emulator</code> package provides a ready-to-run CLI tool and HTTP management server.</p>"},{"location":"cli/#overview","title":"Overview","text":"<p>This section covers the standalone emulator's advanced features for complex testing needs. These features are optional but powerful for:</p> <ul> <li>Maintaining device state across test runs</li> <li>Runtime device management</li> <li>Comprehensive error simulation</li> <li>Complex multi-scenario testing</li> </ul>"},{"location":"cli/#prerequisites","title":"Prerequisites","text":"<p>Before exploring advanced features, you should:</p> <ul> <li>Be comfortable with basic emulator usage</li> <li>Have completed at least the first 2-3 tutorials</li> <li>Understand your testing requirements</li> <li>Be familiar with REST APIs (for API features)</li> </ul>"},{"location":"cli/#learning-path","title":"Learning Path","text":"<p>Read these guides in order from simple to complex:</p> <ol> <li>Persistent Storage - Save device state across restarts</li> <li>Device Management API - Add/remove devices at runtime</li> <li>Scenarios - Comprehensive error simulation concepts</li> <li>Scenario API - REST API for managing test scenarios</li> </ol>"},{"location":"cli/#quick-concepts","title":"Quick Concepts","text":""},{"location":"cli/#persistent-storage","title":"Persistent Storage","text":"<p>Save device state (colors, labels, power) across emulator restarts:</p> <pre><code>lifx-emulator --persistent\n</code></pre> <p>Device states are saved to <code>~/.lifx-emulator/</code> and automatically restored.</p> <p>\ud83d\udc49 Storage Guide</p>"},{"location":"cli/#device-management-api","title":"Device Management API","text":"<p>Enable the HTTP API to manage devices at runtime:</p> <pre><code>lifx-emulator --api\n</code></pre> <p>Access the web dashboard at <code>http://localhost:8080</code> or use the REST API to add/remove devices dynamically.</p> <p>\ud83d\udc49 Device Management Guide</p>"},{"location":"cli/#testing-scenarios","title":"Testing Scenarios","text":"<p>Configure error conditions for comprehensive testing:</p> <ul> <li>Packet loss (test retries)</li> <li>Response delays (test timeouts)</li> <li>Malformed data (test error handling)</li> <li>Firmware version overrides</li> </ul> <p>\ud83d\udc49 Scenarios Guide</p>"},{"location":"cli/#scenario-api","title":"Scenario API","text":"<p>Manage scenarios via REST API with hierarchical scoping:</p> <pre><code># Drop 100% of GetColor packets for all color devices\ncurl -X PUT http://localhost:8080/api/scenarios/types/color \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 1.0}}'\n</code></pre> <p>Supports device-specific, type-based, location-based, group-based, and global scenarios.</p> <p>\ud83d\udc49 Scenario API Reference</p>"},{"location":"cli/#feature-comparison","title":"Feature Comparison","text":"Feature Basic Advanced Create devices \u2705 \u2705 Device discovery \u2705 \u2705 Control devices \u2705 \u2705 State persistence \u274c \u2705 Runtime management \u274c \u2705 Error simulation Basic Comprehensive Web UI \u274c \u2705 REST API \u274c \u2705"},{"location":"cli/#when-to-use-advanced-features","title":"When to Use Advanced Features","text":""},{"location":"cli/#use-persistent-storage-when","title":"Use Persistent Storage When:","text":"<ul> <li>Running long test suites where state matters</li> <li>Testing state restoration after failures</li> <li>Developing iteratively and want to preserve state</li> <li>Simulating real-world device persistence</li> </ul>"},{"location":"cli/#use-device-management-api-when","title":"Use Device Management API When:","text":"<ul> <li>Tests need dynamic device creation/removal</li> <li>Running multi-stage test scenarios</li> <li>Need visual monitoring during development</li> <li>Integrating with external test orchestration</li> </ul>"},{"location":"cli/#use-scenarios-when","title":"Use Scenarios When:","text":"<ul> <li>Testing retry logic and error handling</li> <li>Simulating network issues (packet loss, delays)</li> <li>Testing edge cases (malformed data, timeouts)</li> <li>Validating firmware version compatibility</li> <li>Testing client resilience</li> </ul>"},{"location":"cli/#combined-example","title":"Combined Example","text":"<p>Use multiple advanced features together:</p> <pre><code># Start with persistence, API, and scenarios\nlifx-emulator --persistent --api --color 2\n\n# Configure global scenario for packet loss\ncurl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 0.3}}'  # 30% packet loss\n\n# Add device at runtime\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 32, \"zone_count\": 16}'\n\n# Run your tests...\n# State persists across restarts\n</code></pre>"},{"location":"cli/#next-steps","title":"Next Steps","text":"<p>Choose a topic based on your needs, or read through all guides in order for comprehensive understanding.</p>"},{"location":"cli/cli-reference/","title":"CLI Usage","text":"<p>Complete guide to the <code>lifx-emulator</code> command-line interface.</p>"},{"location":"cli/cli-reference/#basic-usage","title":"Basic Usage","text":"<pre><code>lifx-emulator [OPTIONS] [COMMAND]\n</code></pre>"},{"location":"cli/cli-reference/#commands","title":"Commands","text":""},{"location":"cli/cli-reference/#lifx-emulator-default","title":"<code>lifx-emulator</code> (default)","text":"<p>Start the emulator server with configurable devices.</p> <p>Example: <pre><code>lifx-emulator --color 2 --multizone 1 --verbose\n</code></pre></p>"},{"location":"cli/cli-reference/#lifx-emulator-list-products","title":"<code>lifx-emulator list-products</code>","text":"<p>List all available LIFX products from the registry.</p> <p>Example: <pre><code>lifx-emulator list-products\n</code></pre></p> <p>With filter: <pre><code># List only multizone products\nlifx-emulator list-products --filter-type multizone\n\n# List only matrix products (tiles)\nlifx-emulator list-products --filter-type matrix\n</code></pre></p>"},{"location":"cli/cli-reference/#server-options","title":"Server Options","text":""},{"location":"cli/cli-reference/#-bind-ip","title":"<code>--bind &lt;IP&gt;</code>","text":"<p>IP address to bind to.</p> <ul> <li>Default: <code>127.0.0.1</code> (localhost only)</li> <li>Example: <code>--bind 0.0.0.0</code> (all IP addresses)</li> </ul>"},{"location":"cli/cli-reference/#-port-port","title":"<code>--port &lt;PORT&gt;</code>","text":"<p>UDP port to listen on.</p> <ul> <li>Default: <code>56700</code> (standard LIFX port)</li> <li>Example: <code>--port 56701</code></li> </ul>"},{"location":"cli/cli-reference/#-verbose","title":"<code>--verbose</code>","text":"<p>Enable verbose logging showing all packet traffic.</p> <ul> <li>Default: <code>False</code></li> <li>Example: <code>--verbose</code></li> </ul>"},{"location":"cli/cli-reference/#-persistent","title":"<code>--persistent</code>","text":"<p>Enable persistent storage of device state across sessions. Device state (label, power, color, location, group, etc.) is saved to <code>~/.lifx-emulator/</code> and automatically restored on restart.</p> <ul> <li>Default: <code>False</code></li> <li>Example: <code>--persistent</code></li> </ul>"},{"location":"cli/cli-reference/#-persistent-scenarios","title":"<code>--persistent-scenarios</code>","text":"<p>Enable persistent storage of scenario configurations across sessions. Scenarios are saved to <code>~/.lifx-emulator/scenarios.json</code>. Requires <code>--persistent</code> to be enabled.</p> <ul> <li>Default: <code>False</code></li> <li>Example: <code>--persistent --persistent-scenarios</code></li> </ul>"},{"location":"cli/cli-reference/#api-server-options","title":"API Server Options","text":""},{"location":"cli/cli-reference/#-api","title":"<code>--api</code>","text":"<p>Enable HTTP API server for monitoring and device management. Provides a web dashboard and REST API for runtime control.</p> <ul> <li>Default: <code>False</code></li> <li>Example: <code>--api</code></li> </ul>"},{"location":"cli/cli-reference/#-api-host-ip","title":"<code>--api-host &lt;IP&gt;</code>","text":"<p>IP address for the API server to bind to.</p> <ul> <li>Default: <code>127.0.0.1</code> (localhost only)</li> <li>Example: <code>--api-host 0.0.0.0</code></li> </ul>"},{"location":"cli/cli-reference/#-api-port-port","title":"<code>--api-port &lt;PORT&gt;</code>","text":"<p>Port for the API server.</p> <ul> <li>Default: <code>8080</code></li> <li>Example: <code>--api-port 9090</code></li> </ul>"},{"location":"cli/cli-reference/#-api-activity-bool","title":"<code>--api-activity &lt;BOOL&gt;</code>","text":"<p>Enable activity logging in the API (last 100 packets). Disable to reduce traffic and save UI space.</p> <ul> <li>Default: <code>True</code></li> <li>Example: <code>--api-activity=false</code></li> </ul>"},{"location":"cli/cli-reference/#product-selection","title":"Product Selection","text":""},{"location":"cli/cli-reference/#-product-product-id","title":"<code>--product &lt;product ID&gt;</code>","text":"<p>Create devices by product ID from the registry. Can be specified multiple times.</p> <p>Example: <pre><code># Create LIFX A19 (27) and LIFX Z (32)\nlifx-emulator --product 27 --product 32\n\n# Create multiple of same product\nlifx-emulator --product 55 --product 55 --product 55\n</code></pre></p> <p>When using <code>--product</code>, the default <code>--color 1</code> is suppressed unless explicitly set.</p>"},{"location":"cli/cli-reference/#device-type-options","title":"Device Type Options","text":""},{"location":"cli/cli-reference/#-color-count","title":"<code>--color &lt;COUNT&gt;</code>","text":"<p>Number of color lights to emulate (LIFX A19).</p> <ul> <li>Default: <code>1</code></li> <li>Product: 27 (LIFX A19)</li> <li>Example: <code>--color 3</code></li> </ul>"},{"location":"cli/cli-reference/#-color-temperature-count","title":"<code>--color-temperature &lt;COUNT&gt;</code>","text":"<p>Number of color temperature lights to emulate (LIFX Mini White to Warm).</p> <ul> <li>Default: <code>0</code></li> <li>Product: 50 (LIFX Mini White to Warm)</li> <li>Example: <code>--color-temperature 2</code></li> </ul>"},{"location":"cli/cli-reference/#-infrared-count","title":"<code>--infrared &lt;COUNT&gt;</code>","text":"<p>Number of infrared lights to emulate (LIFX A19 Night Vision).</p> <ul> <li>Default: <code>0</code></li> <li>Product: 29 (LIFX A19 Night Vision)</li> <li>Example: <code>--infrared 1</code></li> </ul>"},{"location":"cli/cli-reference/#-hev-count","title":"<code>--HEV &lt;COUNT&gt;</code>","text":"<p>Number of HEV/Clean lights to emulate (LIFX Clean).</p> <ul> <li>Default: <code>0</code></li> <li>Product: 90 (LIFX Clean)</li> <li>Example: <code>--HEV 2</code></li> </ul>"},{"location":"cli/cli-reference/#-multizone-count","title":"<code>--multizone &lt;COUNT&gt;</code>","text":"<p>Number of multizone devices to emulate (strips/beams).</p> <ul> <li>Default: <code>0</code></li> <li>Product: 32 (LIFX Z) or 38 (LIFX Beam with extended)</li> <li>Example: <code>--multizone 2</code></li> </ul>"},{"location":"cli/cli-reference/#-multizone-zones-count","title":"<code>--multizone-zones &lt;COUNT&gt;</code>","text":"<p>Number of zones per multizone device. If not specified, uses product defaults:</p> <ul> <li>LIFX Z: 16 zones</li> <li> <p>LIFX Beam: 80 zones</p> </li> <li> <p>Default: <code>None</code> (uses product defaults)</p> </li> <li>Example: <code>--multizone-zones 24</code></li> </ul>"},{"location":"cli/cli-reference/#-multizone-extended-no-multizone-extended","title":"<code>--multizone-extended</code> / <code>--no-multizone-extended</code>","text":"<p>Enable or disable extended multizone support for multizone devices.</p> <ul> <li>Default: <code>True</code> (creates LIFX Beam with firmware 3.70)</li> <li>Enabled: <code>--multizone-extended</code> (default, firmware 3.70)</li> <li>Disabled: <code>--no-multizone-extended</code> (creates LIFX Z, firmware 2.60)</li> <li>Example: <code>--no-multizone-extended --multizone-zones 16</code></li> </ul>"},{"location":"cli/cli-reference/#-tile-count","title":"<code>--tile &lt;COUNT&gt;</code>","text":"<p>Number of tile devices to emulate (LIFX Tile).</p> <ul> <li>Default: <code>0</code></li> <li>Product: 55 (LIFX Tile)</li> <li>Example: <code>--tile 1</code></li> </ul>"},{"location":"cli/cli-reference/#-tile-count-count","title":"<code>--tile-count &lt;COUNT&gt;</code>","text":"<p>Number of tiles per tile device. If not specified, uses product default (5 for LIFX Tile).</p> <ul> <li>Default: <code>None</code> (uses product defaults)</li> <li>Example: <code>--tile-count 10</code></li> </ul>"},{"location":"cli/cli-reference/#-tile-width-zones","title":"<code>--tile-width &lt;zones&gt;</code>","text":"<p>Width of each tile in zones. If not specified, uses product default (typically 8).</p> <ul> <li>Default: <code>None</code> (uses product defaults)</li> <li>Example: <code>--tile-width 16</code></li> </ul>"},{"location":"cli/cli-reference/#-tile-height-zones","title":"<code>--tile-height &lt;zones&gt;</code>","text":"<p>Height of each tile in zones. If not specified, uses product default (typically 8).</p> <ul> <li>Default: <code>None</code> (uses product defaults)</li> <li>Example: <code>--tile-height 8</code></li> </ul>"},{"location":"cli/cli-reference/#-switch-count","title":"<code>--switch &lt;COUNT&gt;</code>","text":"<p>Number of LIFX Switch devices to emulate (relay-based switches with no lighting).</p> <ul> <li>Default: <code>0</code></li> <li>Product: 70 (LIFX Switch)</li> <li>Example: <code>--switch 2</code></li> </ul> <p>Switch devices have <code>has_relays=True</code> and <code>has_buttons=True</code> capabilities but do not support Light, MultiZone, or Tile protocol packets. They respond with <code>StateUnhandled</code> (packet 223) to unsupported requests.</p>"},{"location":"cli/cli-reference/#serial-options","title":"serial Options","text":""},{"location":"cli/cli-reference/#-serial-prefix-prefix","title":"<code>--serial-prefix &lt;PREFIX&gt;</code>","text":"<p>serial prefix (6 hex characters).</p> <ul> <li>Default: <code>d073d5</code></li> <li>Example: <code>--serial-prefix cafe00</code></li> </ul> <p>serials are formatted as <code>&lt;prefix&gt;&lt;suffix&gt;</code> where suffix is auto-incremented starting from <code>serial-start</code>.</p>"},{"location":"cli/cli-reference/#-serial-start-number","title":"<code>--serial-start &lt;NUMBER&gt;</code>","text":"<p>Starting serial suffix.</p> <ul> <li>Default: <code>1</code></li> <li>Example: <code>--serial-start 100</code></li> </ul>"},{"location":"cli/cli-reference/#complete-examples","title":"Complete Examples","text":""},{"location":"cli/cli-reference/#default-configuration","title":"Default Configuration","text":"<pre><code># Single color light on port 56700\nlifx-emulator\n</code></pre>"},{"location":"cli/cli-reference/#verbose-mode","title":"Verbose Mode","text":"<pre><code># Show all packet traffic\nlifx-emulator --verbose\n</code></pre>"},{"location":"cli/cli-reference/#custom-port","title":"Custom Port","text":"<pre><code># Use port 56701\nlifx-emulator --port 56701\n</code></pre>"},{"location":"cli/cli-reference/#multiple-device-types","title":"Multiple Device Types","text":"<pre><code># 2 color lights, 1 multizone, 1 tile\nlifx-emulator --color 2 --multizone 1 --tile 1\n</code></pre>"},{"location":"cli/cli-reference/#extended-multizone","title":"Extended Multizone","text":"<pre><code># LIFX Beam with 60 zones\nlifx-emulator --multizone 1 --multizone-extended --multizone-zones 60\n</code></pre>"},{"location":"cli/cli-reference/#specific-products","title":"Specific Products","text":"<pre><code># LIFX A19, LIFX Z, and LIFX Tile\nlifx-emulator --product 27 --product 32 --product 55\n</code></pre>"},{"location":"cli/cli-reference/#mix-products-and-types","title":"Mix Products and Types","text":"<pre><code># Specific product + additional generic devices\nlifx-emulator --product 27 --color 2 --multizone 1\n</code></pre>"},{"location":"cli/cli-reference/#custom-serials","title":"Custom serials","text":"<pre><code># Custom prefix and starting number\nlifx-emulator --serial-prefix cafe00 --serial-start 100 --color 3\n# Creates: cafe00000064, cafe00000065, cafe00000066\n</code></pre>"},{"location":"cli/cli-reference/#only-specific-types","title":"Only Specific Types","text":"<pre><code># No default devices, only infrared, HEV, and switches\nlifx-emulator --color 0 --infrared 3 --HEV 2 --switch 2\n</code></pre>"},{"location":"cli/cli-reference/#discovery-testing","title":"Discovery Testing","text":"<pre><code># Create many devices for load testing\nlifx-emulator --color 10 --multizone 5 --tile 3\n</code></pre>"},{"location":"cli/cli-reference/#localhost-only","title":"Localhost Only","text":"<pre><code># Bind to localhost for security\nlifx-emulator --bind 127.0.0.1 --verbose\n</code></pre>"},{"location":"cli/cli-reference/#with-http-api","title":"With HTTP API","text":"<pre><code># Enable web dashboard and REST API\nlifx-emulator --api --color 2 --multizone 1\n\n# Custom API port\nlifx-emulator --api --api-port 9090\n\n# API without activity logging (reduces traffic)\nlifx-emulator --api --api-activity=false\n</code></pre>"},{"location":"cli/cli-reference/#persistent-storage","title":"Persistent Storage","text":"<pre><code># Enable state persistence\nlifx-emulator --persistent --color 2\n\n# Enable both state and scenario persistence\nlifx-emulator --persistent --persistent-scenarios --api\n</code></pre>"},{"location":"cli/cli-reference/#non-extended-multizone","title":"Non-Extended Multizone","text":"<pre><code># Create LIFX Z (non-extended, 16 zones max)\nlifx-emulator --multizone 2 --no-multizone-extended --multizone-zones 16\n</code></pre>"},{"location":"cli/cli-reference/#list-products-command","title":"List Products Command","text":""},{"location":"cli/cli-reference/#basic-list","title":"Basic List","text":"<pre><code>lifx-emulator list-products\n</code></pre> <p>Output: <pre><code>LIFX Product Registry (137 products)\n\n product ID \u2502 Product Name                              \u2502 Capabilities\n\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n  27 \u2502 LIFX A19                                  \u2502 full color\n  29 \u2502 LIFX A19 Night Vision                     \u2502 full color, infrared\n  32 \u2502 LIFX Z                                    \u2502 full color, multizone\n  38 \u2502 LIFX Beam                                 \u2502 full color, extended-multizone\n  55 \u2502 LIFX Tile                                 \u2502 full color, matrix\n  90 \u2502 LIFX Clean                                \u2502 full color, HEV\n ...\n</code></pre></p>"},{"location":"cli/cli-reference/#filter-by-type","title":"Filter by Type","text":"<pre><code># Only multizone products\nlifx-emulator list-products --filter-type multizone\n\n# Only matrix products\nlifx-emulator list-products --filter-type matrix\n\n# Only HEV products\nlifx-emulator list-products --filter-type HEV\n\n# Only infrared products\nlifx-emulator list-products --filter-type infrared\n\n# Only full color products\nlifx-emulator list-products --filter-type color\n</code></pre>"},{"location":"cli/cli-reference/#tips","title":"Tips","text":""},{"location":"cli/cli-reference/#quick-testing","title":"Quick Testing","text":"<p>For quick testing, use verbose mode to see all traffic:</p> <pre><code>lifx-emulator --verbose\n</code></pre>"},{"location":"cli/cli-reference/#visual-monitoring","title":"Visual Monitoring","text":"<p>Use the HTTP API for visual monitoring during development:</p> <pre><code>lifx-emulator --api --verbose\n# Open http://localhost:8080 in your browser\n</code></pre> <p>The web dashboard shows: - Real-time server statistics - List of all devices - Recent packet activity (last 100 packets) - REST API for runtime device management</p>"},{"location":"cli/cli-reference/#cicd-integration","title":"CI/CD Integration","text":"<p>Use specific ports and localhost binding in CI:</p> <pre><code>lifx-emulator --bind 127.0.0.1 --port 56701 &amp;\nEMULATOR_PID=$!\n# Run your tests\nkill $EMULATOR_PID\n</code></pre>"},{"location":"cli/cli-reference/#product-discovery","title":"Product Discovery","text":"<p>List products to find the right product ID for your tests:</p> <pre><code>lifx-emulator list-products --filter-type multizone\n</code></pre>"},{"location":"cli/cli-reference/#state-preservation","title":"State Preservation","text":"<p>Enable persistence to maintain device state across test runs:</p> <pre><code>lifx-emulator --persistent\n# Device labels, colors, power states persist across restarts\n</code></pre>"},{"location":"cli/cli-reference/#realistic-configurations","title":"Realistic Configurations","text":"<p>Use product defaults for realistic device configurations:</p> <pre><code># LIFX Beam with default 80 zones (extended by default)\nlifx-emulator --multizone 1\n\n# LIFX Tile with default 5 tiles\nlifx-emulator --tile 1\n</code></pre>"},{"location":"cli/cli-reference/#development-mode","title":"Development Mode","text":"<p>For development with full observability:</p> <pre><code># Verbose logging, API dashboard, persistent state\nlifx-emulator --verbose --api --persistent --color 2 --multizone 1\n</code></pre>"},{"location":"cli/cli-reference/#testing-mode","title":"Testing Mode","text":"<p>For testing network issues and edge cases:</p> <pre><code># API enabled for runtime scenario configuration\nlifx-emulator --api --color 3\n# Then use the REST API to configure packet loss, delays, etc.\n</code></pre>"},{"location":"cli/cli-reference/#next-steps","title":"Next Steps","text":"<ul> <li>Device Types Guide - Learn about each device type</li> <li>Testing Scenarios - Configure error scenarios</li> <li>API Reference - Python API documentation</li> <li>Tutorials - More usage examples</li> </ul>"},{"location":"cli/device-management-api/","title":"Device Management API","text":""},{"location":"cli/device-management-api/#overview","title":"Overview","text":"<p>The LIFX Emulator provides a comprehensive REST API for monitoring server status and managing emulated devices. The API is built with FastAPI and provides an OpenAPI 3.1.0 compliant specification.</p> <p>Base URL: <code>http://localhost:8080/api</code></p> <p>Interactive Documentation: - Swagger UI: <code>http://localhost:8080/docs</code> - ReDoc: <code>http://localhost:8080/redoc</code> - OpenAPI Schema: <code>http://localhost:8080/openapi.json</code></p>"},{"location":"cli/device-management-api/#quick-start","title":"Quick Start","text":""},{"location":"cli/device-management-api/#enable-the-api-server","title":"Enable the API Server","text":"<pre><code># Start emulator with API server\nlifx-emulator --api\n\n# Custom host and port\nlifx-emulator --api --api-host 127.0.0.1 --api-port 9090\n\n# Disable activity logging to reduce traffic\nlifx-emulator --api --api-activity=false\n</code></pre>"},{"location":"cli/device-management-api/#basic-examples","title":"Basic Examples","text":"<pre><code># Get server statistics\ncurl http://localhost:8080/api/stats\n\n# List all devices\ncurl http://localhost:8080/api/devices\n\n# Create a new color light (product 27)\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 27}'\n\n# Get specific device info\ncurl http://localhost:8080/api/devices/d073d5000001\n\n# Delete a device\ncurl -X DELETE http://localhost:8080/api/devices/d073d5000001\n\n# Get recent activity\ncurl http://localhost:8080/api/activity\n</code></pre>"},{"location":"cli/device-management-api/#monitoring-endpoints","title":"Monitoring Endpoints","text":""},{"location":"cli/device-management-api/#get-server-statistics","title":"Get Server Statistics","text":"<pre><code>GET /api/stats\n</code></pre> <p>Returns server uptime, packet counts, error counts, and device count.</p> <p>Response (200 OK): <pre><code>{\n  \"uptime_seconds\": 123.45,\n  \"start_time\": 1699564800.0,\n  \"device_count\": 3,\n  \"packets_received\": 1250,\n  \"packets_sent\": 2100,\n  \"packets_received_by_type\": {\n    \"2\": 50,\n    \"101\": 200,\n    \"102\": 300\n  },\n  \"packets_sent_by_type\": {\n    \"3\": 50,\n    \"107\": 200,\n    \"116\": 300\n  },\n  \"error_count\": 2,\n  \"activity_enabled\": true\n}\n</code></pre></p> <p>Use Cases: - Monitor emulator health and uptime - Track packet statistics by type - Verify API is running - Check error rates</p>"},{"location":"cli/device-management-api/#get-recent-activity","title":"Get Recent Activity","text":"<pre><code>GET /api/activity\n</code></pre> <p>Returns the last 100 packet events (TX/RX) with timestamps and packet details.</p> <p>Response (200 OK): <pre><code>[\n  {\n    \"timestamp\": 1699564923.456,\n    \"direction\": \"rx\",\n    \"packet_type\": 101,\n    \"packet_name\": \"GetColor\",\n    \"device\": \"d073d5000001\",\n    \"target\": \"00:00:00:00:00:00:00:00\",\n    \"addr\": \"192.168.1.100:54321\"\n  },\n  {\n    \"timestamp\": 1699564923.457,\n    \"direction\": \"tx\",\n    \"packet_type\": 107,\n    \"packet_name\": \"State\",\n    \"device\": \"d073d5000001\",\n    \"target\": \"192.168.1.100\",\n    \"addr\": \"192.168.1.100:54321\"\n  }\n]\n</code></pre></p> <p>Activity Event Fields: - <code>timestamp</code>: Unix timestamp of the packet - <code>direction</code>: \"rx\" (received) or \"tx\" (transmitted) - <code>packet_type</code>: Numeric packet type ID - <code>packet_name</code>: Human-readable packet name - <code>device</code>: Target device serial (if applicable) - <code>target</code>: LIFX protocol target field - <code>addr</code>: Client IP and port</p> <p>Use Cases: - Debugging LIFX client communication - Verifying packet flow - Monitoring protocol interactions - Testing packet handling</p> <p>Note: Activity logging must be enabled with <code>--api-activity</code> flag (default: true). Disable it to reduce traffic if not needed.</p>"},{"location":"cli/device-management-api/#device-management-endpoints","title":"Device Management Endpoints","text":""},{"location":"cli/device-management-api/#list-all-devices","title":"List All Devices","text":"<pre><code>GET /api/devices\n</code></pre> <p>Returns a list of all emulated devices with their current configuration.</p> <p>Response (200 OK): <pre><code>[\n  {\n    \"serial\": \"d073d5000001\",\n    \"label\": \"Living Room Light\",\n    \"product\": 27,\n    \"vendor\": 1,\n    \"power_level\": 65535,\n    \"has_color\": true,\n    \"has_infrared\": false,\n    \"has_multizone\": false,\n    \"has_extended_multizone\": false,\n    \"has_matrix\": false,\n    \"has_hev\": false,\n    \"zone_count\": 0,\n    \"tile_count\": 0,\n    \"color\": {\n      \"hue\": 32768,\n      \"saturation\": 65535,\n      \"brightness\": 65535,\n      \"kelvin\": 3500\n    },\n    \"zone_colors\": [],\n    \"tile_devices\": [],\n    \"version_major\": 3,\n    \"version_minor\": 70,\n    \"build_timestamp\": 0,\n    \"group_label\": \"\",\n    \"location_label\": \"\",\n    \"uptime_ns\": 123000000000,\n    \"wifi_signal\": -45.5\n  }\n]\n</code></pre></p> <p>Device Info Fields: - <code>serial</code>: Unique device identifier (12-char hex string) - <code>label</code>: Human-readable device label - <code>product</code>: LIFX product ID - <code>vendor</code>: Vendor ID (always 1 for LIFX) - <code>power_level</code>: 0 (off) or 65535 (on) - <code>has_*</code>: Boolean capability flags - <code>zone_count</code>: Number of multizone zones (if multizone) - <code>tile_count</code>: Number of tiles (if matrix device) - <code>color</code>: Current HSBK color (if color-capable) - <code>zone_colors</code>: Array of colors per zone (if multizone) - <code>tile_devices</code>: Tile configuration and colors (if matrix) - <code>version_major/minor</code>: Firmware version - <code>build_timestamp</code>: Build timestamp (usually 0) - <code>group_label</code>: Group assignment - <code>location_label</code>: Location assignment - <code>uptime_ns</code>: Device uptime in nanoseconds - <code>wifi_signal</code>: WiFi signal strength in dBm</p>"},{"location":"cli/device-management-api/#get-device-information","title":"Get Device Information","text":"<pre><code>GET /api/devices/{serial}\n</code></pre> <p>Returns detailed information about a specific device by its serial number.</p> <p>Path Parameters: - <code>serial</code>: Device serial number (e.g., <code>d073d5000001</code>)</p> <p>Response (200 OK): Same as list devices, but for a single device.</p> <p>Error Response (404): <pre><code>{\n  \"detail\": \"Device d073d5000001 not found\"\n}\n</code></pre></p> <p>Example: <pre><code>curl http://localhost:8080/api/devices/d073d5000001\n</code></pre></p>"},{"location":"cli/device-management-api/#create-device","title":"Create Device","text":"<pre><code>POST /api/devices\n</code></pre> <p>Creates a new emulated device by product ID. The device will be added to the emulator immediately.</p> <p>Request Body: <pre><code>{\n  \"product_id\": 27,\n  \"serial\": \"d073d5000099\",\n  \"zone_count\": 16,\n  \"tile_count\": 5,\n  \"tile_width\": 8,\n  \"tile_height\": 8,\n  \"firmware_major\": 3,\n  \"firmware_minor\": 70\n}\n</code></pre></p> <p>Request Fields: - <code>product_id</code> (required): LIFX product ID from registry - <code>serial</code> (optional): Device serial (auto-generated if not provided) - <code>zone_count</code> (optional): Number of zones for multizone devices - <code>tile_count</code> (optional): Number of tiles for matrix devices - <code>tile_width</code> (optional): Width of each tile in zones - <code>tile_height</code> (optional): Height of each tile in zones - <code>firmware_major</code> (optional): Firmware major version - <code>firmware_minor</code> (optional): Firmware minor version</p> <p>Response (201 Created): Same as get device response.</p> <p>Error Responses: - <code>400 Bad Request</code>: Invalid parameters   <pre><code>{\n  \"detail\": \"Failed to create device: Invalid product ID 9999\"\n}\n</code></pre> - <code>409 Conflict</code>: Duplicate serial   <pre><code>{\n  \"detail\": \"Device with serial d073d5000001 already exists\"\n}\n</code></pre></p> <p>Examples:</p> <pre><code># Create color light with auto-generated serial\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 27}'\n\n# Create multizone device with specific zone count\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"product_id\": 32,\n    \"zone_count\": 16\n  }'\n\n# Create tile device with specific count\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"product_id\": 55,\n    \"tile_count\": 3\n  }'\n\n# Create device with specific serial\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"product_id\": 27,\n    \"serial\": \"d073d5cafe00\"\n  }'\n</code></pre>"},{"location":"cli/device-management-api/#delete-device","title":"Delete Device","text":"<pre><code>DELETE /api/devices/{serial}\n</code></pre> <p>Removes an emulated device from the server. The device will stop responding to LIFX protocol packets.</p> <p>Path Parameters: - <code>serial</code>: Device serial number</p> <p>Response (204 No Content): No response body.</p> <p>Error Response (404): <pre><code>{\n  \"detail\": \"Device d073d5000001 not found\"\n}\n</code></pre></p> <p>Example: <pre><code>curl -X DELETE http://localhost:8080/api/devices/d073d5000001\n</code></pre></p>"},{"location":"cli/device-management-api/#delete-all-devices","title":"Delete All Devices","text":"<pre><code>DELETE /api/devices\n</code></pre> <p>Removes all emulated devices from the server. All devices will stop responding to LIFX protocol packets.</p> <p>Response (200 OK): <pre><code>{\n  \"deleted\": 5,\n  \"message\": \"Removed 5 device(s) from server\"\n}\n</code></pre></p> <p>Example: <pre><code>curl -X DELETE http://localhost:8080/api/devices\n</code></pre></p> <p>Note: This only removes devices from memory. Persistent state files remain intact.</p>"},{"location":"cli/device-management-api/#clear-persistent-storage","title":"Clear Persistent Storage","text":"<pre><code>DELETE /api/storage\n</code></pre> <p>Deletes all persistent device state files from disk. This does not affect currently running devices, only saved state files.</p> <p>Response (200 OK): <pre><code>{\n  \"deleted\": 3,\n  \"message\": \"Deleted 3 device state(s) from persistent storage\"\n}\n</code></pre></p> <p>Error Response (503): <pre><code>{\n  \"detail\": \"Persistent storage is not enabled\"\n}\n</code></pre></p> <p>Example: <pre><code>curl -X DELETE http://localhost:8080/api/storage\n</code></pre></p> <p>Note: Requires <code>--persistent</code> flag when starting the emulator.</p>"},{"location":"cli/device-management-api/#code-examples","title":"Code Examples","text":""},{"location":"cli/device-management-api/#python","title":"Python","text":"<pre><code>import requests\nimport json\n\nBASE_URL = \"http://localhost:8080/api\"\n\n# Get server statistics\nstats = requests.get(f\"{BASE_URL}/stats\").json()\nprint(f\"Uptime: {stats['uptime_seconds']:.1f}s\")\nprint(f\"Devices: {stats['device_count']}\")\nprint(f\"Packets RX: {stats['packets_received']}\")\nprint(f\"Packets TX: {stats['packets_sent']}\")\n\n# List all devices\ndevices = requests.get(f\"{BASE_URL}/devices\").json()\nfor device in devices:\n    print(f\"\\nDevice: {device['label']} ({device['serial']})\")\n    print(f\"  Product: {device['product']}\")\n    print(f\"  Power: {'ON' if device['power_level'] &gt; 0 else 'OFF'}\")\n    if device['has_color']:\n        color = device['color']\n        print(f\"  Color: H={color['hue']} S={color['saturation']} B={color['brightness']} K={color['kelvin']}\")\n\n# Create a new device\nresponse = requests.post(\n    f\"{BASE_URL}/devices\",\n    json={\"product_id\": 27, \"zone_count\": 16}\n)\nif response.status_code == 201:\n    device = response.json()\n    print(f\"Created device: {device['serial']}\")\n\n# Get recent activity\nactivity = requests.get(f\"{BASE_URL}/activity\").json()\nfor event in activity[-5:]:  # Last 5 events\n    direction = \"RX\" if event['direction'] == \"rx\" else \"TX\"\n    print(f\"{direction} {event['packet_name']} from {event['addr']}\")\n\n# Delete a device\nserial = devices[0]['serial']\nrequests.delete(f\"{BASE_URL}/devices/{serial}\")\nprint(f\"Deleted device: {serial}\")\n</code></pre>"},{"location":"cli/device-management-api/#javascriptnodejs","title":"JavaScript/Node.js","text":"<pre><code>const BASE_URL = \"http://localhost:8080/api\";\n\n// Get server statistics\nasync function getStats() {\n    const response = await fetch(`${BASE_URL}/stats`);\n    const stats = await response.json();\n    console.log(`Uptime: ${stats.uptime_seconds.toFixed(1)}s`);\n    console.log(`Devices: ${stats.device_count}`);\n    console.log(`Packets RX: ${stats.packets_received}`);\n    console.log(`Packets TX: ${stats.packets_sent}`);\n}\n\n// List all devices\nasync function listDevices() {\n    const response = await fetch(`${BASE_URL}/devices`);\n    const devices = await response.json();\n\n    for (const device of devices) {\n        console.log(`\\nDevice: ${device.label} (${device.serial})`);\n        console.log(`  Product: ${device.product}`);\n        console.log(`  Power: ${device.power_level &gt; 0 ? \"ON\" : \"OFF\"}`);\n        if (device.has_color) {\n            const c = device.color;\n            console.log(`  Color: H=${c.hue} S=${c.saturation} B=${c.brightness} K=${c.kelvin}`);\n        }\n    }\n}\n\n// Create a new device\nasync function createDevice(productId) {\n    const response = await fetch(`${BASE_URL}/devices`, {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        body: JSON.stringify({ product_id: productId })\n    });\n\n    if (response.status === 201) {\n        const device = await response.json();\n        console.log(`Created device: ${device.serial}`);\n        return device;\n    } else {\n        const error = await response.json();\n        console.error(`Failed: ${error.detail}`);\n    }\n}\n\n// Delete a device\nasync function deleteDevice(serial) {\n    const response = await fetch(`${BASE_URL}/devices/${serial}`, {\n        method: \"DELETE\"\n    });\n\n    if (response.status === 204) {\n        console.log(`Deleted device: ${serial}`);\n    } else {\n        const error = await response.json();\n        console.error(`Failed: ${error.detail}`);\n    }\n}\n\n// Get recent activity\nasync function getActivity() {\n    const response = await fetch(`${BASE_URL}/activity`);\n    const activities = await response.json();\n\n    console.log(\"Recent activity:\");\n    for (const event of activities.slice(-5)) {\n        const dir = event.direction === \"rx\" ? \"RX\" : \"TX\";\n        console.log(`  ${dir} ${event.packet_name} from ${event.addr}`);\n    }\n}\n\n// Run examples\ngetStats();\nlistDevices();\ncreateDevice(27);\ngetActivity();\n</code></pre>"},{"location":"cli/device-management-api/#curl","title":"cURL","text":"<pre><code># Get stats (pretty-print with jq)\ncurl http://localhost:8080/api/stats | jq\n\n# List devices\ncurl http://localhost:8080/api/devices | jq '.[] | {serial, label, product}'\n\n# Create color light\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 27}' | jq '.serial'\n\n# Create multizone device with 16 zones\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 32, \"zone_count\": 16}' | jq\n\n# Get specific device\ncurl http://localhost:8080/api/devices/d073d5000001 | jq '{serial, label, power_level}'\n\n# Get recent activity\ncurl http://localhost:8080/api/activity | jq '.[-5:] | .[] | {direction, packet_name, addr}'\n\n# Delete device\ncurl -X DELETE http://localhost:8080/api/devices/d073d5000001 -v\n\n# Delete all devices\ncurl -X DELETE http://localhost:8080/api/devices | jq\n</code></pre>"},{"location":"cli/device-management-api/#common-patterns","title":"Common Patterns","text":""},{"location":"cli/device-management-api/#monitor-emulator-status","title":"Monitor Emulator Status","text":"<pre><code>import requests\nimport time\n\nwhile True:\n    try:\n        stats = requests.get(\"http://localhost:8080/api/stats\", timeout=2).json()\n        print(f\"Status: {stats['device_count']} devices, \"\n              f\"{stats['packets_received']} RX, \"\n              f\"{stats['packets_sent']} TX, \"\n              f\"uptime {stats['uptime_seconds']:.0f}s\")\n    except:\n        print(\"API unavailable\")\n\n    time.sleep(5)\n</code></pre>"},{"location":"cli/device-management-api/#maintain-minimum-device-count","title":"Maintain Minimum Device Count","text":"<pre><code>def ensure_min_devices(min_count, product_id):\n    devices = requests.get(f\"{BASE_URL}/devices\").json()\n    current = len(devices)\n\n    if current &lt; min_count:\n        for i in range(min_count - current):\n            requests.post(f\"{BASE_URL}/devices\",\n                         json={\"product_id\": product_id})\n            print(f\"Created device {i+1}\")\n</code></pre>"},{"location":"cli/device-management-api/#log-activity-to-file","title":"Log Activity to File","text":"<pre><code>import json\nfrom datetime import datetime\n\nwhile True:\n    activity = requests.get(f\"{BASE_URL}/activity\").json()\n\n    for event in activity:\n        log_entry = {\n            \"timestamp\": datetime.fromtimestamp(event['timestamp']).isoformat(),\n            \"direction\": event['direction'],\n            \"packet\": event['packet_name'],\n            \"device\": event['device'],\n            \"addr\": event['addr']\n        }\n\n        with open(\"emulator_activity.jsonl\", \"a\") as f:\n            f.write(json.dumps(log_entry) + \"\\n\")\n</code></pre>"},{"location":"cli/device-management-api/#error-handling","title":"Error Handling","text":"<p>All error responses follow this format:</p> <pre><code>{\n  \"detail\": \"Error message describing what went wrong\"\n}\n</code></pre> <p>Common Status Codes: - <code>200 OK</code>: Successful GET/DELETE request with response body - <code>201 Created</code>: Successful POST request (device creation) - <code>204 No Content</code>: Successful DELETE request (no body) - <code>400 Bad Request</code>: Invalid parameters or request body - <code>404 Not Found</code>: Resource not found - <code>409 Conflict</code>: Resource conflict (e.g., duplicate serial) - <code>503 Service Unavailable</code>: Feature not enabled (e.g., storage)</p>"},{"location":"cli/device-management-api/#see-also","title":"See Also","text":"<ul> <li>Web Interface Guide - Browser-based monitoring dashboard</li> <li>Scenario Management API - Test scenario configuration</li> </ul>"},{"location":"cli/scenario-api/","title":"Scenario Management REST API","text":"<p>The LIFX Emulator provides a comprehensive REST API for runtime management of testing scenarios via HTTP. This guide covers all endpoints and practical examples for managing scenarios.</p>"},{"location":"cli/scenario-api/#quick-start","title":"Quick Start","text":"<pre><code># Start emulator with API enabled\nlifx-emulator --api\n\n# Create a global scenario that drops all GetColor packets (100% drop rate)\ncurl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 1.0}}'\n\n# Verify the scenario was created\ncurl http://localhost:8080/api/scenarios/global\n</code></pre>"},{"location":"cli/scenario-api/#scope-levels","title":"Scope Levels","text":"<p>Scenarios operate at 5 scope levels with automatic precedence (highest to lowest):</p> <ol> <li>Device-specific - Single device by serial number</li> <li>Device-type - All devices of a type (color, multizone, extended_multizone, matrix, hev, infrared, basic)</li> <li>Location-specific - All devices in a location</li> <li>Group-specific - All devices in a group</li> <li>Global - All devices as baseline</li> </ol>"},{"location":"cli/scenario-api/#precedence-example","title":"Precedence Example","text":"<p>If you have:</p> <ul> <li>Global: <code>drop_packets: {101: 1.0}</code></li> <li>Type (multizone): <code>response_delays: {502: 1.0}</code></li> <li>Device (d073d5000001): <code>drop_packets: {102: 0.5}</code></li> </ul> <p>Then device d073d5000001 would:</p> <ul> <li>Drop packet 101 with 100% rate (from global)</li> <li>Drop packet 102 with 50% rate (from device-specific)</li> <li>Have 1.0s delay for packet type 502 (from type scenario)</li> </ul>"},{"location":"cli/scenario-api/#configuration-properties","title":"Configuration Properties","text":"<p>All scenarios can include the following optional properties:</p>"},{"location":"cli/scenario-api/#drop_packets","title":"drop_packets","text":"<p>Type: Object mapping packet type to drop rate (0.0-1.0)</p> <p>Silently drop (don't respond to) packets of specified types with given probability. 1.0 = always drop, 0.5 = drop 50%, 0.0 = never drop. Simulates packet loss.</p> <pre><code>{\"drop_packets\": {\"101\": 1.0, \"102\": 0.5, \"103\": 0.3}}\n</code></pre>"},{"location":"cli/scenario-api/#response_delays","title":"response_delays","text":"<p>Type: Object mapping packet type to delay in seconds</p> <p>Add artificial delay before responding. Simulates latency.</p> <pre><code>{\"response_delays\": {\"101\": 0.5, \"116\": 1.0}}\n</code></pre>"},{"location":"cli/scenario-api/#malformed_packets","title":"malformed_packets","text":"<p>Type: Array of integers</p> <p>Send truncated/corrupted response packets. Tests error handling.</p> <pre><code>{\"malformed_packets\": [107, 506]}\n</code></pre>"},{"location":"cli/scenario-api/#invalid_field_values","title":"invalid_field_values","text":"<p>Type: Array of integers</p> <p>Send response packets with all fields set to 0xFF (invalid). Tests validation.</p> <pre><code>{\"invalid_field_values\": [107]}\n</code></pre>"},{"location":"cli/scenario-api/#firmware_version","title":"firmware_version","text":"<p>Type: Array [major, minor] or null</p> <p>Override firmware version reported by device.</p> <pre><code>{\"firmware_version\": [2, 60]}\n</code></pre>"},{"location":"cli/scenario-api/#partial_responses","title":"partial_responses","text":"<p>Type: Array of integers</p> <p>Send incomplete multizone/tile data. Tests buffer handling.</p> <pre><code>{\"partial_responses\": [506, 512]}\n</code></pre>"},{"location":"cli/scenario-api/#send_unhandled","title":"send_unhandled","text":"<p>Type: Boolean</p> <p>Send StateUnhandled (type 3) for unknown packet types.</p> <pre><code>{\"send_unhandled\": true}\n</code></pre>"},{"location":"cli/scenario-api/#rest-endpoints","title":"REST Endpoints","text":""},{"location":"cli/scenario-api/#global-scenarios","title":"Global Scenarios","text":""},{"location":"cli/scenario-api/#get-global-scenario","title":"Get Global Scenario","text":"<pre><code>GET /api/scenarios/global\n</code></pre> <p>Response (200): <pre><code>{\n  \"scope\": \"global\",\n  \"identifier\": null,\n  \"scenario\": {\n    \"drop_packets\": [],\n    \"response_delays\": {},\n    \"malformed_packets\": [],\n    \"invalid_field_values\": [],\n    \"firmware_version\": null,\n    \"partial_responses\": [],\n    \"send_unhandled\": false\n  }\n}\n</code></pre></p> <p>Example: <pre><code>curl http://localhost:8080/api/scenarios/global | jq\n</code></pre></p>"},{"location":"cli/scenario-api/#set-global-scenario","title":"Set Global Scenario","text":"<pre><code>PUT /api/scenarios/global\nContent-Type: application/json\n</code></pre> <p>Request Body: <pre><code>{\n  \"drop_packets\": {\"101\": 1.0, \"102\": 0.6},\n  \"response_delays\": {\"101\": 0.5, \"116\": 1.0},\n  \"malformed_packets\": [],\n  \"invalid_field_values\": [],\n  \"firmware_version\": null,\n  \"partial_responses\": [],\n  \"send_unhandled\": false\n}\n</code></pre></p> <p>Response (200): Returns the scenario that was set</p> <p>Example: <pre><code>curl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 1.0}, \"response_delays\": {\"116\": 0.5}}'\n</code></pre></p>"},{"location":"cli/scenario-api/#clear-global-scenario","title":"Clear Global Scenario","text":"<pre><code>DELETE /api/scenarios/global\n</code></pre> <p>Response (204): No content</p> <p>Example: <pre><code>curl -X DELETE http://localhost:8080/api/scenarios/global\n</code></pre></p>"},{"location":"cli/scenario-api/#device-specific-scenarios","title":"Device-Specific Scenarios","text":""},{"location":"cli/scenario-api/#get-device-scenario","title":"Get Device Scenario","text":"<pre><code>GET /api/scenarios/devices/{serial}\n</code></pre> <p>Path Parameters: - <code>serial</code>: Device serial (e.g., <code>d073d5000001</code>)</p> <p>Response (200): <pre><code>{\n  \"scope\": \"device\",\n  \"identifier\": \"d073d5000001\",\n  \"scenario\": {...}\n}\n</code></pre></p> <p>Response (404): No scenario for this device</p> <p>Example: <pre><code>curl http://localhost:8080/api/scenarios/devices/d073d5000001 | jq\n</code></pre></p>"},{"location":"cli/scenario-api/#set-device-scenario","title":"Set Device Scenario","text":"<pre><code>PUT /api/scenarios/devices/{serial}\nContent-Type: application/json\n</code></pre> <p>Path Parameters: - <code>serial</code>: Device serial</p> <p>Request Body: Any scenario properties (partial update allowed)</p> <p>Response (200): Returns the scenario that was set</p> <p>Response (404): Device not found</p> <p>Example: <pre><code># Set scenario for specific device (drop 100% of GetColor packets)\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 1.0}}'\n</code></pre></p>"},{"location":"cli/scenario-api/#clear-device-scenario","title":"Clear Device Scenario","text":"<pre><code>DELETE /api/scenarios/devices/{serial}\n</code></pre> <p>Response (204): No content</p> <p>Response (404): No scenario for this device</p> <p>Example: <pre><code>curl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000001\n</code></pre></p>"},{"location":"cli/scenario-api/#type-specific-scenarios","title":"Type-Specific Scenarios","text":""},{"location":"cli/scenario-api/#get-type-scenario","title":"Get Type Scenario","text":"<pre><code>GET /api/scenarios/types/{device_type}\n</code></pre> <p>Path Parameters: - <code>device_type</code>: One of <code>color</code>, <code>multizone</code>, <code>extended_multizone</code>, <code>matrix</code>, <code>hev</code>, <code>infrared</code>, <code>basic</code></p> <p>Response (200): <pre><code>{\n  \"scope\": \"type\",\n  \"identifier\": \"multizone\",\n  \"scenario\": {...}\n}\n</code></pre></p> <p>Response (404): No scenario for this type</p> <p>Example: <pre><code>curl http://localhost:8080/api/scenarios/types/multizone | jq\n</code></pre></p>"},{"location":"cli/scenario-api/#set-type-scenario","title":"Set Type Scenario","text":"<pre><code>PUT /api/scenarios/types/{device_type}\nContent-Type: application/json\n</code></pre> <p>Path Parameters: - <code>device_type</code>: Device type</p> <p>Request Body: Any scenario properties</p> <p>Response (200): Returns the scenario</p> <p>Example: <pre><code># All multizone devices will respond slowly to GetColorZones (502)\ncurl -X PUT http://localhost:8080/api/scenarios/types/multizone \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"response_delays\": {\"502\": 1.0}}'\n</code></pre></p>"},{"location":"cli/scenario-api/#clear-type-scenario","title":"Clear Type Scenario","text":"<pre><code>DELETE /api/scenarios/types/{device_type}\n</code></pre> <p>Response (204): No content</p> <p>Response (404): No scenario for this type</p> <p>Example: <pre><code>curl -X DELETE http://localhost:8080/api/scenarios/types/multizone\n</code></pre></p>"},{"location":"cli/scenario-api/#location-specific-scenarios","title":"Location-Specific Scenarios","text":""},{"location":"cli/scenario-api/#get-location-scenario","title":"Get Location Scenario","text":"<pre><code>GET /api/scenarios/locations/{location}\n</code></pre> <p>Path Parameters: - <code>location</code>: Location label (e.g., <code>Kitchen</code>, <code>Living Room</code>)</p> <p>Response (200): <pre><code>{\n  \"scope\": \"location\",\n  \"identifier\": \"Kitchen\",\n  \"scenario\": {...}\n}\n</code></pre></p> <p>Response (404): No scenario for this location</p>"},{"location":"cli/scenario-api/#set-location-scenario","title":"Set Location Scenario","text":"<pre><code>PUT /api/scenarios/locations/{location}\nContent-Type: application/json\n</code></pre> <p>Path Parameters: - <code>location</code>: Location label</p> <p>Request Body: Any scenario properties</p> <p>Response (200): Returns the scenario</p> <p>Example: <pre><code># All devices in Kitchen will have poor connectivity\ncurl -X PUT http://localhost:8080/api/scenarios/locations/Kitchen \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"response_delays\": {\"116\": 0.5}, \"drop_packets\": {\"101\": 0.3}}'\n</code></pre></p>"},{"location":"cli/scenario-api/#clear-location-scenario","title":"Clear Location Scenario","text":"<pre><code>DELETE /api/scenarios/locations/{location}\n</code></pre> <p>Response (204): No content</p> <p>Response (404): No scenario for this location</p>"},{"location":"cli/scenario-api/#group-specific-scenarios","title":"Group-Specific Scenarios","text":""},{"location":"cli/scenario-api/#get-group-scenario","title":"Get Group Scenario","text":"<pre><code>GET /api/scenarios/groups/{group}\n</code></pre> <p>Path Parameters: - <code>group</code>: Group label (e.g., <code>Bedroom Lights</code>)</p> <p>Response (200): <pre><code>{\n  \"scope\": \"group\",\n  \"identifier\": \"Bedroom Lights\",\n  \"scenario\": {...}\n}\n</code></pre></p> <p>Response (404): No scenario for this group</p>"},{"location":"cli/scenario-api/#set-group-scenario","title":"Set Group Scenario","text":"<pre><code>PUT /api/scenarios/groups/{group}\nContent-Type: application/json\n</code></pre> <p>Path Parameters: - <code>group</code>: Group label</p> <p>Request Body: Any scenario properties</p> <p>Response (200): Returns the scenario</p> <p>Example: <pre><code># All devices in \"Bedroom Lights\" group will send corrupted responses\ncurl -X PUT http://localhost:8080/api/scenarios/groups/\"Bedroom Lights\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"malformed_packets\": [107]}'\n</code></pre></p>"},{"location":"cli/scenario-api/#clear-group-scenario","title":"Clear Group Scenario","text":"<pre><code>DELETE /api/scenarios/groups/{group}\n</code></pre> <p>Response (204): No content</p> <p>Response (404): No scenario for this group</p>"},{"location":"cli/scenario-api/#practical-examples","title":"Practical Examples","text":""},{"location":"cli/scenario-api/#example-1-test-packet-loss-handling","title":"Example 1: Test Packet Loss Handling","text":"<p>Test client retry logic by dropping GetColor packets:</p> <pre><code># Drop GetColor (type 101) for all color lights - 100% drop rate\ncurl -X PUT http://localhost:8080/api/scenarios/types/color \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 1.0}}'\n\n# Your client should:\n# 1. Send GetColor request\n# 2. Timeout waiting for response\n# 3. Retry (with backoff if implemented)\n# 4. Eventually fail after max retries\n\n# Verify scenario is set\ncurl http://localhost:8080/api/scenarios/types/color | jq '.scenario.drop_packets'\n# Output: {\"101\": 1.0}\n\n# Clean up\ncurl -X DELETE http://localhost:8080/api/scenarios/types/color\n</code></pre>"},{"location":"cli/scenario-api/#example-2-simulate-network-latency","title":"Example 2: Simulate Network Latency","text":"<p>Add realistic network delays:</p> <pre><code># Simulate 500ms latency to all color light responses\ncurl -X PUT http://localhost:8080/api/scenarios/types/color \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"response_delays\": {\n      \"45\": 0.5,\n      \"101\": 0.5,\n      \"102\": 0.5,\n      \"107\": 0.5,\n      \"116\": 0.5,\n      \"117\": 0.5\n    }\n  }'\n</code></pre>"},{"location":"cli/scenario-api/#example-3-test-firmware-compatibility","title":"Example 3: Test Firmware Compatibility","text":"<p>Override firmware version to test backward compatibility:</p> <pre><code># Set device to old firmware version\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"firmware_version\": [2, 60]}'\n\n# Get the device to verify firmware version is changed\ncurl http://localhost:8080/api/devices/d073d5000001 | jq '.version_major, .version_minor'\n# Output: 2, 60\n</code></pre>"},{"location":"cli/scenario-api/#example-4-simulate-problematic-device","title":"Example 4: Simulate Problematic Device","text":"<p>Combine multiple scenarios to simulate a problematic device:</p> <pre><code># Device sometimes drops responses, is slow, and sends bad data\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"drop_packets\": {\"101\": 1.0},\n    \"response_delays\": {\"102\": 1.0, \"116\": 0.8},\n    \"malformed_packets\": [107],\n    \"firmware_version\": [2, 50]\n  }'\n</code></pre>"},{"location":"cli/scenario-api/#example-5-location-based-testing","title":"Example 5: Location-Based Testing","text":"<p>Test a group of devices with poor connectivity:</p> <pre><code># All devices in Kitchen location have latency\ncurl -X PUT http://localhost:8080/api/scenarios/locations/Kitchen \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"response_delays\": {\"116\": 0.5}}'\n\n# Override with specific device being worse\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5kitchen01 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"response_delays\": {\"116\": 2.0}, \"drop_packets\": {\"102\": 0.5}}'\n\n# Device d073d5kitchen01 will have 2.0s delay for 116 (device override wins)\n# Other Kitchen devices will have 0.5s delay for 116 (location scenario)\n</code></pre>"},{"location":"cli/scenario-api/#example-6-test-invalid-data-handling","title":"Example 6: Test Invalid Data Handling","text":"<p>Send packets with invalid field values:</p> <pre><code># Device will send StateColor with all 0xFF bytes\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"invalid_field_values\": [107]}'\n\n# Your client should:\n# - Detect invalid values (hue=65535, saturation=65535, etc.)\n# - Reject or sanitize the values\n# - Not crash or use invalid values\n</code></pre>"},{"location":"cli/scenario-api/#example-7-clear-all-scenarios","title":"Example 7: Clear All Scenarios","text":"<pre><code># List all devices to find serial numbers\ncurl http://localhost:8080/api/devices | jq '.[] | .serial'\n\n# Clear scenarios for specific devices\ncurl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000001\ncurl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000002\n\n# Clear all type scenarios\nfor type in color multizone extended_multizone matrix hev infrared basic; do\n  curl -X DELETE http://localhost:8080/api/scenarios/types/$type 2&gt;/dev/null\ndone\n\n# Clear global\ncurl -X DELETE http://localhost:8080/api/scenarios/global\n</code></pre>"},{"location":"cli/scenario-api/#shell-script-helpers","title":"Shell Script Helpers","text":""},{"location":"cli/scenario-api/#get-all-scenarios","title":"Get All Scenarios","text":"<pre><code>#!/bin/bash\n\necho \"=== Global Scenario ===\"\ncurl -s http://localhost:8080/api/scenarios/global | jq '.scenario'\n\necho -e \"\\n=== Device-Specific Scenarios ===\"\ncurl -s http://localhost:8080/api/devices | jq -r '.[] | .serial' | while read serial; do\n  echo -n \"$serial: \"\n  curl -s http://localhost:8080/api/scenarios/devices/$serial 2&gt;/dev/null | jq '.scenario.drop_packets // \"none\"'\ndone\n\necho -e \"\\n=== Type Scenarios ===\"\nfor type in color multizone extended_multizone matrix hev infrared basic; do\n  echo -n \"$type: \"\n  curl -s http://localhost:8080/api/scenarios/types/$type 2&gt;/dev/null | jq '.scenario.drop_packets // \"none\"'\ndone\n</code></pre>"},{"location":"cli/scenario-api/#test-scenario-workflow","title":"Test Scenario Workflow","text":"<pre><code>#!/bin/bash\n\necho \"1. Setting global scenario...\"\ncurl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 1.0}}' &gt; /dev/null\n\necho \"2. Verifying global scenario...\"\ncurl -s http://localhost:8080/api/scenarios/global | jq '.scenario'\n\necho \"3. Running test suite...\"\npytest tests/\n\necho \"4. Clearing scenario...\"\ncurl -X DELETE http://localhost:8080/api/scenarios/global &gt; /dev/null\n\necho \"5. Verifying cleared...\"\ncurl -s http://localhost:8080/api/scenarios/global | jq '.scenario'\n</code></pre>"},{"location":"cli/scenario-api/#python-client-examples","title":"Python Client Examples","text":""},{"location":"cli/scenario-api/#using-requests-library","title":"Using requests Library","text":"<pre><code>import requests\nimport json\n\nBASE_URL = \"http://localhost:8080/api\"\n\ndef get_global_scenario():\n    \"\"\"Get the global scenario configuration.\"\"\"\n    response = requests.get(f\"{BASE_URL}/scenarios/global\")\n    return response.json()\n\ndef set_device_scenario(serial, scenario):\n    \"\"\"Set scenario for a specific device.\"\"\"\n    response = requests.put(\n        f\"{BASE_URL}/scenarios/devices/{serial}\",\n        json=scenario\n    )\n    return response.json()\n\ndef clear_device_scenario(serial):\n    \"\"\"Clear scenario for a device.\"\"\"\n    response = requests.delete(f\"{BASE_URL}/scenarios/devices/{serial}\")\n    return response.status_code\n\n# Usage\nscenario = {\n    \"drop_packets\": {\"101\": 1.0},\n    \"response_delays\": {\"102\": 0.5}\n}\n\nresult = set_device_scenario(\"d073d5000001\", scenario)\nprint(f\"Scenario set: {result}\")\n\nstatus = clear_device_scenario(\"d073d5000001\")\nprint(f\"Cleared: {status == 204}\")\n</code></pre>"},{"location":"cli/scenario-api/#using-httpx-library-async","title":"Using httpx Library (Async)","text":"<pre><code>import httpx\nimport asyncio\n\nBASE_URL = \"http://localhost:8080/api\"\n\nasync def test_scenario():\n    \"\"\"Test scenario management async.\"\"\"\n    async with httpx.AsyncClient() as client:\n        # Get all devices\n        devices = await client.get(f\"{BASE_URL}/devices\")\n\n        for device in devices.json():\n            serial = device[\"serial\"]\n\n            # Set scenario for device\n            scenario = {\"drop_packets\": {\"101\": 1.0}}\n            await client.put(\n                f\"{BASE_URL}/scenarios/devices/{serial}\",\n                json=scenario\n            )\n\n            # Verify it was set\n            resp = await client.get(f\"{BASE_URL}/scenarios/devices/{serial}\")\n            print(f\"{serial}: {resp.json()['scenario']}\")\n\n            # Clear it\n            await client.delete(f\"{BASE_URL}/scenarios/devices/{serial}\")\n\nasyncio.run(test_scenario())\n</code></pre>"},{"location":"cli/scenario-api/#integration-with-tests","title":"Integration with Tests","text":""},{"location":"cli/scenario-api/#pytest-integration","title":"pytest Integration","text":"<pre><code>import pytest\nimport requests\n\nAPI_URL = \"http://localhost:8080/api\"\n\n@pytest.fixture(autouse=True)\ndef clear_scenarios():\n    \"\"\"Clear all scenarios before and after each test.\"\"\"\n    # Clear before\n    requests.delete(f\"{API_URL}/scenarios/global\")\n    yield\n    # Clear after\n    requests.delete(f\"{API_URL}/scenarios/global\")\n\ndef test_with_packet_loss():\n    \"\"\"Test client handles packet loss.\"\"\"\n    # Set scenario\n    requests.put(\n        f\"{API_URL}/scenarios/types/color\",\n        json={\"drop_packets\": {\"101\": 1.0}}\n    )\n\n    # Run test that exercises retry logic\n    client = YourLIFXClient()\n    result = client.get_color(\"d073d5000001\")\n\n    # Should either retry successfully or timeout gracefully\n    assert result is not None or client.last_error is not None\n\ndef test_with_latency():\n    \"\"\"Test client handles slow responses.\"\"\"\n    requests.put(\n        f\"{API_URL}/scenarios/types/color\",\n        json={\"response_delays\": {\"101\": 0.5}}\n    )\n\n    client = YourLIFXClient()\n    import time\n    start = time.time()\n    result = client.get_color(\"d073d5000001\")\n    elapsed = time.time() - start\n\n    assert elapsed &gt;= 0.5\n    assert result is not None\n</code></pre>"},{"location":"cli/scenario-api/#github-actions-integration","title":"GitHub Actions Integration","text":"<pre><code>name: Test with Scenarios\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-python@v4\n\n      - name: Install dependencies\n        run: |\n          pip install -r requirements.txt\n          pip install -r requirements-dev.txt\n\n      - name: Start emulator\n        run: |\n          python -m lifx_emulator --api --color 2 --multizone 1 &amp;\n          sleep 2\n\n      - name: Run tests (normal conditions)\n        run: pytest tests/ -v\n\n      - name: Configure packet loss scenario\n        run: |\n          curl -X PUT http://localhost:8080/api/scenarios/types/color \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\"drop_packets\": {\"101\": 1.0}}'\n\n      - name: Run tests (with packet loss)\n        run: pytest tests/ -v -k \"retry\"\n\n      - name: Configure latency scenario\n        run: |\n          curl -X PUT http://localhost:8080/api/scenarios/types/color \\\n            -H \"Content-Type: application/json\" \\\n            -d '{\"response_delays\": {\"101\": 0.5}}'\n\n      - name: Run performance tests\n        run: pytest tests/ -v -k \"performance\"\n</code></pre>"},{"location":"cli/scenario-api/#common-packet-types","title":"Common Packet Types","text":"Type Name Description 45 Acknowledgement Sent when ack_required is set 101 GetColor Request current color state 102 SetColor Set device color 103 GetWaveform Get waveform effect 104 SetWaveform Set waveform effect 107 StateColor Response with current color 116 GetLightPower Request power state 117 SetLightPower Set power state 502 GetColorZones Request multizone colors 503 SetColorZones Set multizone colors 506 StateMultiZone Response with zone colors 512 ExtendedStateMultiZone Response with extended zones 701 GetDeviceChain Get tile chain info 707 Get64 Get tile zone data 715 Set64 Set tile zone data"},{"location":"cli/scenario-api/#tips-and-best-practices","title":"Tips and Best Practices","text":"<ol> <li>Test One Thing at a Time: Set a single scenario property first, verify it works, then add more</li> <li>Use Realistic Values: Network delays should be 0.1-2.0 seconds, not 10+ seconds</li> <li>Clean Up After Tests: Always delete scenarios between test runs to avoid cross-contamination</li> <li>Monitor Activity: Use the <code>/api/activity</code> endpoint to see actual packets being sent</li> <li>Start with Device-Level: Test individual devices before testing by type/location/group</li> <li>Document Scenarios: Add comments explaining why each scenario is configured in your tests</li> <li>Test Recovery: Verify clients properly recover after scenario conditions clear</li> </ol>"},{"location":"cli/scenario-api/#see-also","title":"See Also","text":"<ul> <li>Testing Scenarios Guide - Programmatic scenario configuration</li> <li>Integration Testing - Using scenarios in test suites</li> <li>Best Practices - Testing strategies</li> <li>API Reference - Full API documentation</li> </ul>"},{"location":"cli/scenarios/","title":"Custom Test Scenarios","text":"<p>Simulate real-world conditions and protocol edge cases</p> <p>Test scenarios allow you to configure the emulator to simulate various real-world conditions like packet loss, network delays, malformed packets, and more. This is useful for testing how your application handles protocol errors and network unreliability.</p>"},{"location":"cli/scenarios/#overview","title":"Overview","text":"<p>Scenarios are organized in a hierarchical structure with automatic precedence resolution:</p> <ol> <li>Device-specific - Affects single device by serial</li> <li>Type-specific - Affects all devices of a type (color, multizone, etc.)</li> <li>Location-based - Affects all devices in a location</li> <li>Group-based - Affects all devices in a group</li> <li>Global - Affects all devices</li> </ol> <p>This allows fine-grained control over which devices experience which conditions.</p>"},{"location":"cli/scenarios/#quick-start","title":"Quick Start","text":"<p>Configure a simple scenario via Python API:</p> <pre><code>from lifx_emulator import create_color_light\nfrom lifx_emulator.scenarios.manager import ScenarioConfig\n\ndevice = create_color_light(\"d073d5000001\")\n\n# Drop 30% of GetColor packets\ndevice.scenarios = ScenarioConfig(\n    drop_packets={\"101\": 0.3}\n)\n</code></pre> <p>Or via REST API:</p> <pre><code># Set global scenario - drop 100% of GetColor packets\ncurl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"drop_packets\": {\"101\": 1.0},\n    \"response_delays\": {},\n    \"malformed_packets\": [],\n    \"invalid_field_values\": [],\n    \"firmware_version\": null,\n    \"partial_responses\": [],\n    \"send_unhandled\": false\n  }'\n</code></pre>"},{"location":"cli/scenarios/#scenario-types","title":"Scenario Types","text":""},{"location":"cli/scenarios/#packet-dropping","title":"Packet Dropping","text":"<p>Simulate packet loss by dropping incoming packets:</p> <pre><code>from lifx_emulator.scenarios.manager import ScenarioConfig\n\n# Drop 100% of GetColor packets\nconfig = ScenarioConfig(drop_packets={\"101\": 1.0})\n\n# Drop 30% probabilistically\nconfig = ScenarioConfig(drop_packets={\"101\": 0.3})\n\n# Drop multiple packet types\nconfig = ScenarioConfig(drop_packets={\"101\": 1.0, \"102\": 0.5})\n</code></pre>"},{"location":"cli/scenarios/#response-delays","title":"Response Delays","text":"<p>Add latency to responses to simulate slow networks:</p> <pre><code># Add 500ms delay to all GetColor responses\nconfig = ScenarioConfig(response_delays={\"101\": 0.5})\n\n# Multiple delays\nconfig = ScenarioConfig(response_delays={\n    \"101\": 0.5,    # GetColor - 500ms\n    \"102\": 0.2,    # SetColor - 200ms\n    \"116\": 1.0,    # GetPower - 1000ms\n})\n</code></pre>"},{"location":"cli/scenarios/#malformed-packets","title":"Malformed Packets","text":"<p>Send corrupted/truncated packets to test error handling:</p> <pre><code># Send truncated StateColor packets\nconfig = ScenarioConfig(malformed_packets=[107])\n\n# Multiple packet types\nconfig = ScenarioConfig(malformed_packets=[107, 108, 110])\n</code></pre>"},{"location":"cli/scenarios/#invalid-field-values","title":"Invalid Field Values","text":"<p>Send packets with invalid field values (all 0xFF bytes):</p> <pre><code># Send StateColor with all 0xFF values\nconfig = ScenarioConfig(invalid_field_values=[107])\n</code></pre>"},{"location":"cli/scenarios/#partial-responses","title":"Partial Responses","text":"<p>Send incomplete multizone/tile data:</p> <pre><code># Send only partial zone data\nconfig = ScenarioConfig(partial_responses=[506])  # StateMultiZone\n</code></pre>"},{"location":"cli/scenarios/#firmware-version-override","title":"Firmware Version Override","text":"<p>Simulate different firmware versions:</p> <pre><code># Simulate older firmware\nconfig = ScenarioConfig(firmware_version=(2, 60))\n\n# Simulate newer firmware\nconfig = ScenarioConfig(firmware_version=(3, 90))\n</code></pre>"},{"location":"cli/scenarios/#scenario-scope","title":"Scenario Scope","text":""},{"location":"cli/scenarios/#global-scenarios","title":"Global Scenarios","text":"<p>Apply to all devices:</p> <pre><code>from lifx_emulator.scenarios.manager import HierarchicalScenarioManager\n\nmanager = HierarchicalScenarioManager()\n\nmanager.set_global_scenario(ScenarioConfig(\n    drop_packets={\"101\": 1.0}\n))\n\n# All devices now drop GetColor packets\n</code></pre>"},{"location":"cli/scenarios/#device-specific-scenarios","title":"Device-Specific Scenarios","text":"<p>Target individual devices by serial:</p> <pre><code># Only device d073d5000001 experiences delays\nmanager.set_device_scenario(\n    \"d073d5000001\",\n    ScenarioConfig(response_delays={\"101\": 0.5})\n)\n</code></pre>"},{"location":"cli/scenarios/#type-specific-scenarios","title":"Type-Specific Scenarios","text":"<p>Target all devices of a type:</p> <pre><code># All color devices drop GetColor packets\nmanager.set_type_scenario(\n    \"color\",\n    ScenarioConfig(drop_packets={\"101\": 0.3})\n)\n\n# All multizone devices get 500ms delay\nmanager.set_type_scenario(\n    \"multizone\",\n    ScenarioConfig(response_delays={\"502\": 0.5})\n)\n\n# Supported types: color, multizone, extended_multizone, matrix, hev, infrared, basic\n</code></pre>"},{"location":"cli/scenarios/#location-based-scenarios","title":"Location-Based Scenarios","text":"<p>Target all devices in a location:</p> <pre><code># All devices in \"Kitchen\" experience delays\nmanager.set_location_scenario(\n    \"Kitchen\",\n    ScenarioConfig(response_delays={\"101\": 0.2})\n)\n</code></pre>"},{"location":"cli/scenarios/#group-based-scenarios","title":"Group-Based Scenarios","text":"<p>Target all devices in a group:</p> <pre><code># All devices in \"Bedroom Lights\" group\nmanager.set_group_scenario(\n    \"Bedroom Lights\",\n    ScenarioConfig(drop_packets={\"101\": 0.5})\n)\n</code></pre>"},{"location":"cli/scenarios/#scenario-precedence","title":"Scenario Precedence","text":"<p>When multiple scopes apply, precedence is:</p> <ol> <li>Device-specific (highest priority)</li> <li>Type-specific</li> <li>Location-based</li> <li>Group-based</li> <li>Global (lowest priority)</li> </ol> <p>Example:</p> <pre><code>manager = HierarchicalScenarioManager()\n\n# Global: drop 100% of GetColor\nmanager.set_global_scenario(\n    ScenarioConfig(drop_packets={\"101\": 1.0})\n)\n\n# Type: multizone devices get 500ms delay\nmanager.set_type_scenario(\n    \"multizone\",\n    ScenarioConfig(response_delays={\"502\": 0.5})\n)\n\n# Device: d073d5000001 drops 50% of SetColor\nmanager.set_device_scenario(\n    \"d073d5000001\",\n    ScenarioConfig(drop_packets={\"102\": 0.5})\n)\n\n# Result for d073d5000001:\n# - Drop 100% of GetColor (from global)\n# - Drop 50% of SetColor (from device, overrides global)\n# - 500ms delay for packet 502 (from type if multizone)\n</code></pre>"},{"location":"cli/scenarios/#rest-api-examples","title":"REST API Examples","text":"<p>Full REST API documentation is in the Scenario Management API guide.</p>"},{"location":"cli/scenarios/#get-current-scenario","title":"Get Current Scenario","text":"<pre><code># Get global scenario\ncurl http://localhost:8080/api/scenarios/global\n\n# Get scenario for specific device\ncurl http://localhost:8080/api/scenarios/devices/d073d5000001\n\n# Get scenario for device type\ncurl http://localhost:8080/api/scenarios/types/multizone\n</code></pre>"},{"location":"cli/scenarios/#update-scenarios","title":"Update Scenarios","text":"<pre><code># Set global scenario\ncurl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"drop_packets\": {\"101\": 0.3},\n    \"response_delays\": {\"101\": 0.2},\n    \"malformed_packets\": [],\n    \"invalid_field_values\": [],\n    \"firmware_version\": null,\n    \"partial_responses\": [],\n    \"send_unhandled\": false\n  }'\n\n# Set device-specific scenario\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"drop_packets\": {\"101\": 1.0},\n    \"response_delays\": {},\n    \"malformed_packets\": [],\n    \"invalid_field_values\": [],\n    \"firmware_version\": [2, 60],\n    \"partial_responses\": [],\n    \"send_unhandled\": false\n  }'\n</code></pre>"},{"location":"cli/scenarios/#clear-scenarios","title":"Clear Scenarios","text":"<pre><code># Clear global scenario\ncurl -X DELETE http://localhost:8080/api/scenarios/global\n\n# Clear device scenario\ncurl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000001\n\n# Clear type scenario\ncurl -X DELETE http://localhost:8080/api/scenarios/types/multizone\n</code></pre>"},{"location":"cli/scenarios/#practical-testing-patterns","title":"Practical Testing Patterns","text":""},{"location":"cli/scenarios/#testing-retry-logic","title":"Testing Retry Logic","text":"<pre><code># Simulate flaky network - drop 30% of packets\nconfig = ScenarioConfig(drop_packets={\"101\": 0.3})\n\n# Your client should retry and eventually succeed\n</code></pre>"},{"location":"cli/scenarios/#testing-timeout-handling","title":"Testing Timeout Handling","text":"<pre><code># Add 2 second delay to simulate slow device\nconfig = ScenarioConfig(response_delays={\"101\": 2.0})\n\n# Test that client timeout is &gt; 2 seconds\n</code></pre>"},{"location":"cli/scenarios/#testing-error-recovery","title":"Testing Error Recovery","text":"<pre><code># Send malformed responses\nconfig = ScenarioConfig(malformed_packets=[107])\n\n# Test that client handles parse errors gracefully\n</code></pre>"},{"location":"cli/scenarios/#testing-firmware-compatibility","title":"Testing Firmware Compatibility","text":"<pre><code># Simulate older firmware\nconfig = ScenarioConfig(firmware_version=(2, 60))\n\n# Test client behavior with older firmware\n\n# Simulate newer firmware\nconfig = ScenarioConfig(firmware_version=(3, 90))\n\n# Test client with newer features\n</code></pre>"},{"location":"cli/scenarios/#testing-concurrent-operations","title":"Testing Concurrent Operations","text":"<pre><code># Create multiple devices with different scenarios\ndevices = [\n    create_color_light(\"d073d5000001\"),  # No delays\n    create_color_light(\"d073d5000002\"),  # 500ms delay\n    create_color_light(\"d073d5000003\"),  # Drop packets\n]\n\nmanager.set_device_scenario(\n    \"d073d5000002\",\n    ScenarioConfig(response_delays={\"101\": 0.5})\n)\n\nmanager.set_device_scenario(\n    \"d073d5000003\",\n    ScenarioConfig(drop_packets={\"101\": 0.5})\n)\n\n# Test client behavior with heterogeneous device conditions\n</code></pre>"},{"location":"cli/scenarios/#persistent-scenarios","title":"Persistent Scenarios","text":"<p>Save scenarios across emulator restarts:</p> <pre><code>lifx-emulator --api --persistent --persistent-scenarios\n</code></pre> <p>Scenarios are saved to <code>~/.lifx-emulator/scenarios.json</code>.</p>"},{"location":"cli/scenarios/#api-reference","title":"API Reference","text":"<p>For complete API documentation, see:</p> <ul> <li>Scenario Management API Guide - REST API endpoints</li> <li>Testing Scenarios Guide - Configuration details</li> <li>Scenario Manager API - Python API</li> </ul>"},{"location":"cli/scenarios/#common-packet-types","title":"Common Packet Types","text":"Type ID Description GetColor 101 Request device color SetColor 102 Set device color GetPower 116 Request power state SetPower 117 Set power state StateColor 107 Color state response StatePower 118 Power state response StateMultiZone 506 Multizone state ExtendedStateMultiZone 512 Extended multizone state Get64 514 Get tile 64 Set64 715 Set tile 64 <p>See Protocol Documentation for complete list.</p>"},{"location":"cli/scenarios/#next-steps","title":"Next Steps","text":"<ul> <li>Scenario Management API - REST API reference</li> <li>Testing Scenarios Guide - Configuration details</li> <li>Integration Testing - Testing patterns</li> </ul>"},{"location":"cli/storage/","title":"Persistent Storage Guide","text":"<p>Save and restore device state across emulator sessions</p> <p>The LIFX Emulator supports optional persistent storage that automatically saves device state (color, power, labels, zone colors, etc.) to disk and restores it when the emulator restarts.</p>"},{"location":"cli/storage/#overview","title":"Overview","text":"<p>With persistent storage enabled, device state survives emulator restarts, making it useful for:</p> <ul> <li>Testing long-running applications with stateful devices</li> <li>Preserving test setup between development sessions</li> <li>Simulating real-world device behavior where state persists</li> </ul>"},{"location":"cli/storage/#quick-start","title":"Quick Start","text":"<p>Enable persistent storage from the CLI:</p> <pre><code># Start emulator with persistent storage\nlifx-emulator --persistent\n\n# State will be saved and restored across restarts\n</code></pre> <p>Or from Python:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\nasync def main():\n    # Create storage handler\n    storage = AsyncDeviceStorage()\n\n    # Create device with storage\n    device = create_color_light(\"d073d5000001\", storage=storage)\n\n    # State changes are automatically saved\n    device.state.label = \"My Light\"\n    device.state.color.hue = 21845  # 120 degrees\n\n    # Start server\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    await server.start()\n\n    # Device state will be restored on next run with same serial\n\nasyncio.run(main())\n</code></pre>"},{"location":"cli/storage/#storage-location","title":"Storage Location","text":"<p>By default, device state is stored in <code>~/.lifx-emulator/</code>:</p> <pre><code>~/.lifx-emulator/\n\u251c\u2500\u2500 d073d5000001.json  # State for first device\n\u251c\u2500\u2500 d073d5000002.json  # State for second device\n\u2514\u2500\u2500 d073d8000001.json  # State for multizone device\n</code></pre>"},{"location":"cli/storage/#custom-storage-directory","title":"Custom Storage Directory","text":"<pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\n# Use custom directory\nstorage = AsyncDeviceStorage(\"/var/lib/lifx-emulator\")\n\n# Now state files will be stored in /var/lib/lifx-emulator/\n</code></pre>"},{"location":"cli/storage/#what-gets-saved","title":"What Gets Saved","text":"<p>The following device state is persisted:</p> <ul> <li>Label - Device name</li> <li>Power Level - On/off and brightness</li> <li>Color - Hue, saturation, brightness, kelvin (for color lights)</li> <li>Location - Device location</li> <li>Group - Device group</li> <li>Zone Colors - Individual zone colors (for multizone devices)</li> <li>Tile Colors - Individual tile colors (for matrix devices)</li> <li>Infrared Brightness - IR brightness level (for IR capable devices)</li> <li>HEV State - HEV cycle state (for HEV capable devices)</li> </ul>"},{"location":"cli/storage/#state-file-format","title":"State File Format","text":"<p>Device state is stored as JSON:</p> <pre><code>{\n  \"serial\": \"d073d5000001\",\n  \"product_id\": 27,\n  \"label\": \"Living Room Light\",\n  \"power_level\": 65535,\n  \"color\": {\n    \"hue\": 21845,\n    \"saturation\": 65535,\n    \"brightness\": 32768,\n    \"kelvin\": 4000\n  },\n  \"location\": \"Living Room\",\n  \"group\": \"Main Lights\",\n  \"zone_colors\": [],\n  \"tile_devices\": [],\n  \"infrared_brightness\": 0,\n  \"hev_state\": null\n}\n</code></pre>"},{"location":"cli/storage/#restoration-on-startup","title":"Restoration on Startup","text":"<p>When a device is created with the same serial as a previously saved device, its state is automatically restored:</p> <pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\nfrom lifx_emulator import create_color_light\n\nstorage = AsyncDeviceStorage()\n\n# First session - state is created\ndevice1 = create_color_light(\"d073d5000001\", storage=storage)\ndevice1.state.label = \"Kitchen Light\"\ndevice1.state.color.hue = 10923  # Orange\n\n# State changes are automatically queued for saving\n# (saved asynchronously with debouncing)\n\n# Later session - state is restored\ndevice2 = create_color_light(\"d073d5000001\", storage=storage)\nassert device2.state.label == \"Kitchen Light\"\nassert device2.state.color.hue == 10923\n</code></pre>"},{"location":"cli/storage/#automatic-saving","title":"Automatic Saving","text":"<p>Device state is automatically saved (asynchronously) after certain operations:</p> <pre><code>device = create_color_light(\"d073d5000001\", storage=storage)\n\n# These automatically trigger async saves with debouncing:\n# - Color changes (via protocol packets)\n# - Power state changes\n# - Label changes\n# - Group/Location changes\n\n# AsyncDeviceStorage queues saves and flushes with debouncing\n# to minimize I/O overhead (default: 100ms debounce)\n</code></pre> <p>The <code>AsyncDeviceStorage</code> class provides high-performance non-blocking saves by:</p> <ul> <li>Debouncing: Coalescing rapid changes to the same device</li> <li>Batch writes: Grouping multiple devices in single flush</li> <li>Executor-based I/O: Running I/O in background thread</li> <li>Adaptive flushing: Flushing early if queue size threshold is reached</li> </ul>"},{"location":"cli/storage/#advanced-usage","title":"Advanced Usage","text":""},{"location":"cli/storage/#managing-multiple-devices","title":"Managing Multiple Devices","text":"<pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\nfrom lifx_emulator import create_color_light, create_multizone_light\n\nstorage = AsyncDeviceStorage()\n\n# Create multiple devices - each maintains its own state file\ndevices = [\n    create_color_light(\"d073d5000001\", storage=storage),\n    create_color_light(\"d073d5000002\", storage=storage),\n    create_multizone_light(\"d073d8000001\", storage=storage),\n]\n\n# All state is independently persisted and restored asynchronously\n</code></pre>"},{"location":"cli/storage/#clearing-saved-state","title":"Clearing Saved State","text":"<pre><code>storage = AsyncDeviceStorage()\n\n# Delete saved state for one device (synchronous)\nstorage.delete_device_state(\"d073d5000001\")\n\n# Delete all saved state\nstorage.delete_all_device_states()\n\n# List all saved devices\ndevices = storage.list_devices()\n</code></pre>"},{"location":"cli/storage/#backup-and-restore","title":"Backup and Restore","text":"<pre><code># Backup device state\ncp -r ~/.lifx-emulator ~/.lifx-emulator.backup\n\n# Restore from backup\ncp -r ~/.lifx-emulator.backup/* ~/.lifx-emulator/\n</code></pre>"},{"location":"cli/storage/#scenarios-with-persistent-storage","title":"Scenarios with Persistent Storage","text":"<p>Combine persistent storage with test scenarios:</p> <pre><code>from lifx_emulator import create_color_light\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\nfrom lifx_emulator.scenarios.manager import ScenarioConfig\n\nstorage = AsyncDeviceStorage()\ndevice = create_color_light(\"d073d5000001\", storage=storage)\n\n# Configure scenario\ndevice.scenarios = ScenarioConfig(\n    response_delays={101: 0.5}  # 500ms delay on GetColor\n)\n\n# State + scenario config both persist across restarts\n</code></pre>"},{"location":"cli/storage/#persistent-scenarios","title":"Persistent Scenarios","text":"<p>In addition to device state, test scenarios can also be persisted:</p> <pre><code># Enable both device state and scenario persistence\nlifx-emulator --persistent --persistent-scenarios\n</code></pre> <p>This saves scenario configurations to <code>~/.lifx-emulator/scenarios.json</code>.</p>"},{"location":"cli/storage/#api-reference","title":"API Reference","text":"<p>For complete API documentation, see:</p> <ul> <li>Storage API Reference</li> <li>AsyncDeviceStorage class reference</li> <li>File format specification</li> </ul>"},{"location":"cli/storage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/storage/#saved-state-not-loading","title":"Saved State Not Loading","text":"<ol> <li>Check that the serial matches exactly (case-sensitive hex)</li> <li>Verify the file exists: <code>ls ~/.lifx-emulator/</code></li> <li>Check file permissions: <code>ls -la ~/.lifx-emulator/</code></li> <li>Check for JSON syntax errors: <code>cat ~/.lifx-emulator/{serial}.json | python -m json.tool</code></li> </ol>"},{"location":"cli/storage/#storage-directory-issues","title":"Storage Directory Issues","text":"<pre><code># Ensure storage directory exists with proper permissions\nmkdir -p ~/.lifx-emulator\nchmod 700 ~/.lifx-emulator\n\n# Check for disk space\ndf -h ~/.lifx-emulator\n</code></pre>"},{"location":"cli/storage/#clearing-all-state","title":"Clearing All State","text":"<pre><code># Remove all saved state\nrm -rf ~/.lifx-emulator/\n\n# Or use the API\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\nstorage = AsyncDeviceStorage()\nfor serial in storage.list_devices():\n    storage.delete_device_state(serial)\n</code></pre>"},{"location":"cli/storage/#best-practices","title":"Best Practices","text":"<ol> <li>Use storage for integration tests - Persist state across test sessions</li> <li>Back up important state - Use <code>cp -r ~/.lifx-emulator ~/.lifx-emulator.backup</code></li> <li>Clean up after tests - Delete device state when tests complete</li> <li>Use meaningful serials - Make it easy to identify saved devices</li> <li>Version your state - Keep track of state changes in git if needed</li> </ol>"},{"location":"cli/storage/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Scenarios Guide - Combine with error scenarios</li> <li>Storage API Reference - Detailed API documentation</li> <li>Advanced Testing Guide - Integration patterns</li> </ul>"},{"location":"cli/web-interface/","title":"Web Interface Guide","text":""},{"location":"cli/web-interface/#overview","title":"Overview","text":"<p>The LIFX Emulator includes a built-in web interface for real-time monitoring and device management. The dashboard provides a browser-based alternative to the REST API, with live updates of server statistics, device status, and packet activity.</p> <p>Access: Open <code>http://localhost:8080</code> in your web browser (after starting the emulator with <code>--api</code>)</p>"},{"location":"cli/web-interface/#getting-started","title":"Getting Started","text":""},{"location":"cli/web-interface/#enable-the-web-interface","title":"Enable the Web Interface","text":"<pre><code># Start emulator with API (enables web interface)\nlifx-emulator --api\n\n# Custom host and port\nlifx-emulator --api --api-host 127.0.0.1 --api-port 9090\n\n# Then open in browser:\n# http://localhost:8080\n# or http://127.0.0.1:9090\n</code></pre>"},{"location":"cli/web-interface/#interface-layout","title":"Interface Layout","text":"<p>The web interface is organized into three main sections:</p>"},{"location":"cli/web-interface/#server-statistics-card-top-left","title":"Server Statistics Card (Top Left)","text":"<p>Displays real-time emulator health metrics:</p> <pre><code>Server Statistics\n\u251c\u2500 Uptime: 123s\n\u251c\u2500 Devices: 3\n\u251c\u2500 Packets RX: 1250\n\u251c\u2500 Packets TX: 2100\n\u2514\u2500 Errors: 0\n</code></pre> <p>Metrics:</p> <ul> <li>Uptime: Time since server started (auto-updating)</li> <li>Devices: Number of currently emulated devices</li> <li>Packets RX: Total packets received from LIFX clients</li> <li>Packets TX: Total packets sent to LIFX clients</li> <li>Errors: Total packet processing errors</li> </ul> <p>Use Cases:</p> <ul> <li>Verify API server is running</li> <li>Monitor packet flow during testing</li> <li>Check for errors during protocol testing</li> </ul>"},{"location":"cli/web-interface/#add-device-card-top-right","title":"Add Device Card (Top Right)","text":"<p>Creates new devices on the fly:</p> <pre><code>Add Device\n\u251c\u2500 Product ID: [dropdown menu]\n\u2514\u2500 [Add Device button]\n</code></pre> <p>Features:</p> <ul> <li>Dropdown list of common products:</li> <li>27 - LIFX A19 (color light)</li> <li>29 - LIFX A19 Night Vision</li> <li>32 - LIFX Z (multizone strip)</li> <li>38 - LIFX Beam (extended multizone)</li> <li>50 - LIFX Mini White to Warm</li> <li>55 - LIFX Tile (matrix device)</li> <li>90 - LIFX Clean (HEV)</li> <li>Serial numbers are auto-generated</li> </ul> <p>Use Cases:</p> <ul> <li>Quick device creation for testing</li> <li>Create multiple device types without CLI</li> <li>Test with different device configurations</li> </ul>"},{"location":"cli/web-interface/#devices-section","title":"Devices Section","text":"<p>Displays all emulated devices with detailed status:</p> <pre><code>Devices (3)                    [Remove All]  [Clear Storage]\n\n\u250c\u2500 Device Card \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 d073d5000001                                    [Del]  \u2502\n\u2502 Living Room Light                                      \u2502\n\u2502                                                        \u2502\n\u2502 [ON]  [P27]  [color]  [multizone\u00d716]  [HEV]         \u2502\n\u2502                                                        \u2502\n\u2502 \u25b8 Show metadata  (click to expand)                    \u2502\n\u2502 \u25b8 Show zones (16)  (click to expand)                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"cli/web-interface/#device-card-components","title":"Device Card Components","text":"<p>Header:</p> <ul> <li>Device serial number (clickable, displays copy tooltip)</li> <li>Device label (e.g., \"Living Room Light\")</li> <li>Delete button (red, with confirmation)</li> </ul> <p>Status Badges:</p> <ul> <li>Power status: <code>[ON]</code> (green) or <code>[OFF]</code> (gray)</li> <li>Product ID: <code>[P27]</code> (light blue)</li> <li>Capabilities: <code>[color]</code>, <code>[multizone\u00d716]</code>, <code>[HEV]</code>, etc.</li> <li>Extended multizone: <code>[extended-mz\u00d780]</code> (green)</li> </ul> <p>Expandable Metadata (click \"\u25b8 Show metadata\"): <pre><code>Firmware: 3.70\nVendor: 1\nProduct: 27\nCapabilities: Color, Multizone (16 zones)\nGroup: (empty)\nLocation: (empty)\nUptime: 123s\nWiFi Signal: -45.5 dBm\n</code></pre></p> <p>Color/Zone Display:</p> <p>For color lights: <pre><code>\u25b8 Show zones\n  \u25a0 Current color\n</code></pre></p> <p>For multizone devices: <pre><code>\u25b8 Show zones (16)  (click to expand)\n  [colored strips representing each zone]\n</code></pre></p> <p>For matrix/tile devices: <pre><code>\u25b8 Show tiles (5)  (click to expand)\n  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n  \u2502 T1       \u2502  (8\u00d78 zone grid)\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2502 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 \u2502\n  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n  (repeats for each tile)\n</code></pre></p> <p>Zone Display:</p> <ul> <li>Each zone shown as a colored segment</li> <li>Colors represent current HSBK values</li> <li>Heights approximately proportional to brightness</li> <li>Saturation affects color intensity</li> <li>Hue determines the color</li> </ul>"},{"location":"cli/web-interface/#recent-activity-log-bottom","title":"Recent Activity Log (Bottom)","text":"<p>Displays the last 100 LIFX protocol packets in real-time:</p> <pre><code>Recent Activity\n\n12:34:56  RX  GetColor           d073d5000001  192.168.1.100:54321\n12:34:56  TX  State              d073d5000001  192.168.1.100:54321\n12:34:57  RX  GetPower           d073d5000002  192.168.1.101:54322\n12:34:57  TX  StatePower         d073d5000002  192.168.1.101:54322\n</code></pre> <p>Activity Event Fields:</p> <ul> <li>Time: HH:MM:SS (local time)</li> <li>Direction:</li> <li><code>RX</code> (blue) - Received from client</li> <li><code>TX</code> (orange) - Transmitted to client</li> <li>Packet Name: Human-readable LIFX packet type (e.g., \"GetColor\", \"SetColor\")</li> <li>Device: Target device serial number</li> <li>Address: Client IP address and port</li> </ul> <p>Use Cases:</p> <ul> <li>Debugging LIFX client communication</li> <li>Verifying packet flow</li> <li>Monitoring protocol interactions</li> <li>Identifying communication problems</li> </ul> <p>Note: Activity log is only visible if activity logging is enabled (<code>--api-activity</code> flag, default: true). Disable to reduce server traffic.</p>"},{"location":"cli/web-interface/#common-tasks","title":"Common Tasks","text":""},{"location":"cli/web-interface/#add-a-new-device","title":"Add a New Device","text":"<ol> <li>Open the web interface: <code>http://localhost:8080</code></li> <li>Find the \"Add Device\" card (top right)</li> <li>Select a product from the dropdown menu</li> <li>Click \"Add Device\" button</li> <li>New device appears in the Devices section with auto-generated serial</li> </ol> <p>The device is immediately available to LIFX clients and is added to the emulator runtime (not persisted to disk unless <code>--persistent</code> flag is used).</p>"},{"location":"cli/web-interface/#check-device-status","title":"Check Device Status","text":"<ol> <li>Locate device in the Devices section</li> <li>Check power badge (<code>[ON]</code> or <code>[OFF]</code>)</li> <li>Check capability badges (color, multizone, matrix, HEV, etc.)</li> <li>Click \"\u25b8 Show metadata\" to view:</li> <li>Firmware version</li> <li>Product ID and vendor</li> <li>Assigned group and location</li> <li>Device uptime</li> <li>WiFi signal strength</li> </ol>"},{"location":"cli/web-interface/#view-multizone-colors","title":"View Multizone Colors","text":"<p>For multizone devices (strips, beams):</p> <ol> <li>Locate device in Devices section</li> <li>Click \"\u25b8 Show zones\" to expand</li> <li>Colored bar displays all zone colors</li> <li>Each segment represents one zone</li> <li>Color indicates current HSBK values</li> <li>Click again to collapse</li> </ol> <p>Color Interpretation:</p> <ul> <li>Hue (0-360\u00b0): Color wheel position</li> <li>Saturation (0-100%): Color intensity (white to saturated)</li> <li>Brightness (0-100%): Light intensity</li> <li>Kelvin (1500-9000K): Color temperature</li> </ul>"},{"location":"cli/web-interface/#view-tilematrix-colors","title":"View Tile/Matrix Colors","text":"<p>For matrix devices (tiles, candles, ceiling):</p> <ol> <li>Locate device in Devices section</li> <li>Click \"\u25b8 Show tiles\" to expand</li> <li>Grid display shows zone colors</li> <li>Each small square is one zone</li> <li>Tiles labeled T1, T2, etc.</li> <li>Click again to collapse</li> </ol>"},{"location":"cli/web-interface/#monitor-packet-activity","title":"Monitor Packet Activity","text":"<ol> <li>Scroll to \"Recent Activity\" section (bottom)</li> <li>Watch for real-time packet updates</li> <li>Filter mentally by:</li> <li>Direction: RX (requests) vs TX (responses)</li> <li>Packet type: GetColor, SetColor, StatePower, etc.</li> <li>Device: Compare multiple devices</li> <li>Client address: Identify different clients</li> </ol> <p>Common Packet Patterns: <pre><code>RX GetService (broadcast)     &lt;- Client discovering devices\nTX StateService (response)    &lt;- Device responds\n\nRX GetColor                   &lt;- Client querying color\nTX State (color response)     &lt;- Device responds\n\nRX SetColor + params          &lt;- Client setting new color\nTX Acknowledgment             &lt;- Device confirms\n\nRX GetPower                   &lt;- Client querying power\nTX StatePower                 &lt;- Device responds\n</code></pre></p>"},{"location":"cli/web-interface/#remove-a-device","title":"Remove a Device","text":"<p>Remove Single Device:</p> <ol> <li>Locate device in Devices section</li> <li>Click red \"Del\" button on device card</li> <li>Confirm deletion in prompt</li> <li>Device disappears from list</li> <li>Device stops responding to LIFX protocol packets</li> </ol> <p>Remove All Devices:</p> <ol> <li>Click \"Remove All\" button (top right of Devices section)</li> <li>Confirmation dialog shows: \"Remove all X device(s)?\"</li> <li>Click OK to confirm</li> <li>All devices removed from runtime (storage preserved)</li> </ol>"},{"location":"cli/web-interface/#clear-persistent-storage","title":"Clear Persistent Storage","text":"<p>If <code>--persistent</code> flag was used to enable state persistence:</p> <ol> <li>Click \"Clear Storage\" button (top right of Devices section)</li> <li>Confirmation dialog shows: \"Clear all persistent device state?\"</li> <li>Click OK to confirm</li> <li>All saved device state files deleted from disk</li> <li>Currently running devices NOT affected</li> <li>Next restart will start with no saved state</li> </ol>"},{"location":"cli/web-interface/#features-and-capabilities","title":"Features and Capabilities","text":""},{"location":"cli/web-interface/#real-time-updates","title":"Real-Time Updates","text":"<ul> <li>Dashboard auto-refreshes every 2 seconds</li> <li>Server statistics updated in real-time</li> <li>Device list and status refreshed</li> <li>Activity log scrolls with new packets</li> <li>No manual refresh button needed</li> </ul>"},{"location":"cli/web-interface/#persistent-ui-state","title":"Persistent UI State","text":"<p>The interface remembers your preferences:</p> <ul> <li>Zone/tile display states (expanded/collapsed) per device</li> <li>Metadata display states (expanded/collapsed) per device</li> <li>Preferences stored in browser localStorage</li> <li>Persists across page reloads</li> <li>Per-device basis (no global toggle)</li> </ul>"},{"location":"cli/web-interface/#color-display","title":"Color Display","text":"<p>Colors are displayed accurately:</p> <ul> <li>HSBK to RGB conversion for display</li> <li>Hue: Color wheel position</li> <li>Saturation: Intensity/purity</li> <li>Brightness: Light level</li> <li>Kelvin: Color temperature (white point)</li> </ul>"},{"location":"cli/web-interface/#responsive-design","title":"Responsive Design","text":"<ul> <li>Adapts to different screen sizes</li> <li>Device cards responsive grid layout</li> <li>Touch-friendly on tablets</li> <li>Dark theme optimized for monitoring</li> </ul>"},{"location":"cli/web-interface/#performance-considerations","title":"Performance Considerations","text":""},{"location":"cli/web-interface/#activity-logging-impact","title":"Activity Logging Impact","text":"<p>Activity logging has performance implications:</p> <pre><code># Disable activity logging (reduces traffic)\nlifx-emulator --api --api-activity=false\n\n# Activity endpoint returns 503 Service Unavailable when disabled\ncurl http://localhost:8080/api/activity\n# Response: 503 Service Unavailable\n</code></pre>"},{"location":"cli/web-interface/#optimal-configuration-for-monitoring","title":"Optimal Configuration for Monitoring","text":"<pre><code># Balance between visibility and performance\nlifx-emulator --api \\\n  --api-host 127.0.0.1 \\  # Limit to localhost if not needed on network\n  --api-port 8080\n</code></pre>"},{"location":"cli/web-interface/#browser-performance","title":"Browser Performance","text":"<p>For emulators with many devices (50+):</p> <ul> <li>Activity log auto-update may slow down browser</li> <li>Consider disabling activity logging (<code>--api-activity=false</code>)</li> <li>Refresh page if UI becomes sluggish</li> <li>Use REST API directly for automated monitoring</li> </ul>"},{"location":"cli/web-interface/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cli/web-interface/#web-interface-not-loading","title":"Web Interface Not Loading","text":"<pre><code># Check if API server is running\ncurl http://localhost:8080/api/stats\n\n# Check if port is correct\n# Default: http://localhost:8080\n# Custom: http://localhost:9090  (if --api-port 9090)\n</code></pre>"},{"location":"cli/web-interface/#activity-log-not-updating","title":"Activity Log Not Updating","text":"<ul> <li>Ensure <code>--api-activity</code> is not disabled (default: enabled)</li> <li>Check browser developer console for errors</li> <li>Try refreshing page</li> </ul>"},{"location":"cli/web-interface/#devices-not-appearing","title":"Devices Not Appearing","text":"<pre><code># Verify devices exist via API\ncurl http://localhost:8080/api/devices | jq\n\n# Check emulator logs for creation errors\n# Device should appear in response\n</code></pre>"},{"location":"cli/web-interface/#zones-not-displaying","title":"Zones Not Displaying","text":"<p>For multizone devices:</p> <ul> <li>Click \"\u25b8 Show zones\" to expand display</li> <li>Ensure device has <code>has_multizone: true</code></li> <li>Check that zone_count &gt; 0 and zone_colors array is populated</li> </ul> <p>For tile/matrix devices:</p> <ul> <li>Click \"\u25b8 Show tiles\" to expand display</li> <li>Ensure device has <code>has_matrix: true</code></li> <li>Check that tile_count &gt; 0 and colors are populated</li> </ul>"},{"location":"cli/web-interface/#browser-compatibility","title":"Browser Compatibility","text":"<p>Tested and Supported:</p> <ul> <li>Chrome/Chromium 90+</li> <li>Firefox 88+</li> <li>Safari 14+</li> <li>Edge 90+</li> </ul> <p>Required:</p> <ul> <li>JavaScript enabled</li> <li>LocalStorage for UI state persistence</li> <li>CSS Grid support</li> </ul>"},{"location":"cli/web-interface/#security-considerations","title":"Security Considerations","text":"<p>The web interface provides no authentication or authorization:</p> <ul> <li>Intended for local development/testing only</li> <li>No user login required</li> <li>All operations available to anyone with network access</li> <li>Consider firewall rules if on shared network</li> <li>Use <code>--api-host 127.0.0.1</code> for localhost-only access</li> </ul>"},{"location":"cli/web-interface/#advanced-features","title":"Advanced Features","text":""},{"location":"cli/web-interface/#serial-number-details","title":"Serial Number Details","text":"<p>Each device has a unique 12-character hexadecimal serial:</p> <ul> <li>Default prefix: <code>d073d5</code></li> <li>Default range: <code>d073d5000001</code> - <code>d073d5999999</code></li> <li>Can be customized with <code>--serial-prefix</code> and <code>--serial-start</code> CLI flags</li> </ul>"},{"location":"cli/web-interface/#product-ids","title":"Product IDs","text":"<p>Common products:</p> <ul> <li>27: LIFX A19 (color light)</li> <li>29: LIFX A19 Night Vision (infrared)</li> <li>32: LIFX Z (multizone strip)</li> <li>38: LIFX Beam (extended multizone)</li> <li>50: LIFX Mini White to Warm (color temperature)</li> <li>55: LIFX Tile (matrix/tile device)</li> <li>90: LIFX Clean (HEV)</li> </ul> <p>See <code>lifx-emulator list-products</code> for complete list.</p>"},{"location":"cli/web-interface/#related-documentation","title":"Related Documentation","text":"<ul> <li>Device Management API - Programmatic API access</li> <li>Scenario Management API - Test scenario configuration</li> </ul>"},{"location":"development/","title":"Developer Documentation","text":"<p>Practical guide for developers working on the lifx-emulator codebase</p>"},{"location":"development/#welcome","title":"Welcome","text":"<p>This section provides developer-focused documentation for navigating and contributing to the lifx-emulator project. Whether you're fixing a bug, adding a feature, or just exploring the codebase, this guide will help you get oriented quickly.</p>"},{"location":"development/#quick-links","title":"Quick Links","text":""},{"location":"development/#essential-reading","title":"Essential Reading","text":"<ul> <li>Code Navigation Guide - Navigate the codebase efficiently</li> <li>Architecture Overview - Understand system design</li> <li>Architecture Decisions - Design rationale and ADRs</li> <li>Testing Guide - Writing and running tests</li> </ul>"},{"location":"development/#quick-start","title":"Quick Start","text":"<ul> <li>Installation - Set up your development environment</li> <li>Best Practices - Code quality standards</li> </ul>"},{"location":"development/#understanding-the-architecture","title":"Understanding the Architecture","text":"<p>Before diving into development, understand the system design:</p> <ul> <li>Architecture Overview - System layers and component interaction</li> <li>Architecture Decisions - 15 ADRs explaining design choices</li> <li>Packet Flow - How packets are processed</li> <li>Protocol Details - Binary protocol implementation</li> <li>Device State - State management internals</li> </ul> <p>This Development section focuses on navigating and modifying the codebase, not architectural theory.</p>"},{"location":"development/#code-navigation-guide","title":"Code Navigation Guide","text":"<p>Purpose: Help you find your way around the codebase quickly</p> <p>What's inside: - Package structure and file organization (13.6k LOC core library) - Entry points and main exports - Layer architecture (Network \u2192 Domain \u2192 Repository \u2192 Persistence) - Common code paths and module dependencies - Quick command reference for development</p> <p>When to use: - First time exploring the codebase - Looking for where specific functionality lives - Understanding how modules relate to each other - Finding test files or documentation</p> <p>Read the Code Navigation Guide \u2192</p>"},{"location":"development/#getting-started-as-a-developer","title":"Getting Started as a Developer","text":""},{"location":"development/#1-environment-setup","title":"1. Environment Setup","text":"<pre><code># Clone repository\ngit clone https://github.com/Djelibeybi/lifx-emulator.git\ncd lifx-emulator\n\n# Install dependencies (uses uv package manager)\nuv sync\n\n# Activate virtual environment\nsource .venv/bin/activate\n\n# Verify installation\npytest --version\npyright --version\nruff --version\n</code></pre>"},{"location":"development/#2-run-tests","title":"2. Run Tests","text":"<pre><code># Run all tests (764 tests)\npytest\n\n# Run with coverage report\npytest --cov=lifx_emulator --cov=lifx_emulator_app --cov-report=html\n\n# Run specific module tests\npytest packages/lifx-emulator-core/tests/test_device.py -v\n\n# Run specific test\npytest packages/lifx-emulator-core/tests/test_device.py::test_process_packet -v\n</code></pre>"},{"location":"development/#3-code-quality-checks","title":"3. Code Quality Checks","text":"<pre><code># Lint and auto-fix\nruff check --fix .\n\n# Type checking\npyright\n\n# Run all quality checks (mimics CI)\nruff check . &amp;&amp; pyright &amp;&amp; pytest\n</code></pre>"},{"location":"development/#4-run-the-emulator","title":"4. Run the Emulator","text":"<pre><code># As module\npython -m lifx_emulator_app\n\n# As installed command\nlifx-emulator --api --verbose\n\n# With custom devices\nlifx-emulator --color 2 --multizone 1 --tile 1 --api\n</code></pre>"},{"location":"development/#5-build-documentation","title":"5. Build Documentation","text":"<pre><code># Serve locally (live reload)\nuv run mkdocs serve\n\n# Build static site\nuv run mkdocs build\n\n# View at http://localhost:8000\n</code></pre>"},{"location":"development/#development-workflow","title":"Development Workflow","text":""},{"location":"development/#adding-a-new-feature","title":"Adding a New Feature","text":"<ol> <li>Understand the architecture</li> <li>Read Architecture Decisions for context</li> <li>Review Architecture Overview for data flow</li> <li> <p>Check Code Navigation for file locations</p> </li> <li> <p>Write tests first (TDD approach)</p> </li> <li>Add test cases in appropriate <code>tests/</code> directory</li> <li>Ensure 95% coverage (minimum 80%)</li> <li> <p>Run <code>pytest -v</code> to verify tests fail</p> </li> <li> <p>Implement the feature</p> </li> <li>Follow existing patterns and layer boundaries</li> <li>Keep functions under 10 complexity (McCabe)</li> <li>Add type hints for all public APIs</li> <li> <p>Update docstrings</p> </li> <li> <p>Verify code quality <pre><code>ruff check --fix .        # Lint and format\npyright                   # Type checking\npytest --cov              # Test coverage\n</code></pre></p> </li> <li> <p>Update documentation</p> </li> <li>Add/update docstrings</li> <li>Update relevant markdown docs</li> <li> <p>Add examples if public API changed</p> </li> <li> <p>Submit pull request</p> </li> <li>Use conventional commits (feat:, fix:, docs:, etc.)</li> <li>Reference related issues</li> <li>Ensure CI passes</li> </ol>"},{"location":"development/#fixing-a-bug","title":"Fixing a Bug","text":"<ol> <li>Reproduce the bug</li> <li>Write a failing test case</li> <li> <p>Verify it fails: <code>pytest -v</code></p> </li> <li> <p>Locate the issue</p> </li> <li>Use Code Navigation to find relevant code</li> <li>Check Packet Flow for data flow</li> <li> <p>Add debug logging if needed</p> </li> <li> <p>Fix the bug</p> </li> <li>Make minimal changes</li> <li>Avoid scope creep</li> <li> <p>Maintain backwards compatibility</p> </li> <li> <p>Verify the fix <pre><code>pytest -v                 # All tests pass\npytest --cov              # Coverage maintained\nruff check . &amp;&amp; pyright   # Quality checks pass\n</code></pre></p> </li> <li> <p>Submit pull request</p> </li> <li>Use <code>fix:</code> prefix in commit message</li> <li>Explain root cause in PR description</li> <li>Reference issue number</li> </ol>"},{"location":"development/#refactoring-code","title":"Refactoring Code","text":"<ol> <li>Establish test coverage</li> <li>Ensure affected code has &gt;95% coverage</li> <li> <p>Add tests if needed: <code>pytest --cov=lifx_emulator.module</code></p> </li> <li> <p>Plan the refactoring</p> </li> <li>Review Architecture Decisions</li> <li>Don't violate established patterns</li> <li> <p>Consider backwards compatibility</p> </li> <li> <p>Refactor incrementally</p> </li> <li>Small, focused changes</li> <li>Run tests after each change</li> <li> <p>Keep commits atomic</p> </li> <li> <p>Verify no regressions <pre><code>pytest -v                 # All tests still pass\npytest --cov              # Coverage maintained/improved\nruff check .              # Complexity within limits\n</code></pre></p> </li> <li> <p>Update documentation</p> </li> <li>Revise docstrings</li> <li>Update architecture docs if needed</li> </ol>"},{"location":"development/#code-quality-standards","title":"Code Quality Standards","text":""},{"location":"development/#test-coverage","title":"Test Coverage","text":"<ul> <li>Target: 95% coverage</li> <li>Minimum: 80% (enforced by CI)</li> <li>Check: <code>pytest --cov --cov-report=term-missing</code></li> </ul>"},{"location":"development/#code-complexity","title":"Code Complexity","text":"<ul> <li>Max McCabe complexity: 10 per function</li> <li>Max arguments: 5 per function</li> <li>Max branches: 12 per function</li> <li>Max statements: 50 per function</li> <li>Check: <code>ruff check .</code> (enforced automatically)</li> </ul>"},{"location":"development/#type-checking","title":"Type Checking","text":"<ul> <li>Standard: Pyright standard mode</li> <li>Target: Python 3.11+</li> <li>Check: <code>pyright</code></li> </ul>"},{"location":"development/#formatting","title":"Formatting","text":"<ul> <li>Tool: Ruff formatter</li> <li>Line length: 88 characters</li> <li>Quote style: Double quotes</li> <li>Indent: 4 spaces</li> <li>Check: <code>ruff format --check .</code></li> <li>Fix: <code>ruff format .</code></li> </ul>"},{"location":"development/#import-organization","title":"Import Organization","text":"<ul> <li>Order: stdlib \u2192 third-party \u2192 local</li> <li>Tool: Ruff import sorter</li> <li>Check: <code>ruff check --select I .</code></li> <li>Fix: <code>ruff check --select I --fix .</code></li> </ul>"},{"location":"development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"development/#regenerating-auto-generated-code","title":"Regenerating Auto-Generated Code","text":"<p>Protocol packets (DO NOT EDIT <code>protocol/packets.py</code>): <pre><code>python -m lifx_emulator.protocol.generator\n# Downloads LIFX YAML spec and regenerates packets.py\n</code></pre></p> <p>Product registry (DO NOT EDIT <code>products/registry.py</code>): <pre><code>python -m lifx_emulator.products.generator\n# Downloads products.json from LIFX GitHub\n# Regenerates registry.py with all 137+ products\n# Updates specs.yml templates for new products\n</code></pre></p>"},{"location":"development/#adding-a-new-packet-type","title":"Adding a New Packet Type","text":"<ol> <li> <p>Regenerate protocol (if LIFX added new packet type):    <pre><code>python -m lifx_emulator.protocol.generator\n</code></pre></p> </li> <li> <p>Create handler function in appropriate handler module:    <pre><code># handlers/light_handlers.py\ndef handle_new_packet(\n    device: EmulatedLifxDevice,\n    packet: NewPacket,\n    header: LifxHeader,\n) -&gt; list[Any]:\n    # Implementation\n    return [ResponsePacket(...)]\n</code></pre></p> </li> <li> <p>Register handler in <code>handlers/registry.py</code>:    <pre><code>registry.register(NewPacket.PKT_TYPE, handle_new_packet)\n</code></pre></p> </li> <li> <p>Add tests in <code>tests/test_handlers.py</code>:    <pre><code>def test_handle_new_packet():\n    device = create_color_light()\n    packet = NewPacket(...)\n    header = create_test_header()\n    responses = handle_new_packet(device, packet, header)\n    assert len(responses) == 1\n    # ... assertions\n</code></pre></p> </li> </ol>"},{"location":"development/#adding-a-new-device-type","title":"Adding a New Device Type","text":"<ol> <li> <p>Add product to specs.yml (if needed):    <pre><code>products:\n  99:  # Product ID\n    zones: 16\n    tile_count: 5\n    # ... other specs\n</code></pre></p> </li> <li> <p>Create factory function in <code>factories/factory.py</code>:    <pre><code>def create_new_device_type(\n    serial: str | None = None,\n    storage: IDeviceStorageBackend | None = None,\n) -&gt; EmulatedLifxDevice:\n    builder = DeviceBuilder()\n    # ... configure builder\n    return builder.build()\n</code></pre></p> </li> <li> <p>Add to <code>__init__.py</code> exports:    <pre><code>__all__ = [\n    # ...\n    \"create_new_device_type\",\n]\n</code></pre></p> </li> <li> <p>Add CLI argument in <code>__main__.py</code>:    <pre><code>@app.default\ndef main(\n    # ...\n    new_device_type: int = 0,\n):\n    # ... device creation logic\n</code></pre></p> </li> <li> <p>Add tests:    <pre><code>def test_create_new_device_type():\n    device = create_new_device_type()\n    assert device.state.has_new_capability\n    # ... assertions\n</code></pre></p> </li> </ol>"},{"location":"development/#debugging-tips","title":"Debugging Tips","text":""},{"location":"development/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>lifx-emulator --verbose\n# Shows all packets sent/received with hex dumps\n</code></pre>"},{"location":"development/#inspect-device-state","title":"Inspect Device State","text":"<pre><code>import asyncio\nfrom lifx_emulator import create_color_light\n\ndevice = create_color_light()\nprint(device.state)  # Pretty-prints all state\n</code></pre>"},{"location":"development/#test-single-packet","title":"Test Single Packet","text":"<pre><code>from lifx_emulator.protocol.packets import Light\nfrom lifx_emulator.protocol.header import LifxHeader\n\npacket = Light.Get()\nheader = LifxHeader(\n    target=bytes.fromhex(\"d073d5000001\") + b\"\\x00\\x00\",\n    source=12345,\n    sequence=1,\n    pkt_type=Light.Get.PKT_TYPE,\n)\n\nresponses = device.process_packet(packet, header, (\"127.0.0.1\", 56700))\nprint(responses)\n</code></pre>"},{"location":"development/#profile-performance","title":"Profile Performance","text":"<pre><code># Using pytest with profiling\npytest --profile\n\n# Using cProfile\npython -m cProfile -s cumtime -m lifx_emulator_app\n</code></pre>"},{"location":"development/#check-coverage-gaps","title":"Check Coverage Gaps","text":"<pre><code>pytest --cov --cov-report=html\n# Open htmlcov/index.html in browser\n# Red lines = not covered\n</code></pre>"},{"location":"development/#cicd-pipeline","title":"CI/CD Pipeline","text":""},{"location":"development/#automated-checks-github-actions","title":"Automated Checks (GitHub Actions)","text":"<p>Every pull request runs: 1. Ruff lint check - Code quality and formatting 2. Pyright type check - Type safety validation 3. Pytest with coverage - All 764 tests, 95% coverage target 4. Multi-version testing - Python 3.11, 3.12, 3.13, 3.14 5. Documentation build - Ensures docs compile</p> <p>All checks must pass before merge.</p>"},{"location":"development/#semantic-release","title":"Semantic Release","text":"<p>The project uses semantic-release with conventional commits:</p> <ul> <li><code>feat:</code> \u2192 Minor version bump (1.x.0)</li> <li><code>fix:</code> \u2192 Patch version bump (1.0.x)</li> <li><code>BREAKING CHANGE:</code> \u2192 Major version bump (x.0.0)</li> <li><code>docs:</code>, <code>chore:</code>, <code>ci:</code> \u2192 No version bump</li> </ul> <p>Commit message format: <pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre></p> <p>Examples: <pre><code>feat(core): add HEV device support\n\nImplements HEV Clean device emulation with duration tracking.\n\nCloses #123\n\nfix(api): correct scenario merging precedence\n\nDevice-specific scenarios now correctly override type scenarios.\n\ndocs(guide): add scenario API examples\n</code></pre></p>"},{"location":"development/#project-structure-quick-reference","title":"Project Structure Quick Reference","text":"<pre><code>lifx-emulator/\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 lifx-emulator-core/          # Core library (13.6k LOC)\n\u2502   \u2502   \u251c\u2500\u2500 src/lifx_emulator/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 devices/             # Device lifecycle, state, persistence\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 scenarios/           # Test scenario management\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 protocol/            # LIFX binary protocol\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 handlers/            # Packet type handlers\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 products/            # Product registry\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 factories/           # Device creation\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 repositories/        # Storage abstraction\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 server.py            # UDP server\n\u2502   \u2502   \u2514\u2500\u2500 tests/                   # Core library tests\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 lifx-emulator/               # Standalone app (1.6k LOC)\n\u2502       \u251c\u2500\u2500 src/lifx_emulator_app/\n\u2502       \u2502   \u251c\u2500\u2500 __main__.py          # CLI entry point\n\u2502       \u2502   \u2514\u2500\u2500 api/                 # HTTP API (FastAPI)\n\u2502       \u2514\u2500\u2500 tests/                   # App/API tests\n\u2502\n\u251c\u2500\u2500 docs/                            # MkDocs documentation\n\u2502   \u251c\u2500\u2500 development/                 # This section\n\u2502   \u251c\u2500\u2500 architecture/                # System design\n\u2502   \u251c\u2500\u2500 guide/                       # User guides\n\u2502   \u251c\u2500\u2500 library/                     # Library API reference\n\u2502   \u251c\u2500\u2500 cli/                         # CLI/API documentation\n\u2502   \u2514\u2500\u2500 tutorials/                   # Step-by-step tutorials\n\u2502\n\u251c\u2500\u2500 pyproject.toml                   # Workspace config (uv)\n\u251c\u2500\u2500 mkdocs.yml                       # Documentation config\n\u2514\u2500\u2500 README.md                        # Project overview\n</code></pre>"},{"location":"development/#resources","title":"Resources","text":""},{"location":"development/#internal-documentation","title":"Internal Documentation","text":"<ul> <li>Architecture Overview</li> <li>Device Types Guide</li> <li>Testing Scenarios</li> <li>Integration Testing</li> <li>Best Practices</li> </ul>"},{"location":"development/#external-resources","title":"External Resources","text":"<ul> <li>LIFX LAN Protocol Docs</li> <li>LIFX Products JSON</li> <li>Python Type Hints</li> <li>asyncio Documentation</li> <li>Pytest Documentation</li> <li>FastAPI Documentation</li> </ul>"},{"location":"development/#tools-documentation","title":"Tools Documentation","text":"<ul> <li>uv Package Manager</li> <li>Ruff Linter</li> <li>Pyright Type Checker</li> <li>MkDocs</li> <li>Conventional Commits</li> </ul>"},{"location":"development/#getting-help","title":"Getting Help","text":""},{"location":"development/#contribution-guidelines","title":"Contribution Guidelines","text":"<p>For detailed contribution information: - Code of conduct: Follow respectful collaboration practices - How to submit issues: Use GitHub Issues with clear descriptions - Pull request process: Use conventional commits, ensure CI passes - Development setup: See Getting Started above</p>"},{"location":"development/#questions-and-discussion","title":"Questions and Discussion","text":"<ul> <li>Issues: GitHub Issues</li> <li>Discussions: GitHub Discussions</li> </ul>"},{"location":"development/#next-steps","title":"Next Steps","text":"<ol> <li>First time here? Start with Code Navigation</li> <li>Planning a feature? Read Architecture Decisions</li> <li>Need to understand data flow? Check Packet Flow</li> <li>Ready to code? Review the Getting Started section above</li> </ol> <p>Happy coding! \ud83d\ude80</p>"},{"location":"development/code-navigation/","title":"Code Navigation Guide","text":"<p>Developer-focused guide to navigating the lifx-emulator codebase</p>"},{"location":"development/code-navigation/#quick-stats","title":"Quick Stats","text":"<ul> <li>Core Library: 13,654 lines of Python across 41 files</li> <li>Standalone App: 1,672 lines of Python across modules</li> <li>Test Coverage: 95% (764 test cases)</li> <li>Documentation: 41 markdown files</li> </ul>"},{"location":"development/code-navigation/#package-structure","title":"Package Structure","text":"<pre><code>lifx-emulator/\n\u251c\u2500\u2500 packages/\n\u2502   \u251c\u2500\u2500 lifx-emulator-core/          # Library package (13.6k LOC)\n\u2502   \u2502   \u2514\u2500\u2500 src/lifx_emulator/\n\u2502   \u2502       \u251c\u2500\u2500 devices/             # Device lifecycle and state (10 files)\n\u2502   \u2502       \u251c\u2500\u2500 scenarios/           # Test scenario management (3 files)\n\u2502   \u2502       \u251c\u2500\u2500 protocol/            # LIFX binary protocol (7 files)\n\u2502   \u2502       \u251c\u2500\u2500 handlers/            # Packet type handlers (5 files)\n\u2502   \u2502       \u251c\u2500\u2500 products/            # Product registry (4 files)\n\u2502   \u2502       \u251c\u2500\u2500 factories/           # Device creation (6 files)\n\u2502   \u2502       \u251c\u2500\u2500 repositories/        # Storage abstraction (3 files)\n\u2502   \u2502       \u2514\u2500\u2500 server.py            # UDP server\n\u2502   \u2502\n\u2502   \u2514\u2500\u2500 lifx-emulator/               # Standalone package (1.6k LOC)\n\u2502       \u2514\u2500\u2500 src/lifx_emulator_app/\n\u2502           \u251c\u2500\u2500 __main__.py          # CLI entry point\n\u2502           \u2514\u2500\u2500 api/                 # HTTP API module\n\u2502               \u251c\u2500\u2500 app.py           # FastAPI application\n\u2502               \u251c\u2500\u2500 models.py        # Pydantic models\n\u2502               \u251c\u2500\u2500 routers/         # API endpoints\n\u2502               \u2514\u2500\u2500 services/        # Business logic\n\u2502\n\u251c\u2500\u2500 docs/                            # MkDocs documentation (41 files)\n\u2514\u2500\u2500 pyproject.toml                   # Workspace config\n</code></pre>"},{"location":"development/code-navigation/#core-library-lifx-emulator-core","title":"Core Library (<code>lifx-emulator-core</code>)","text":""},{"location":"development/code-navigation/#entry-points","title":"Entry Points","text":"<p>Main exports (<code>packages/lifx-emulator-core/src/lifx_emulator/__init__.py:1</code>) <pre><code>from lifx_emulator import (\n    EmulatedLifxServer,      # UDP server\n    EmulatedLifxDevice,      # Device instance\n    create_color_light,      # Factory functions\n    create_multizone_light,\n    create_tile_device,\n)\n</code></pre></p>"},{"location":"development/code-navigation/#layer-architecture","title":"Layer Architecture","text":""},{"location":"development/code-navigation/#1-network-layer","title":"1. Network Layer","text":"<p>Purpose: UDP protocol handling</p> <ul> <li><code>server.py:1</code> - <code>EmulatedLifxServer</code></li> <li>Responsibilities: Network I/O, packet routing</li> <li>Dependencies: <code>DeviceManager</code>, <code>HierarchicalScenarioManager</code></li> <li>Protocol: asyncio DatagramProtocol</li> </ul>"},{"location":"development/code-navigation/#2-domain-layer","title":"2. Domain Layer","text":"<p>Purpose: Business logic and device management</p> <p>Device Management (<code>devices/</code>) - <code>devices/manager.py:1</code> - <code>DeviceManager</code>   - Device lifecycle: add, remove, get, count   - Packet routing: target resolution, broadcast handling   - Scenario cache invalidation</p> <ul> <li><code>devices/device.py:1</code> - <code>EmulatedLifxDevice</code></li> <li>Main entry: <code>process_packet()</code> (line ~100)</li> <li>Packet dispatcher: <code>_handle_packet_type()</code> (line ~200)</li> <li>State storage: <code>DeviceState</code> dataclass</li> </ul> <p>Scenario Management (<code>scenarios/</code>) - <code>scenarios/manager.py:1</code> - <code>HierarchicalScenarioManager</code>   - 5-level precedence: device &gt; type &gt; location &gt; group &gt; global   - Scenario merging and caching   - Configuration: <code>ScenarioConfig</code> dataclass</p> <p>Protocol Layer (<code>protocol/</code>) - <code>protocol/packets.py:1</code> - Auto-generated packet classes   - 44+ packet types organized by namespace (Device, Light, MultiZone, Tile)   - Each class: <code>PKT_TYPE</code>, <code>pack()</code>, <code>unpack()</code>   - Registry: <code>PACKET_REGISTRY</code> dict</p> <ul> <li><code>protocol/header.py:1</code> - <code>LifxHeader</code></li> <li>36-byte LIFX packet header</li> <li>Key fields: target, source, sequence, pkt_type, flags</li> </ul> <p>Handler Registry (<code>handlers/</code>) - <code>handlers/registry.py:1</code> - <code>PacketHandlerRegistry</code>   - Maps packet types \u2192 handler functions   - Modular handlers by namespace:     - <code>device_handlers.py:1</code> - Device.* packets (types 2-59)     - <code>light_handlers.py:1</code> - Light.* packets (types 101-149)     - <code>multizone_handlers.py:1</code> - MultiZone.* packets (types 501-512)     - <code>tile_handlers.py:1</code> - Tile.* packets (types 701-720)</p>"},{"location":"development/code-navigation/#3-repository-layer","title":"3. Repository Layer","text":"<p>Purpose: Storage abstraction</p> <p>Interfaces (<code>repositories/</code>) - <code>repositories/storage_backend.py:1</code>   - <code>IDeviceRepository</code> - In-memory device collection   - <code>IDeviceStorageBackend</code> - Device state persistence   - <code>IScenarioStorageBackend</code> - Scenario persistence</p> <p>Implementations - <code>repositories/device_repository.py:1</code> - In-memory dict storage - <code>devices/persistence.py:1</code> - Async file persistence with debouncing - <code>scenarios/persistence.py:1</code> - Atomic scenario file writes</p>"},{"location":"development/code-navigation/#4-state-management","title":"4. State Management","text":"<p>Purpose: Device state representation</p> <p>State Dataclasses (<code>devices/states.py:1</code>) <pre><code>@dataclass\nclass DeviceState:\n    \"\"\"Complete device state\"\"\"\n    core: CoreDeviceState        # Serial, power, label, firmware\n    color: ColorState | None      # HSBK color for color devices\n    infrared: InfraredState | None\n    hev: HevState | None\n    multizone: MultiZoneState | None\n    matrix: MatrixState | None\n    relay: RelayState | None\n</code></pre></p> <p>Capability Detection - <code>has_color</code>, <code>has_infrared</code>, <code>has_multizone</code>, <code>has_matrix</code>, <code>has_hev</code> - <code>has_relays</code>, <code>has_buttons</code> (for LIFX Switch devices)</p>"},{"location":"development/code-navigation/#factory-system","title":"Factory System","text":"<p>Factory Functions (<code>factories/factory.py:1</code>) <pre><code># Simple factories\ncreate_color_light(serial, storage) -&gt; EmulatedLifxDevice\ncreate_multizone_light(serial, zone_count, extended_multizone, storage)\ncreate_tile_device(serial, tile_count, storage)\ncreate_switch(serial, product_id, storage)\n\n# Universal factory\ncreate_device(product_id, serial, zone_count, tile_count, storage)\n</code></pre></p> <p>Builder Pattern (<code>factories/builder.py:1</code>) <pre><code>builder = (\n    DeviceBuilder()\n    .with_serial(\"d073d5000001\")\n    .with_product(27)  # LIFX A19\n    .with_color_support()\n    .with_infrared_support()\n    .build()\n)\n</code></pre></p> <p>Configuration Services - <code>factories/serial_generator.py:1</code> - Serial number generation - <code>factories/firmware_config.py:1</code> - Firmware version logic - <code>factories/default_config.py:1</code> - Default color/power values</p>"},{"location":"development/code-navigation/#product-registry","title":"Product Registry","text":"<p>Registry (<code>products/registry.py:1</code>) - Auto-generated from LIFX GitHub (DO NOT EDIT) - 137+ product definitions with capabilities - Pre-built <code>ProductInfo</code> instances</p> <p>Specs (<code>products/specs.py:1</code> + <code>specs.yml</code>) - Product-specific configuration - Zone counts, tile dimensions, defaults - Manually maintained for accuracy</p> <p>Generator (<code>products/generator.py:1</code>) <pre><code>python -m lifx_emulator.products.generator\n# Downloads latest products.json\n# Regenerates registry.py\n# Updates specs.yml templates\n</code></pre></p>"},{"location":"development/code-navigation/#protocol-components","title":"Protocol Components","text":"<p>Serializer (<code>protocol/serializer.py:1</code>) - Low-level binary packing/unpacking - Handles: byte arrays, enums, nested types, arrays</p> <p>Types (<code>protocol/protocol_types.py:1</code>) - <code>LightHsbk</code> - Color representation - <code>TileStateDevice</code> - Tile configuration - Effect settings, enums, constants</p> <p>Generator (<code>protocol/generator.py:1</code>) <pre><code>python -m lifx_emulator.protocol.generator\n# Regenerates packets.py from LIFX YAML spec\n</code></pre></p>"},{"location":"development/code-navigation/#standalone-app-lifx-emulator","title":"Standalone App (<code>lifx-emulator</code>)","text":""},{"location":"development/code-navigation/#cli-entry-point","title":"CLI Entry Point","text":"<p>Main (<code>packages/lifx-emulator/src/lifx_emulator_app/__main__.py:1</code>) - Command-line argument parsing (cyclopts) - Device creation from CLI parameters - Server startup and lifecycle management - Subcommands: <code>list-products</code></p>"},{"location":"development/code-navigation/#http-api-module","title":"HTTP API Module","text":"<p>FastAPI App (<code>api/app.py:1</code>) <pre><code>def create_api_app(server: EmulatedLifxServer) -&gt; FastAPI:\n    \"\"\"Creates OpenAPI 3.1.0 compliant FastAPI application\"\"\"\n\ndef run_api_server(server, host, port):\n    \"\"\"Run uvicorn ASGI server\"\"\"\n</code></pre></p> <p>Routers (<code>api/routers/</code>) - <code>monitoring.py</code> - <code>/api/stats</code>, <code>/api/activity</code> - <code>devices.py</code> - <code>/api/devices</code>, <code>/api/devices/{serial}</code> - <code>scenarios.py</code> - <code>/api/scenarios/*</code> (5 scope levels)</p> <p>Models (<code>api/models.py:1</code>) - Pydantic request/response validation - OpenAPI schema generation - Type-safe API contracts</p> <p>Services (<code>api/services/</code>) - Business logic layer - Separates API concerns from domain logic</p>"},{"location":"development/code-navigation/#key-file-locations","title":"Key File Locations","text":""},{"location":"development/code-navigation/#configuration","title":"Configuration","text":"<ul> <li><code>pyproject.toml:1</code> - Workspace configuration</li> <li><code>packages/lifx-emulator-core/pyproject.toml:1</code> - Library package config</li> <li><code>packages/lifx-emulator/pyproject.toml:1</code> - App package config</li> </ul>"},{"location":"development/code-navigation/#testing","title":"Testing","text":"<ul> <li><code>packages/lifx-emulator-core/tests/</code> - Library tests</li> <li><code>packages/lifx-emulator/tests/</code> - App/API tests</li> <li>Test count: 764 total</li> </ul>"},{"location":"development/code-navigation/#documentation","title":"Documentation","text":"<ul> <li><code>docs/</code> - MkDocs documentation (41 files)</li> <li><code>CLAUDE.md:1</code> - AI assistant guidance</li> <li><code>README.md:1</code> - Project overview</li> </ul>"},{"location":"development/code-navigation/#auto-generated-do-not-edit","title":"Auto-Generated (DO NOT EDIT)","text":"<ul> <li><code>packages/lifx-emulator-core/src/lifx_emulator/products/registry.py:1</code></li> <li><code>packages/lifx-emulator-core/src/lifx_emulator/protocol/packets.py:1</code></li> </ul>"},{"location":"development/code-navigation/#common-code-paths","title":"Common Code Paths","text":""},{"location":"development/code-navigation/#creating-a-device","title":"Creating a Device","text":"<pre><code>CLI Args\n  \u2193\n__main__.py:main()\n  \u2193\nfactories/factory.py:create_*()\n  \u2193\nfactories/builder.py:DeviceBuilder\n  \u2193\ndevices/device.py:EmulatedLifxDevice()\n</code></pre>"},{"location":"development/code-navigation/#processing-a-packet","title":"Processing a Packet","text":"<pre><code>UDP Socket\n  \u2193\nserver.py:EmulatedLifxServer.handle_packet()\n  \u2193\ndevices/manager.py:DeviceManager.route_packet()\n  \u2193\ndevices/device.py:EmulatedLifxDevice.process_packet()\n  \u2193\nhandlers/registry.py:PacketHandlerRegistry.get_handler()\n  \u2193\nhandlers/*_handlers.py:handle_*()\n  \u2193\nResponse packets sent via UDP\n</code></pre>"},{"location":"development/code-navigation/#scenario-application","title":"Scenario Application","text":"<pre><code>Scenario Config\n  \u2193\nscenarios/manager.py:HierarchicalScenarioManager.set_*_scenario()\n  \u2193\nCache invalidation\n  \u2193\ndevices/device.py:EmulatedLifxDevice.invalidate_scenario_cache()\n  \u2193\nNext packet: get_scenario_for_device()\n  \u2193\nMerged scenario applied (drop/delay/malform)\n</code></pre>"},{"location":"development/code-navigation/#state-persistence","title":"State Persistence","text":"<pre><code>State Change\n  \u2193\ndevices/device.py:EmulatedLifxDevice.state (modified)\n  \u2193\nObserver pattern: notify state change\n  \u2193\ndevices/persistence.py:DevicePersistenceAsyncFile.save_device_state()\n  \u2193\nDebounced async write (100ms default)\n  \u2193\nJSON file: ~/.lifx-emulator/{serial}.json\n</code></pre>"},{"location":"development/code-navigation/#development-workflow","title":"Development Workflow","text":""},{"location":"development/code-navigation/#quick-commands","title":"Quick Commands","text":"<pre><code># Code quality\nruff check --fix .                # Lint and auto-fix\npyright                          # Type checking\npytest -v                        # Run all tests\n\n# Run emulator\npython -m lifx_emulator_app      # CLI mode\nlifx-emulator --api              # With HTTP API\n\n# Regenerate code\npython -m lifx_emulator.products.generator   # Update registry\npython -m lifx_emulator.protocol.generator   # Update packets\n</code></pre>"},{"location":"development/code-navigation/#testing-specific-components","title":"Testing Specific Components","text":"<pre><code># Test specific module\npytest packages/lifx-emulator-core/tests/test_device.py -v\n\n# Test with coverage\npytest --cov=lifx_emulator --cov-report=html\n\n# Run specific test\npytest packages/lifx-emulator-core/tests/test_device.py::test_process_packet -v\n</code></pre>"},{"location":"development/code-navigation/#module-dependencies","title":"Module Dependencies","text":""},{"location":"development/code-navigation/#core-library-dependencies","title":"Core Library Dependencies","text":"<pre><code>lifx_emulator/\n\u251c\u2500\u2500 server.py \u2192 devices.manager, scenarios.manager\n\u251c\u2500\u2500 devices/\n\u2502   \u251c\u2500\u2500 device.py \u2192 states, handlers.registry, scenarios.models\n\u2502   \u251c\u2500\u2500 manager.py \u2192 repositories.device_repository\n\u2502   \u251c\u2500\u2500 persistence.py \u2192 repositories.storage_backend\n\u2502   \u2514\u2500\u2500 states.py \u2192 (no internal deps)\n\u251c\u2500\u2500 scenarios/\n\u2502   \u251c\u2500\u2500 manager.py \u2192 models, persistence\n\u2502   \u2514\u2500\u2500 models.py \u2192 (pydantic only)\n\u251c\u2500\u2500 protocol/\n\u2502   \u251c\u2500\u2500 packets.py \u2192 header, serializer, protocol_types\n\u2502   \u2514\u2500\u2500 header.py \u2192 (struct only)\n\u251c\u2500\u2500 handlers/\n\u2502   \u2514\u2500\u2500 *_handlers.py \u2192 protocol.packets, devices.states\n\u251c\u2500\u2500 products/\n\u2502   \u2514\u2500\u2500 registry.py \u2192 specs\n\u2514\u2500\u2500 factories/\n    \u2514\u2500\u2500 factory.py \u2192 builder, devices.device, products.registry\n</code></pre>"},{"location":"development/code-navigation/#external-dependencies","title":"External Dependencies","text":"<ul> <li>pydantic: State validation, API models</li> <li>pyyaml: Product specs loading</li> <li>fastapi: HTTP API (app only)</li> <li>uvicorn: ASGI server (app only)</li> <li>cyclopts: CLI parsing (app only)</li> <li>rich: Terminal UI (app only)</li> </ul>"},{"location":"development/code-navigation/#cross-reference-index","title":"Cross-Reference Index","text":""},{"location":"development/code-navigation/#by-feature","title":"By Feature","text":"<p>Device Creation - Entry: <code>factories/__init__.py:1</code> - Functions: <code>factories/factory.py:1</code> - Builder: <code>factories/builder.py:1</code> - Docs: <code>docs/library/factories.md:1</code></p> <p>Packet Processing - Entry: <code>devices/device.py:100</code> (process_packet) - Handlers: <code>handlers/registry.py:1</code> - Protocol: <code>protocol/packets.py:1</code> - Docs: <code>docs/architecture/packet-flow.md:1</code></p> <p>State Management - States: <code>devices/states.py:1</code> - Persistence: <code>devices/persistence.py:1</code> - Serialization: <code>devices/state_serializer.py:1</code> - Docs: <code>docs/architecture/device-state.md:1</code>, <code>docs/library/storage.md:1</code></p> <p>Scenario Management - Manager: <code>scenarios/manager.py:1</code> - Models: <code>scenarios/models.py:1</code> - API: <code>api/routers/scenarios.py:1</code> - Docs: <code>docs/guide/testing-scenarios.md:1</code>, <code>docs/cli/scenario-api.md:1</code></p> <p>HTTP API - App: <code>api/app.py:1</code> - Routers: <code>api/routers/</code> - Models: <code>api/models.py:1</code> - Docs: <code>docs/cli/web-interface.md:1</code>, <code>docs/cli/device-management-api.md:1</code></p>"},{"location":"development/code-navigation/#by-layer","title":"By Layer","text":"<p>Network Layer - <code>server.py:1</code> - UDP server - Docs: <code>docs/library/server.md:1</code></p> <p>Domain Layer - <code>devices/manager.py:1</code> - Device management - <code>scenarios/manager.py:1</code> - Scenario management - Docs: <code>docs/architecture/overview.md:1</code></p> <p>Repository Layer - <code>repositories/device_repository.py:1</code> - In-memory storage - <code>repositories/storage_backend.py:1</code> - Interfaces - Docs: <code>docs/architecture/overview.md:1</code> (Repository Pattern section)</p> <p>Persistence Layer - <code>devices/persistence.py:1</code> - Device state files - <code>scenarios/persistence.py:1</code> - Scenario files - Docs: <code>docs/library/storage.md:1</code>, <code>docs/cli/storage.md:1</code></p>"},{"location":"development/code-navigation/#next-steps","title":"Next Steps","text":"<ul> <li>New to the codebase? Start with <code>docs/getting-started/quickstart.md:1</code></li> <li>Adding features? Review <code>docs/architecture/overview.md:1</code></li> <li>Writing tests? Check <code>docs/guide/integration-testing.md:1</code></li> <li>Using the API? See <code>docs/cli/device-management-api.md:1</code></li> <li>Understanding protocol? Read <code>docs/architecture/protocol.md:1</code></li> </ul>"},{"location":"development/code-navigation/#related-documentation","title":"Related Documentation","text":"<ul> <li>Architecture Overview - System design</li> <li>Device Types - Supported devices</li> <li>Testing Scenarios - Error simulation</li> <li>CLI Reference - Command-line options</li> <li>Library Reference - Python API</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Welcome to LIFX Emulator! This section will help you get up and running quickly.</p>"},{"location":"getting-started/#choose-your-package","title":"Choose Your Package","text":"<p>LIFX Emulator is available as two packages:</p> Package Best For <code>lifx-emulator</code> CLI tool, web dashboard, quick testing <code>lifx-emulator-core</code> Embedding in Python applications, pytest"},{"location":"getting-started/#learning-path","title":"Learning Path","text":""},{"location":"getting-started/#cli-users-lifx-emulator","title":"CLI Users (lifx-emulator)","text":"<ol> <li>Installation - Install the CLI tool</li> <li>Quick Start - Start emulating devices</li> <li>CLI Reference - All command-line options</li> </ol>"},{"location":"getting-started/#library-users-lifx-emulator-core","title":"Library Users (lifx-emulator-core)","text":"<ol> <li>Installation - Install the library</li> <li>Quick Start - Programmatic usage</li> <li>API Reference - Python API documentation</li> </ol>"},{"location":"getting-started/#quick-preview","title":"Quick Preview","text":"CLI (lifx-emulator)Python API (lifx-emulator-core) <pre><code># Install\npip install lifx-emulator\n\n# Run with one color light\nlifx-emulator\n\n# Create multiple devices with web dashboard\nlifx-emulator --color 2 --multizone 1 --tile 1 --api --verbose\n</code></pre> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n    device_manager = DeviceManager(DeviceRepository())\n\n    async with EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    ) as server:\n        print(f\"Emulating: {device.state.label}\")\n        await asyncio.Event().wait()\n\nasyncio.run(main())\n</code></pre>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11+ (or let uv manage it for you)</li> <li>Basic understanding of Python or command-line tools</li> <li>(Optional) Familiarity with LIFX devices or protocol</li> </ul>"},{"location":"getting-started/#why-uv","title":"Why uv?","text":"<p>We recommend uv because it:</p> <ul> <li>Automatically manages Python versions for you</li> <li>Is significantly faster than pip</li> <li>Handles virtual environments seamlessly</li> <li>Works consistently across platforms</li> </ul>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Once you've completed the getting started guide, explore:</p> <ul> <li>User Guides - Deeper understanding of features</li> <li>Tutorials - Hands-on learning with examples</li> <li>API Reference - Complete API documentation</li> </ul>"},{"location":"getting-started/#need-help","title":"Need Help?","text":"<ul> <li>Troubleshooting Guide</li> <li>FAQ</li> <li>GitHub Issues</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> <li>pip or uv package manager</li> </ul>"},{"location":"getting-started/installation/#choose-your-package","title":"Choose Your Package","text":"Package Install Command Use Case <code>lifx-emulator</code> <code>pip install lifx-emulator</code> CLI tool with HTTP API <code>lifx-emulator-core</code> <code>pip install lifx-emulator-core</code> Python library for embedding"},{"location":"getting-started/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"getting-started/installation/#lifx-emulator-cli-http-api","title":"lifx-emulator (CLI + HTTP API)","text":"<p>Recommended: Using uv (automatically manages Python environment):</p> <pre><code>uv tool install lifx-emulator\n</code></pre> <p>Alternative: Using pip (requires Python 3.11+ already installed):</p> <pre><code>pip install lifx-emulator\n</code></pre>"},{"location":"getting-started/installation/#lifx-emulator-core-python-library","title":"lifx-emulator-core (Python Library)","text":"<p>Using uv:</p> <pre><code>uv add lifx-emulator-core\n</code></pre> <p>Using pip:</p> <pre><code>pip install lifx-emulator-core\n</code></pre> <p>Then in your code:</p> <pre><code>from lifx_emulator import create_color_light, EmulatedLifxServer\n</code></pre>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>For development or to get the latest features:</p> <pre><code># Install uv if you don't have it\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# Clone the repository\ngit clone https://github.com/Djelibeybi/lifx-emulator.git\ncd lifx-emulator\n\n# Install dependencies and create virtual environment\nuv sync\n\n# Activate the virtual environment\nsource .venv/bin/activate\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":""},{"location":"getting-started/installation/#cli-package","title":"CLI Package","text":"<pre><code># Check CLI is available\nlifx-emulator --help\n\n# Run the emulator with verbose output\nlifx-emulator --verbose\n</code></pre> <p>You should see output like:</p> <pre><code>INFO - Starting LIFX Emulator on 127.0.0.1:56700\nINFO - Created 1 emulated device(s):\nINFO -   \u2022 A19 d073d5000001 (d073d5000001) - full color\nINFO - Server running with verbose packet logging... Press Ctrl+C to stop\n</code></pre>"},{"location":"getting-started/installation/#library-package","title":"Library Package","text":"<pre><code>from lifx_emulator import create_color_light\n\ndevice = create_color_light(\"d073d5000001\")\nprint(f\"Device: {device.state.label}\")\nprint(f\"Product: {device.state.product}\")\nprint(f\"Has color: {device.state.has_color}\")\n</code></pre>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":""},{"location":"getting-started/installation/#lifx-emulator-standalone","title":"lifx-emulator (Standalone)","text":"<ul> <li>lifx-emulator-core: Core emulation library</li> <li>fastapi: HTTP API framework</li> <li>uvicorn: ASGI server</li> <li>cyclopts: CLI framework</li> <li>rich: Terminal formatting</li> </ul>"},{"location":"getting-started/installation/#lifx-emulator-core-library","title":"lifx-emulator-core (Library)","text":"<ul> <li>pyyaml: For product registry and configuration</li> </ul>"},{"location":"getting-started/installation/#development-dependencies","title":"Development Dependencies","text":"<ul> <li>pytest: Testing framework</li> <li>pytest-asyncio: Async test support</li> <li>ruff: Fast Python linter</li> <li>pyright: Type checker</li> <li>hatchling: Build backend</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"getting-started/installation/#port-already-in-use","title":"Port Already in Use","text":"<p>If you see an error about port 56700 being in use:</p> <pre><code># Use a different port\nlifx-emulator --port 56701\n</code></pre>"},{"location":"getting-started/installation/#python-version","title":"Python Version","text":"<p>Ensure you're using Python 3.11+:</p> <pre><code>python --version\n</code></pre> <p>If you need to manage Python versions, we recommend using uv, which automatically handles Python version management:</p> <pre><code># Install uv\ncurl -LsSf https://astral.sh/uv/install.sh | sh\n\n# uv will automatically manage Python for you\nuv tool install lifx-emulator  # For CLI tool\n# or\nuv add lifx-emulator-core  # As a dependency of your project\n</code></pre>"},{"location":"getting-started/installation/#import-errors","title":"Import Errors","text":"<p>If you see import errors, ensure the package is installed:</p> <pre><code>pip show lifx-emulator-core\n</code></pre> <p>If not found, reinstall:</p> <pre><code>pip install --force-reinstall lifx-emulator-core\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start Guide - Create your first emulated device</li> <li>CLI Usage - Learn all CLI commands</li> <li>Device Types - Explore supported devices</li> </ul>"},{"location":"getting-started/quickstart/","title":"Quick Start","text":"<p>Get started with LIFX Emulator in just a few minutes.</p>"},{"location":"getting-started/quickstart/#start-the-emulator","title":"Start the Emulator","text":"<p>The simplest way to start the emulator is with the default configuration:</p> <pre><code>lifx-emulator\n</code></pre> <p>This creates a single color light device listening on port 56700.</p>"},{"location":"getting-started/quickstart/#using-verbose-mode","title":"Using Verbose Mode","text":"<p>To see all packet traffic (helpful for debugging):</p> <pre><code>lifx-emulator --verbose\n</code></pre> <p>You'll see output like:</p> <pre><code>INFO - Starting LIFX Emulator on 127.0.0.1:56700\nINFO - Created 1 emulated device(s):\nINFO -   \u2022 A19 d073d5 (d073d5000001) - full color\nINFO - Server running with verbose packet logging... Press Ctrl+C to stop\nDEBUG - Received 36 bytes from ('192.168.1.100', 54321)\nDEBUG - Header: GetService (type=2) target=000000000000 source=12345678\nDEBUG - Sending StateService to ('192.168.1.100', 54321)\n</code></pre>"},{"location":"getting-started/quickstart/#create-multiple-devices","title":"Create Multiple Devices","text":"<p>Create different device types:</p> <pre><code># Create 2 color lights, 1 multizone strip, and 1 tile\nlifx-emulator --color 2 --multizone 1 --tile 1\n</code></pre>"},{"location":"getting-started/quickstart/#use-specific-products","title":"Use Specific Products","text":"<p>Create devices by product ID from the LIFX registry:</p> <pre><code># Create LIFX A19 (27), LIFX Z (32), and LIFX Tile (55)\nlifx-emulator --product 27 --product 32 --product 55\n</code></pre> <p>See all available products:</p> <pre><code>lifx-emulator list-products\n</code></pre>"},{"location":"getting-started/quickstart/#python-api","title":"Python API","text":"<p>Use the emulator in your Python tests:</p> Basic ExampleMultiple DevicesTest Integration <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def main():\n    # Create a color light\n    device = create_color_light(\"d073d5000001\")\n\n    # Set up repository and manager (required)\n    device_repository = DeviceRepository()\n    device_manager = DeviceManager(device_repository)\n\n    # Start server\n    server = EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    )\n    await server.start()\n\n    print(f\"Server running with device: {device.state.label}\")\n\n    # Keep running\n    try:\n        await asyncio.Event().wait()\n    except KeyboardInterrupt:\n        await server.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import (\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def main():\n    # Create different device types\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_multizone_light(\"d073d8000001\", zone_count=16),\n        create_tile_device(\"d073d9000001\", tile_count=5),\n    ]\n\n    # Set up repository and manager (required)\n    device_repository = DeviceRepository()\n    device_manager = DeviceManager(device_repository)\n\n    # Start server\n    server = EmulatedLifxServer(\n        devices, device_manager, \"127.0.0.1\", 56700\n    )\n    await server.start()\n\n    print(f\"Server running with {len(devices)} devices\")\n\n    try:\n        await asyncio.Event().wait()\n    except KeyboardInterrupt:\n        await server.stop()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\nfrom your_lifx_library import LifxClient\n\n@pytest.fixture\ndef device_manager():\n    return DeviceManager(DeviceRepository())\n\n@pytest.mark.asyncio\nasync def test_discover_devices(device_manager):\n    # Create emulated devices\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    )\n\n    async with server:\n        # Use your LIFX library\n        client = LifxClient()\n        await client.discover(port=56700)\n\n        # Verify discovery\n        assert len(client.devices) == 1\n        assert client.devices[0].serial == \"d073d5000001\"\n\n@pytest.mark.asyncio\nasync def test_set_color(device_manager):\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    )\n\n    async with server:\n        client = LifxClient()\n        await client.discover(port=56700)\n\n        # Set color\n        await client.devices[0].set_color(hue=120, saturation=1.0, brightness=0.5)\n\n        # Verify state changed\n        assert device.state.color.hue == 21845  # 120 degrees in LIFX format\n        assert device.state.color.saturation == 65535\n        assert device.state.color.brightness == 32768\n</code></pre>"},{"location":"getting-started/quickstart/#device-discovery","title":"Device Discovery","text":"<p>The emulator responds to discovery broadcasts on port 56700 (or your chosen port). Your LIFX library should be able to discover emulated devices just like real ones.</p> <p>Example with a typical discovery flow:</p> <ol> <li>Your library broadcasts <code>GetService</code> (packet type 2)</li> <li>Emulator responds with <code>StateService</code> listing UDP service on port 56700</li> <li>Your library sends <code>GetVersion</code> to get product info</li> <li>Emulator responds with vendor=1, product=27 (or configured product)</li> <li>Your library can now send commands to control the device</li> </ol>"},{"location":"getting-started/quickstart/#next-steps","title":"Next Steps","text":"<ul> <li>CLI Usage Guide - Learn all CLI options</li> <li>Device Types - Explore supported devices</li> <li>Testing Scenarios - Configure error scenarios</li> <li>API Reference - Complete API documentation</li> <li>Tutorials - More code examples</li> </ul>"},{"location":"guide/","title":"User Guide Overview","text":"<p>Welcome to the LIFX Emulator User Guide. This guide helps you understand the emulator's features and use them effectively.</p>"},{"location":"guide/#prerequisites","title":"Prerequisites","text":"<p>Before reading this guide, you should have:</p> <ul> <li>Completed the Getting Started section</li> <li>Successfully run the emulator at least once</li> <li>Basic understanding of LIFX devices (optional but helpful)</li> </ul>"},{"location":"guide/#learning-path","title":"Learning Path","text":"<p>Read these guides in order for the best learning experience:</p> <ol> <li>Overview (below) - High-level concepts</li> <li>Device Types - What devices you can emulate</li> <li>Products and Specs - Product registry system</li> <li>Web Interface - Visual monitoring and management</li> <li>Integration Testing - Using in test suites</li> <li>Testing Scenarios - Simulating errors and edge cases</li> <li>Best Practices - Tips for effective testing</li> </ol>"},{"location":"guide/#what-is-lifx-emulator","title":"What is LIFX Emulator?","text":"<p>LIFX Emulator creates virtual LIFX devices that behave like real hardware. It implements the complete LIFX LAN protocol, allowing you to:</p>"},{"location":"guide/#test-without-hardware","title":"Test Without Hardware","text":"<p>No need to purchase physical devices. Create as many virtual devices as you need for testing.</p>"},{"location":"guide/#simulate-real-world-conditions","title":"Simulate Real-World Conditions","text":"<ul> <li>Normal operations (power, color, brightness)</li> <li>Network issues (packet loss, delays)</li> <li>Edge cases (malformed packets, invalid data)</li> <li>Error conditions (timeouts, unhandled packets)</li> </ul>"},{"location":"guide/#integrate-with-cicd","title":"Integrate with CI/CD","text":"<p>Run automated tests in continuous integration pipelines without physical device dependencies.</p>"},{"location":"guide/#common-use-cases","title":"Common Use Cases","text":""},{"location":"guide/#testing-your-lifx-library","title":"Testing Your LIFX Library","text":"<p>The emulator allows you to test your LIFX library without physical devices:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def test_my_library():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Test your library here\n        pass\n</code></pre>"},{"location":"guide/#cicd-integration","title":"CI/CD Integration","text":"<p>Run tests in continuous integration pipelines:</p> <pre><code># Start emulator in background\nlifx-emulator --bind 127.0.0.1 --port 56701 &amp;\nEMULATOR_PID=$!\n\n# Run tests\npytest tests/\n\n# Clean up\nkill $EMULATOR_PID\n</code></pre>"},{"location":"guide/#protocol-development","title":"Protocol Development","text":"<p>Experiment with LIFX protocol features:</p> <pre><code># Start with verbose logging to see all packets\nlifx-emulator --verbose\n</code></pre>"},{"location":"guide/#next-steps","title":"Next Steps","text":"<p>Choose a topic from the list above to dive deeper into specific features.</p>"},{"location":"guide/best-practices/","title":"Best Practices","text":"<p>This guide covers best practices for using the LIFX Emulator effectively in your development and testing workflows.</p>"},{"location":"guide/best-practices/#when-to-use-the-emulator","title":"When to Use the Emulator","text":""},{"location":"guide/best-practices/#use-the-emulator-when","title":"\u2705 Use the Emulator When:","text":"<p>1. Developing LIFX Client Libraries - Testing protocol implementation - Verifying packet handling - Testing discovery mechanisms - Validating state management</p> <p>2. Integration Testing - Testing application logic with LIFX devices - Verifying end-to-end workflows - Testing error handling - CI/CD pipeline integration</p> <p>3. Protocol Exploration - Learning the LIFX LAN protocol - Experimenting with different device types - Understanding packet structures - Testing edge cases</p> <p>4. Performance Testing - Load testing with many devices - Concurrent request handling - Network latency simulation - Resource usage profiling</p>"},{"location":"guide/best-practices/#dont-use-the-emulator-when","title":"\u274c Don't Use the Emulator When:","text":"<p>1. Unit Testing Business Logic - Use mocks for faster, isolated tests - Emulator adds unnecessary overhead - Business logic should not depend on protocol details</p> <pre><code># Good: Unit test with mock\nfrom unittest.mock import Mock\n\ndef test_color_converter():\n    mock_device = Mock()\n    mock_device.get_color.return_value = (21845, 65535, 32768, 3500)\n\n    # Test your color conversion logic\n    rgb = convert_hsbk_to_rgb(mock_device.get_color())\n    assert rgb == (0, 255, 128)\n\n# Bad: Unit test with emulator (too slow)\nasync def test_color_converter_slow():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:\n        # Just testing conversion logic doesn't need a full emulator\n        ...\n</code></pre> <p>2. Testing Third-Party Hardware - Emulator can't reproduce hardware-specific bugs - Real devices needed for hardware validation - Firmware behavior may differ</p> <p>3. Testing WiFi/Network Stack - Emulator doesn't simulate WiFi issues - Network stack testing needs real network conditions - Use network simulation tools instead</p>"},{"location":"guide/best-practices/#decision-tree-mock-vs-emulator-vs-real-device","title":"Decision Tree: Mock vs Emulator vs Real Device","text":"<pre><code>Are you testing protocol implementation?\n\u251c\u2500 Yes \u2192 Use Emulator\n\u2514\u2500 No\n    \u251c\u2500 Is this a unit test of business logic?\n    \u2502   \u2514\u2500 Yes \u2192 Use Mock\n    \u2514\u2500 No\n        \u251c\u2500 Do you need to test hardware-specific behavior?\n        \u2502   \u2514\u2500 Yes \u2192 Use Real Device\n        \u2514\u2500 No\n            \u251c\u2500 Is this an integration/E2E test?\n            \u2502   \u2514\u2500 Yes \u2192 Use Emulator\n            \u2514\u2500 No \u2192 Use Mock\n</code></pre>"},{"location":"guide/best-practices/#serial-number-strategies","title":"Serial Number Strategies","text":""},{"location":"guide/best-practices/#consistent-naming-conventions","title":"Consistent Naming Conventions","text":"<p>Use meaningful serial number patterns for easier debugging:</p> <pre><code># Good: Meaningful patterns\nDEVICES = {\n    'living_room': \"d073d5001001\",  # 1001 = living room\n    'bedroom':     \"d073d5001002\",  # 1002 = bedroom\n    'kitchen':     \"d073d5001003\",  # 1003 = kitchen\n}\n\n# Also good: By device type\nDEVICES = {\n    'color_1':     \"d073d5100001\",  # 1xxxxx = color lights\n    'color_2':     \"d073d5100002\",\n    'strip_1':     \"d073d5200001\",  # 2xxxxx = multizone\n    'tile_1':      \"d073d5300001\",  # 3xxxxx = tiles\n}\n</code></pre>"},{"location":"guide/best-practices/#avoid-conflicts","title":"Avoid Conflicts","text":"<p>Ensure serial numbers are unique across your test suite:</p> <pre><code># Bad: Reusing serials in different tests\n# test_colors.py\ndevice = create_color_light(\"d073d5000001\")\n\n# test_power.py\ndevice = create_color_light(\"d073d5000001\")  # Same serial!\n\n# Good: Unique serials\n# test_colors.py\ndevice = create_color_light(\"d073d5010001\")  # 01xxxx = color tests\n\n# test_power.py\ndevice = create_color_light(\"d073d5020001\")  # 02xxxx = power tests\n</code></pre>"},{"location":"guide/best-practices/#use-fixtures-for-serial-generation","title":"Use Fixtures for Serial Generation","text":"<pre><code>import pytest\n\n@pytest.fixture\ndef unique_serial():\n    \"\"\"Generate unique serial numbers.\"\"\"\n    counter = 0\n    def _get_serial(prefix=\"d073d5\"):\n        nonlocal counter\n        counter += 1\n        return f\"{prefix}{counter:06d}\"\n    return _get_serial\n\n@pytest.mark.asyncio\nasync def test_with_unique_serial(unique_serial):\n    device1 = create_color_light(unique_serial())  # d073d5000001\n    device2 = create_color_light(unique_serial())  # d073d5000002\n    # Guaranteed unique\n</code></pre>"},{"location":"guide/best-practices/#port-management","title":"Port Management","text":""},{"location":"guide/best-practices/#dynamic-port-allocation","title":"Dynamic Port Allocation","text":"<p>Always use dynamic ports to avoid conflicts:</p> <pre><code>import socket\n\ndef get_free_port():\n    \"\"\"Get an available port from the OS.\"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        return s.getsockname()[1]\n\n@pytest.fixture\nasync def emulator():\n    \"\"\"Emulator with dynamic port.\"\"\"\n    port = get_free_port()\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server, port\n</code></pre>"},{"location":"guide/best-practices/#port-ranges-for-parallel-tests","title":"Port Ranges for Parallel Tests","text":"<p>When using pytest-xdist:</p> <pre><code>@pytest.fixture\nasync def emulator(worker_id):\n    \"\"\"Port allocation for parallel workers.\"\"\"\n    if worker_id == 'master':\n        port = 56700\n    else:\n        # gw0 -&gt; 56701, gw1 -&gt; 56702, etc.\n        worker_num = int(worker_id.replace('gw', ''))\n        port = 56700 + worker_num + 1\n\n    device = create_color_light(f\"d073d500{worker_num:04d}\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"guide/best-practices/#environment-variable-override","title":"Environment Variable Override","text":"<pre><code>import os\n\n@pytest.fixture\nasync def emulator():\n    \"\"\"Allow port override via environment.\"\"\"\n    port = int(os.getenv('LIFX_EMULATOR_PORT', get_free_port()))\n\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"guide/best-practices/#async-context-manager-patterns","title":"Async Context Manager Patterns","text":""},{"location":"guide/best-practices/#always-use-context-managers","title":"Always Use Context Managers","text":"<pre><code># Good: Context manager ensures cleanup\nasync with server:\n    # Server automatically starts\n    await do_tests()\n# Server automatically stops\n\n# Bad: Manual start/stop\nawait server.start()\ntry:\n    await do_tests()\nfinally:\n    await server.stop()  # Easy to forget!\n</code></pre>"},{"location":"guide/best-practices/#nested-context-managers","title":"Nested Context Managers","text":"<pre><code># Multiple servers\nasync with server1:\n    async with server2:\n        # Both running\n        await test_multi_server()\n# Both stopped\n\n# Or use asynccontextmanager for custom fixtures\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def multi_server_setup():\n    server1 = EmulatedLifxServer([device1], \"127.0.0.1\", 56700)\n    server2 = EmulatedLifxServer([device2], \"127.0.0.1\", 56701)\n\n    async with server1, server2:\n        yield server1, server2\n</code></pre>"},{"location":"guide/best-practices/#timeout-protection","title":"Timeout Protection","text":"<pre><code>import asyncio\n\n@pytest.mark.asyncio\n@pytest.mark.timeout(30)  # Fail if test takes &gt;30s\nasync def test_with_timeout():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Test times out if it hangs\n        await asyncio.wait_for(run_test(), timeout=25)\n</code></pre>"},{"location":"guide/best-practices/#resource-cleanup","title":"Resource Cleanup","text":""},{"location":"guide/best-practices/#explicit-cleanup-in-fixtures","title":"Explicit Cleanup in Fixtures","text":"<pre><code>@pytest.fixture\nasync def emulator():\n    \"\"\"Fixture with explicit cleanup.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        try:\n            yield server\n        finally:\n            # Additional cleanup if needed\n            print(\"Cleaning up...\")\n            # Context manager already stopped server\n</code></pre>"},{"location":"guide/best-practices/#cleanup-even-on-exceptions","title":"Cleanup Even on Exceptions","text":"<pre><code>import pytest\n\n@pytest.fixture\nasync def robust_emulator():\n    \"\"\"Emulator that cleans up even on test failure.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        try:\n            yield server\n        except Exception as e:\n            # Log error but still clean up\n            print(f\"Test failed: {e}\")\n            raise  # Re-raise after logging\n</code></pre>"},{"location":"guide/best-practices/#background-task-management","title":"Background Task Management","text":"<pre><code>import asyncio\n\n@pytest.fixture\nasync def emulator_with_task():\n    \"\"\"Emulator with background task.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Start background task\n        task = asyncio.create_task(monitor_server(server))\n\n        try:\n            yield server\n        finally:\n            # Cancel background task\n            task.cancel()\n            try:\n                await task\n            except asyncio.CancelledError:\n                pass\n</code></pre>"},{"location":"guide/best-practices/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guide/best-practices/#fixture-scoping","title":"Fixture Scoping","text":"<p>Choose appropriate fixture scopes for performance:</p> <pre><code># Fastest: Session scope (one emulator for all tests)\n@pytest.fixture(scope=\"session\")\nasync def shared_emulator():\n    \"\"\"Shared across entire test session.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:\n        yield server\n    # Pros: Very fast, minimal overhead\n    # Cons: Tests may affect each other\n\n# Balanced: Module scope (one per test file)\n@pytest.fixture(scope=\"module\")\nasync def module_emulator():\n    \"\"\"Shared across one test file.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:\n        yield server\n    # Pros: Good isolation, reasonable speed\n    # Cons: Some test coupling within module\n\n# Safest: Function scope (one per test)\n@pytest.fixture(scope=\"function\")\nasync def fresh_emulator():\n    \"\"\"Fresh emulator for each test.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:\n        yield server\n    # Pros: Perfect isolation\n    # Cons: Slowest (startup overhead per test)\n</code></pre>"},{"location":"guide/best-practices/#parallel-test-execution","title":"Parallel Test Execution","text":"<pre><code># Run tests in parallel with pytest-xdist\npytest -n auto  # Use all CPU cores\npytest -n 4     # Use 4 workers\n</code></pre> <pre><code># Ensure tests are parallel-safe\n@pytest.fixture\nasync def parallel_safe_emulator(worker_id):\n    \"\"\"Each worker gets unique port and serial.\"\"\"\n    if worker_id == 'master':\n        port = 56700\n        serial = \"d073d5000001\"\n    else:\n        worker_num = int(worker_id.replace('gw', ''))\n        port = 56700 + worker_num + 1\n        serial = f\"d073d500{worker_num:04d}\"\n\n    device = create_color_light(serial)\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"guide/best-practices/#minimize-device-count","title":"Minimize Device Count","text":"<p>Create only the devices you need:</p> <pre><code># Bad: Creating unnecessary devices\ndevices = [create_color_light(f\"d073d500{i:04d}\") for i in range(100)]\nserver = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n# Only testing with 1 device!\n\n# Good: Create what you need\ndevice = create_color_light(\"d073d5000001\")\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n</code></pre>"},{"location":"guide/best-practices/#test-organization-patterns","title":"Test Organization Patterns","text":""},{"location":"guide/best-practices/#group-related-tests","title":"Group Related Tests","text":"<pre><code># tests/test_colors.py\nclass TestColorOperations:\n    \"\"\"Group color-related tests.\"\"\"\n\n    @pytest.fixture\n    async def color_device(self):\n        device = create_color_light(\"d073d5010001\")\n        server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n        async with server:\n            yield server\n\n    async def test_set_color(self, color_device):\n        ...\n\n    async def test_get_color(self, color_device):\n        ...\n\n# tests/test_power.py\nclass TestPowerOperations:\n    \"\"\"Group power-related tests.\"\"\"\n    ...\n</code></pre>"},{"location":"guide/best-practices/#shared-fixtures-in-conftestpy","title":"Shared Fixtures in conftest.py","text":"<pre><code># tests/conftest.py\nimport pytest\nfrom lifx_emulator import create_color_light, EmulatedLifxServer\n\n@pytest.fixture\nasync def basic_emulator():\n    \"\"\"Reusable basic emulator fixture.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:\n        yield server\n\n@pytest.fixture\nasync def multi_device_emulator():\n    \"\"\"Reusable multi-device fixture.\"\"\"\n    devices = [\n        create_color_light(f\"d073d500{i:04d}\")\n        for i in range(1, 4)\n    ]\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n    async with server:\n        yield server\n</code></pre>"},{"location":"guide/best-practices/#parametrized-device-tests","title":"Parametrized Device Tests","text":"<pre><code>import pytest\nfrom lifx_emulator import (\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\n\n@pytest.fixture(params=[\n    (\"color\", create_color_light),\n    (\"multizone\", lambda s: create_multizone_light(s, zone_count=16)),\n    (\"tile\", lambda s: create_tile_device(s, tile_count=5)),\n])\nasync def any_device_type(request):\n    \"\"\"Test against all device types.\"\"\"\n    device_type, factory = request.param\n    device = factory(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server, device_type\n\nasync def test_basic_operations(any_device_type):\n    \"\"\"Test runs 3 times (once per device type).\"\"\"\n    server, device_type = any_device_type\n    print(f\"Testing {device_type}\")\n    # Test common operations...\n</code></pre>"},{"location":"guide/best-practices/#debugging-tips","title":"Debugging Tips","text":""},{"location":"guide/best-practices/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<pre><code>import logging\n\n# At top of test file or conftest.py\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n\n# Or for specific module\nlogging.getLogger('lifx_emulator').setLevel(logging.DEBUG)\n</code></pre>"},{"location":"guide/best-practices/#add-print-debugging","title":"Add Print Debugging","text":"<pre><code>async def test_with_debugging():\n    device = create_color_light(\"d073d5000001\")\n\n    # Check initial state\n    print(f\"Initial state: {device.state}\")\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Server started on port {server.port}\")\n        print(f\"Devices: {[d.state.serial for d in server.devices]}\")\n\n        # Your test here\n        ...\n\n        print(f\"Final state: {device.state}\")\n</code></pre>"},{"location":"guide/best-practices/#use-pytest-v-and-s-flags","title":"Use pytest -v and -s Flags","text":"<pre><code># Verbose output + show print statements\npytest tests/ -v -s\n\n# Even more verbose\npytest tests/ -vv -s\n\n# Show locals on failure\npytest tests/ -l\n</code></pre>"},{"location":"guide/best-practices/#capture-state-on-failure","title":"Capture State on Failure","text":"<pre><code>@pytest.fixture\nasync def emulator_with_state_capture():\n    \"\"\"Capture state on test failure.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        try:\n            yield server\n        except Exception:\n            # Capture state before cleanup\n            print(f\"\\nDevice state at failure:\")\n            print(f\"  Serial: {device.state.serial}\")\n            print(f\"  Label: {device.state.label}\")\n            print(f\"  Power: {device.state.power}\")\n            print(f\"  Color: {device.state.color}\")\n            raise\n</code></pre>"},{"location":"guide/best-practices/#common-pitfalls","title":"Common Pitfalls","text":""},{"location":"guide/best-practices/#pitfall-1-forgetting-await","title":"\u274c Pitfall 1: Forgetting await","text":"<pre><code># Bad: Forgot await\nasync def test_bad():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    server.start()  # Returns coroutine, not called!\n\n# Good: Using await\nasync def test_good():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:  # Properly awaits start/stop\n        ...\n</code></pre>"},{"location":"guide/best-practices/#pitfall-2-port-conflicts","title":"\u274c Pitfall 2: Port Conflicts","text":"<pre><code># Bad: Hard-coded port (conflicts in parallel tests)\nport = 56700\n\n# Good: Dynamic port\nport = get_free_port()\n\n# Better: Let fixture handle it\n@pytest.fixture\nasync def emulator():\n    port = get_free_port()\n    ...\n</code></pre>"},{"location":"guide/best-practices/#pitfall-3-shared-mutable-state","title":"\u274c Pitfall 3: Shared Mutable State","text":"<pre><code># Bad: Shared device across tests\nGLOBAL_DEVICE = create_color_light(\"d073d5000001\")\n\ndef test_1():\n    GLOBAL_DEVICE.state.power = 0  # Modifies global state!\n\ndef test_2():\n    assert GLOBAL_DEVICE.state.power == 65535  # Fails!\n\n# Good: Fresh device per test\n@pytest.fixture\nasync def device():\n    return create_color_light(\"d073d5000001\")\n</code></pre>"},{"location":"guide/best-practices/#pitfall-4-not-cleaning-up","title":"\u274c Pitfall 4: Not Cleaning Up","text":"<pre><code># Bad: Manual cleanup can be missed\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\nawait server.start()\n# If error occurs here, server never stops!\nawait run_test()\nawait server.stop()\n\n# Good: Context manager guarantees cleanup\nasync with server:\n    await run_test()\n# Always stops, even on error\n</code></pre>"},{"location":"guide/best-practices/#pitfall-5-ignoring-async-event-loop","title":"\u274c Pitfall 5: Ignoring Async Event Loop","text":"<pre><code># Bad: Wrong event loop policy on Windows\n# May cause issues with asyncio on Windows\n\n# Good: Set policy in conftest.py\nimport sys\nimport pytest\n\nif sys.platform == 'win32':\n    import asyncio\n    asyncio.set_event_loop_policy(\n        asyncio.WindowsProactorEventLoopPolicy()\n    )\n</code></pre>"},{"location":"guide/best-practices/#checklist-for-new-tests","title":"Checklist for New Tests","text":"<p>Before writing a new test, ask:</p> <ul> <li> Do I need the full emulator, or would a mock suffice?</li> <li> What fixture scope is appropriate (function/module/session)?</li> <li> Am I using dynamic port allocation?</li> <li> Are my serial numbers unique and meaningful?</li> <li> Am I using context managers for cleanup?</li> <li> Have I added appropriate timeouts?</li> <li> Can this test run in parallel with others?</li> <li> Did I test the test? (Run it locally first)</li> </ul>"},{"location":"guide/best-practices/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Scenarios - Error injection patterns</li> <li>Integration Testing - pytest integration</li> <li>Advanced Examples - Complex scenarios</li> <li>CI/CD Integration - Running in CI</li> </ul>"},{"location":"guide/best-practices/#see-also","title":"See Also","text":"<ul> <li>pytest Best Practices</li> <li>pytest-asyncio Documentation</li> <li>API Reference: Server</li> <li>API Reference: Device</li> </ul>"},{"location":"guide/device-types/","title":"Device Types","text":"<p>Complete guide to all supported LIFX device types and their capabilities.</p>"},{"location":"guide/device-types/#overview","title":"Overview","text":"<p>The LIFX Emulator supports all major LIFX device types, each with specific capabilities and features.</p>"},{"location":"guide/device-types/#color-lights","title":"Color Lights","text":"<p>Full RGB color lights with complete color control.</p>"},{"location":"guide/device-types/#example-products","title":"Example Products","text":"<ul> <li>LIFX A19 (product ID 27) - Standard color bulb</li> <li>LIFX BR30 (product ID 43) - BR30 flood light</li> <li>LIFX Downlight (product ID 36) - Recessed downlight</li> <li>LIFX GU10 (product ID 66) - GU10 spot light</li> <li>And many more...</li> </ul>"},{"location":"guide/device-types/#capabilities","title":"Capabilities","text":"<ul> <li>Full RGBW color (360\u00b0 hue, 0-100% saturation)</li> <li>Brightness control (0-100%)</li> <li>Color temperature (1500K-9000K)</li> <li>Power on/off</li> </ul>"},{"location":"guide/device-types/#creating-color-lights","title":"Creating Color Lights","text":"CLIPython LibraryREST API <pre><code># Create a single color light\nlifx-emulator --color 1\n\n# Create multiple color lights\nlifx-emulator --color 3\n\n# Create by specific product ID\nlifx-emulator --product 27  # LIFX A19\nlifx-emulator --product 43  # LIFX BR30\n</code></pre> <pre><code>from lifx_emulator import create_color_light\n\ndevice = create_color_light(\"d073d5000001\")\n</code></pre> <pre><code># With API server enabled (lifx-emulator --api)\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 27}'\n</code></pre>"},{"location":"guide/device-types/#example-usage","title":"Example Usage","text":"CLIPython Library <pre><code># Start emulator with verbose output to see state\nlifx-emulator --color 1 --verbose\n</code></pre> <pre><code># Create and start server\ndevice = create_color_light(\"d073d5000001\")\ndevice_manager = DeviceManager(DeviceRepository())\nserver = EmulatedLifxServer([device], device_manager, \"127.0.0.1\", 56700)\nawait server.start()\n\n# Check state\nprint(f\"Has color: {device.state.has_color}\")  # True\nprint(f\"Color: {device.state.color}\")\n</code></pre>"},{"location":"guide/device-types/#color-temperature-lights","title":"Color Temperature Lights","text":"<p>White lights with variable color temperature (warm to cool white).</p>"},{"location":"guide/device-types/#example-products_1","title":"Example Products","text":"<ul> <li>LIFX Mini White to Warm (product ID 50)</li> <li>LIFX Downlight White to Warm (product ID 48)</li> </ul>"},{"location":"guide/device-types/#capabilities_1","title":"Capabilities","text":"<ul> <li>Color temperature adjustment (1500K-9000K)</li> <li>Brightness control (0-100%)</li> <li>Power on/off</li> <li>No RGB color (saturation locked to 0)</li> </ul>"},{"location":"guide/device-types/#creating-color-temperature-lights","title":"Creating Color Temperature Lights","text":"CLIPython LibraryREST API <pre><code># Create color temperature lights\nlifx-emulator --color-temperature 1\n\n# Create by specific product ID\nlifx-emulator --product 50  # LIFX Mini White to Warm\n</code></pre> <pre><code>from lifx_emulator import create_color_temperature_light\n\ndevice = create_color_temperature_light(\"d073d5000007\")\n</code></pre> <pre><code>curl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 50}'\n</code></pre>"},{"location":"guide/device-types/#behavior","title":"Behavior","text":"<p>These devices:</p> <ul> <li>Always report <code>has_color=False</code></li> <li>Reject color commands (SetColor with saturation &gt; 0)</li> <li>Accept color temperature changes via kelvin value</li> <li>Only vary brightness and temperature</li> </ul>"},{"location":"guide/device-types/#infrared-lights","title":"Infrared Lights","text":"<p>Color lights with additional infrared capability for night vision.</p>"},{"location":"guide/device-types/#example-products_2","title":"Example Products","text":"<ul> <li>LIFX A19 Night Vision (product ID 29)</li> <li>LIFX BR30 Night Vision (product ID 44)</li> </ul>"},{"location":"guide/device-types/#capabilities_2","title":"Capabilities","text":"<ul> <li>Full RGBW color</li> <li>Brightness control</li> <li>Color temperature</li> <li>Infrared brightness (0-100%)</li> <li>Power on/off</li> </ul>"},{"location":"guide/device-types/#creating-infrared-lights","title":"Creating Infrared Lights","text":"CLIPython LibraryREST API <pre><code># Create infrared lights\nlifx-emulator --infrared 1\n\n# Create by specific product ID\nlifx-emulator --product 29  # LIFX A19 Night Vision\n</code></pre> <pre><code>from lifx_emulator import create_infrared_light\n\ndevice = create_infrared_light(\"d073d5000002\")\n</code></pre> <pre><code>curl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 29}'\n</code></pre>"},{"location":"guide/device-types/#infrared-control","title":"Infrared Control","text":"<pre><code>device = create_infrared_light(\"d073d5000002\")\n\n# Check infrared support\nprint(f\"Has IR: {device.state.has_infrared}\")  # True\n\n# Default IR brightness (set to 25%)\nprint(f\"IR brightness: {device.state.infrared_brightness}\")  # 16384\n\n# After receiving LightSetInfrared command\n# device.state.infrared_brightness will be updated\n</code></pre>"},{"location":"guide/device-types/#packet-types","title":"Packet Types","text":"<ul> <li><code>LightGetInfrared</code> (120)</li> <li><code>LightStateInfrared</code> (121)</li> <li><code>LightSetInfrared</code> (122)</li> </ul>"},{"location":"guide/device-types/#hev-lights","title":"HEV Lights","text":"<p>Lights with HEV (High Energy Visible) anti-bacterial cleaning capability.</p>"},{"location":"guide/device-types/#example-products_3","title":"Example Products","text":"<ul> <li>LIFX Clean (product ID 90)</li> </ul>"},{"location":"guide/device-types/#capabilities_3","title":"Capabilities","text":"<ul> <li>Full RGBW color</li> <li>Brightness control</li> <li>Color temperature</li> <li>HEV cleaning cycle (anti-bacterial sanitization)</li> <li>Cycle duration configuration</li> <li>Cycle progress tracking</li> <li>Power on/off</li> </ul>"},{"location":"guide/device-types/#creating-hev-lights","title":"Creating HEV Lights","text":"CLIPython LibraryREST API <pre><code># Create HEV lights\nlifx-emulator --hev 1\n\n# Create by specific product ID\nlifx-emulator --product 90  # LIFX Clean\n</code></pre> <pre><code>from lifx_emulator import create_hev_light\n\ndevice = create_hev_light(\"d073d5000003\")\n</code></pre> <pre><code>curl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 90}'\n</code></pre>"},{"location":"guide/device-types/#hev-state","title":"HEV State","text":"<pre><code>device = create_hev_light(\"d073d5000003\")\n\n# HEV defaults\nprint(f\"Has HEV: {device.state.has_hev}\")  # True\nprint(f\"Cycle duration: {device.state.hev_cycle_duration_s}\")  # 7200 (2 hours)\nprint(f\"Remaining: {device.state.hev_cycle_remaining_s}\")  # 0 (not running)\nprint(f\"Indication: {device.state.hev_indication}\")  # True\n</code></pre>"},{"location":"guide/device-types/#hev-packet-types","title":"HEV Packet Types","text":"<ul> <li><code>HevGet</code> (143)</li> <li><code>HevStateResult</code> (144)</li> <li><code>HevGetResult</code> (145)</li> <li><code>HevStateResult</code> (146)</li> <li><code>HevSetConfig</code> (147)</li> <li><code>HevGetConfig</code> (148)</li> <li><code>HevStateConfig</code> (149)</li> </ul>"},{"location":"guide/device-types/#multizone-devices","title":"Multizone Devices","text":"<p>Linear light strips with independently controllable zones.</p>"},{"location":"guide/device-types/#example-products_4","title":"Example Products","text":"<ul> <li>LIFX Z (product ID 32) - Default 16 zones (8 zones/strip)</li> <li>LIFX Beam (product ID 38) - Default 80 zones (10 zones/beam)</li> <li>LIFX Neon (product ID 141) - Default 24 zones (24 zones/segment)</li> <li>LIFX String (product ID 143) - Default 36 zones (36 zones/string)</li> <li>LIFX Permanent Outdoor (product ID 213) - Default 30 zones (15 zones/segment)</li> </ul>"},{"location":"guide/device-types/#capabilities_4","title":"Capabilities","text":"<ul> <li>Full RGBW color per zone</li> <li>Per-zone brightness and color</li> <li>Multizone effect (MOVE)</li> <li>Power on/off</li> </ul>"},{"location":"guide/device-types/#creating-multizone-devices","title":"Creating Multizone Devices","text":"CLIPython LibraryREST API <pre><code># Standard LIFX Z with default 16 zones\nlifx-emulator --multizone 1\n\n# Multiple multizone devices with custom zone count\nlifx-emulator --multizone 2 --multizone-zones 24\n\n# Extended multizone (LIFX Beam) with default 80 zones\nlifx-emulator --multizone 1 --multizone-extended\n\n# Non-extended multizone\nlifx-emulator --multizone 1 --no-multizone-extended\n\n# Create by specific product ID\nlifx-emulator --product 32  # LIFX Z\nlifx-emulator --product 38  # LIFX Beam\n</code></pre> <pre><code>from lifx_emulator import create_multizone_light\n\n# Standard LIFX Z with default 16 zones\nstrip = create_multizone_light(\"d073d8000001\")\n\n# Custom zone count\nstrip = create_multizone_light(\"d073d8000002\", zone_count=24)\n\n# Extended multizone (LIFX Beam) with default 80 zones\nbeam = create_multizone_light(\"d073d8000003\", extended_multizone=True)\n\n# Extended with custom zone count\nbeam = create_multizone_light(\"d073d8000004\", zone_count=60, extended_multizone=True)\n</code></pre> <pre><code># Standard multizone\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 32, \"zone_count\": 16}'\n\n# Extended multizone with custom zones\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 38, \"zone_count\": 80}'\n</code></pre>"},{"location":"guide/device-types/#zone-management","title":"Zone Management","text":"<pre><code>strip = create_multizone_light(\"d073d8000001\", zone_count=16)\n\n# Check configuration\nprint(f\"Has multizone: {device.state.has_multizone}\")  # True\nprint(f\"Zone count: {device.state.zone_count}\")  # 16\nprint(f\"Product: {device.state.product}\")  # 32 (LIFX Z)\n\n# Access zone colors\nfor i, color in enumerate(device.state.zone_colors):\n    print(f\"Zone {i}: {color}\")\n</code></pre>"},{"location":"guide/device-types/#multizone-packet-types","title":"Multizone Packet Types","text":"<p>Standard (all multizone devices): - <code>SetColorZones</code> (501) - <code>GetColorZones</code> (502) - <code>StateZone</code> (503) - <code>StateMultiZone</code> (506)</p> <p>Extended (extended multizone only): - <code>SetExtendedColorZones</code> (510) - <code>GetExtendedColorZones</code> (511) - <code>StateExtendedColorZones</code> (512)</p> <p>Effects: - <code>SetMultiZoneEffect</code> (509) - <code>GetMultiZoneEffect</code> (507) - <code>StateMultiZoneEffect</code> (508)</p>"},{"location":"guide/device-types/#matrix-devices","title":"Matrix Devices","text":"<p>Devices with a 2D matrix of individually controlled zones.</p>"},{"location":"guide/device-types/#example-products_5","title":"Example Products","text":"<ul> <li>LIFX Tile (product ID 55) - 8x8 tile with up to 5 tiles per chain (discontinued)</li> <li>LIFX Candle (product ID 57, 68, 137, 138, 185, 186, 215, 216) - 6x5 tile</li> <li>LIFX Ceiling (product ID 176) - 8x8 with uplight/downlight zones</li> <li>LIFX Ceiling 13x26\" (product ID 201, 202) - 16x8 with uplight/downlight zones</li> <li>LIFX Tube (product ID 177, 217, 218) - 5x11</li> <li>LIFX Luna (product ID 219, 220) - 7x5</li> <li>LIFX Round Spot (product ID 171, 221) - 3x1</li> <li>LIFX Round/Square Path (product ID 173, 174, 222) - 3x2</li> </ul>"},{"location":"guide/device-types/#capabilities_5","title":"Capabilities","text":"<ul> <li>2D matrix of individually controlled full color zones</li> <li>Multiple tiles in a chain (original Tile only)</li> <li>Tile positioning in 2D space (original Tile only)</li> <li>Matrix effects (Morph, Flame, Sky)</li> <li>Power on/off</li> </ul>"},{"location":"guide/device-types/#creating-matrix-devices","title":"Creating Matrix Devices","text":"CLIPython LibraryREST API <pre><code># Standard LIFX Tile (8x8) with default 5 tiles\nlifx-emulator --tile 1\n\n# Multiple tile devices with custom tile count\nlifx-emulator --tile 2 --tile-count 3\n\n# Custom tile dimensions\nlifx-emulator --tile 1 --tile-width 16 --tile-height 8\n\n# Create by specific product ID\nlifx-emulator --product 55   # LIFX Tile\nlifx-emulator --product 57   # LIFX Candle\nlifx-emulator --product 176  # LIFX Ceiling\n</code></pre> <pre><code>from lifx_emulator import create_tile_device\n\n# Standard LIFX Tile (8x8) with default 5 tiles\ntiles = create_tile_device(\"d073d9000001\")\n\n# Custom tile count\ntiles = create_tile_device(\"d073d9000002\", tile_count=10)\n\n# Custom tile dimensions (e.g., 16x8 with &gt;64 zones)\nlarge_tile = create_tile_device(\"d073dc000001\", tile_count=1, tile_width=16, tile_height=8)\n\n# Any custom size\ncustom = create_tile_device(\"d073dc000002\", tile_count=3, tile_width=12, tile_height=12)\n</code></pre> <pre><code># Standard tile\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 55, \"tile_count\": 5}'\n\n# Custom dimensions\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 55, \"tile_count\": 1, \"tile_width\": 16, \"tile_height\": 8}'\n</code></pre>"},{"location":"guide/device-types/#matrix-configuration","title":"Matrix Configuration","text":"<pre><code>tiles = create_tile_device(\"d073d9000001\", tile_count=5)\n\n# Check configuration\nprint(f\"Has matrix: {device.state.has_matrix}\")  # True\nprint(f\"Tile count: {device.state.tile_count}\")  # 5\nprint(f\"Tile width: {device.state.tile_width}\")  # 8\nprint(f\"Tile height: {device.state.tile_height}\")  # 8\n\n# Access tile devices\nfor i, tile in enumerate(device.state.tile_devices):\n    print(f\"Tile {i}: {tile.width}x{tile.height} zones\")\n</code></pre>"},{"location":"guide/device-types/#matrix-packet-types","title":"Matrix Packet Types","text":"<ul> <li><code>GetDeviceChain</code> (701)</li> <li><code>StateDeviceChain</code> (702)</li> <li><code>SetUserPosition</code> (703)</li> <li><code>GetTileState64</code> (707)</li> <li><code>StateTileState64</code> (711)</li> <li><code>SetTileState64</code> (715)</li> <li><code>GetTileEffect</code> (718)</li> <li><code>StateTileEffect</code> (719)</li> </ul>"},{"location":"guide/device-types/#zone-access","title":"Zone Access","text":"<p>Matrix devices usually have up to 64 zones per tile with a single tile per chain.</p> <p>Exceptions include the LIFX Tile that supports up to 5 tiles per chain and the new LIFX Ceiling 26\"x13\" which has 128 zones on a single tile.</p> <pre><code># Get64 requests specify a rectangle of zones\n# x, y, width specify which zones to retrieve\n# State64 responses contain up to 64 zones\n\n# Large tiles (16x8) require multiple Get64 requests\n# split either by row or column.\n</code></pre>"},{"location":"guide/device-types/#framebuffers-v23","title":"Framebuffers (v2.3+)","text":"<p>Matrix devices support 8 framebuffers (0-7) to enable atomic updates of tiles with more than 64 zones:</p> <ul> <li>Framebuffer 0: Visible buffer (displayed on device)</li> <li>Framebuffers 1-7: Non-visible buffers for preparing content off-screen</li> </ul> <p>For large tiles (&gt;64 zones), prepare all zones in a non-visible framebuffer, then use <code>CopyFrameBuffer</code> to atomically display them without flicker.</p> <p>See Framebuffer Guide for complete documentation and examples.</p>"},{"location":"guide/device-types/#switch-devices","title":"Switch Devices","text":"<p>LIFX Switch devices are relay-based switches with no lighting capabilities. They respond with <code>StateUnhandled</code> (packet 223) to all lighting-related protocol requests.</p>"},{"location":"guide/device-types/#example-products_6","title":"Example Products","text":"<ul> <li>LIFX Switch (product IDs 70, 71, 89, 115, 116) - 2 relay switches</li> </ul>"},{"location":"guide/device-types/#capabilities_6","title":"Capabilities","text":"<ul> <li>Relays: Physical relay switches for controlling external loads</li> <li>Buttons: Physical buttons for manual control</li> <li>No lighting: No color, brightness, or zone control</li> <li>Basic device operations (GetVersion, GetLabel, EchoRequest, etc.)</li> </ul>"},{"location":"guide/device-types/#creating-switch-devices","title":"Creating Switch Devices","text":"CLIPython LibraryREST API <pre><code># Create LIFX Switch devices\nlifx-emulator --switch 1\n\n# Create by specific product ID\nlifx-emulator --product 70  # LIFX Switch\nlifx-emulator --product 89  # LIFX Switch variant\n</code></pre> <pre><code>from lifx_emulator import create_switch\n\n# Create LIFX Switch (default product 70)\nswitch = create_switch(\"d073d7000001\")\n\n# Or specify a different switch product\nswitch = create_switch(\"d073d7000002\", product_id=89)\n</code></pre> <pre><code>curl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 70}'\n</code></pre>"},{"location":"guide/device-types/#switch-behavior","title":"Switch Behavior","text":"<pre><code>switch = create_switch(\"d073d7000001\")\n\n# Check capabilities\nprint(f\"Has relays: {switch.state.has_relays}\")  # True\nprint(f\"Has buttons: {switch.state.has_buttons}\")  # True\nprint(f\"Has color: {switch.state.has_color}\")  # False\nprint(f\"Has multizone: {switch.state.has_multizone}\")  # False\n</code></pre>"},{"location":"guide/device-types/#packet-handling","title":"Packet Handling","text":"<p>Supported (Device.* packets 2-59): - <code>GetVersion</code> (32) \u2192 <code>StateVersion</code> (33) - <code>GetLabel</code> (23) \u2192 <code>StateLabel</code> (25) - <code>SetLabel</code> (24) - <code>EchoRequest</code> (58) \u2192 <code>EchoResponse</code> (59) - All other Device.* packets</p> <p>Rejected with StateUnhandled (223): - Light.* packets (101-149): GetColor, SetColor, GetPower, SetPower, etc. - MultiZone.* packets (501-512): GetColorZones, SetColorZones, etc. - Tile.* packets (701-720): Get64, Set64, GetTileEffect, etc.</p>"},{"location":"guide/device-types/#stateunhandled-response","title":"StateUnhandled Response","text":"<p>When a switch receives an unsupported packet type, it responds with:</p> <pre><code># Client sends Light.GetColor (101) to switch\n# Switch responds with:\n# - StateUnhandled (223) with unhandled_type=101\n# - Acknowledgement (45) if ack_required=True\n</code></pre> <p>The <code>StateUnhandled</code> packet includes the rejected packet type in the <code>unhandled_type</code> field, allowing clients to detect and handle unsupported operations gracefully.</p>"},{"location":"guide/device-types/#limitations","title":"Limitations","text":"<p>Note: Button and relay control protocol packets are not currently implemented in the emulator.</p> <p>The switch emulation is primarily for testing client libraries' handling of: - Device capability detection - StateUnhandled response handling - Graceful degradation when lighting features are unavailable</p>"},{"location":"guide/device-types/#using-generic-create_device","title":"Using Generic create_device()","text":"<p>All factory functions use <code>create_device()</code> internally. You can use it directly:</p> CLIPython LibraryREST API <pre><code># Create any device by product ID\nlifx-emulator --product 27   # LIFX A19\nlifx-emulator --product 32   # LIFX Z\nlifx-emulator --product 55   # LIFX Tile\nlifx-emulator --product 57   # LIFX Candle\n\n# Mix multiple products\nlifx-emulator --product 27 --product 32 --product 55\n</code></pre> <pre><code>from lifx_emulator.factories import create_device\n\n# Create by product ID\na19 = create_device(27, serial=\"d073d5000001\")\nz_strip = create_device(32, serial=\"d073d8000001\", zone_count=16)\ntiles = create_device(55, serial=\"d073d9000001\", tile_count=5)\ncandle = create_device(57, serial=\"d073d9000002\")\n\n# Product defaults are automatically loaded\nprint(f\"Candle size: {candle.state.tile_width}x{candle.state.tile_height}\")  # 5x6\n</code></pre> <pre><code># Create any device by product ID\ncurl -X POST http://localhost:8080/api/devices \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"product_id\": 57}'  # LIFX Candle\n</code></pre>"},{"location":"guide/device-types/#next-steps","title":"Next Steps","text":"<ul> <li>Testing Scenarios - Configure error scenarios</li> <li>Integration Testing - Use in tests</li> <li>Factory Functions API - Detailed API docs</li> <li>Product Registry - All products</li> </ul>"},{"location":"guide/framebuffers/","title":"Matrix Framebuffer Support","text":"<p>Matrix devices with more than 64 zones require multiple Set64 packets to update all zones. Framebuffers enable atomic updates by allowing you to prepare all zones off-screen before displaying them.</p>"},{"location":"guide/framebuffers/#overview","title":"Overview","text":"<p>Matrix devices support 8 framebuffers (0-7):</p> <ul> <li>Framebuffer 0: The visible buffer displayed on the device</li> <li>Framebuffers 1-7: Non-visible buffers for preparing content</li> </ul>"},{"location":"guide/framebuffers/#why-framebuffers-matter","title":"Why Framebuffers Matter","text":"<p>For large tiles (&gt;64 zones), such as the LIFX Ceiling 13\"x26\" with 128 zones (16\u00d78):</p> <p>Without framebuffers: <pre><code>Set64(fb=0, zones 0-63)   \u2192 Visible immediately (partial update)\nSet64(fb=0, zones 64-127) \u2192 Visible immediately (flicker as zones update)\n</code></pre></p> <p>With framebuffers: <pre><code>Set64(fb=1, zones 0-63)      \u2192 Prepared off-screen\nSet64(fb=1, zones 64-127)    \u2192 Prepared off-screen\nCopyFrameBuffer(fb=1 \u2192 fb=0) \u2192 All 128 zones appear atomically\n</code></pre></p>"},{"location":"guide/framebuffers/#framebuffer-operations","title":"Framebuffer Operations","text":""},{"location":"guide/framebuffers/#set64-update-zones","title":"Set64 - Update Zones","text":"<p>The <code>rect.fb_index</code> field specifies which framebuffer to update:</p> <pre><code>from lifx_emulator.protocol.packets import Tile\nfrom lifx_emulator.protocol.protocol_types import TileBufferRect, LightHsbk\n\n# Update visible framebuffer (immediate display)\nrect = TileBufferRect(fb_index=0, x=0, y=0, width=8)\npacket = Tile.Set64(\n    tile_index=0,\n    rect=rect,\n    duration=0,\n    colors=[...64 colors...]\n)\n\n# Update non-visible framebuffer 1 (off-screen)\nrect = TileBufferRect(fb_index=1, x=0, y=0, width=8)\npacket = Tile.Set64(\n    tile_index=0,\n    rect=rect,\n    duration=0,\n    colors=[...64 colors...]\n)\n</code></pre>"},{"location":"guide/framebuffers/#get64-read-zones","title":"Get64 - Read Zones","text":"<p>Get64 always returns framebuffer 0 (the visible buffer), regardless of the <code>fb_index</code> in the request:</p> <pre><code># Request can specify any fb_index\nrect = TileBufferRect(fb_index=1, x=0, y=0, width=8)\npacket = Tile.Get64(tile_index=0, rect=rect)\n\n# Response will contain framebuffer 0 content\n# Response rect.fb_index is always 0\n</code></pre>"},{"location":"guide/framebuffers/#copyframebuffer-atomic-display","title":"CopyFrameBuffer - Atomic Display","text":"<p>Copy zones between framebuffers to make prepared content visible:</p> <pre><code># Copy entire framebuffer 1 to framebuffer 0 (make visible)\npacket = Tile.CopyFrameBuffer(\n    tile_index=0,\n    src_fb_index=1,\n    dst_fb_index=0,\n    src_x=0,\n    src_y=0,\n    dst_x=0,\n    dst_y=0,\n    width=16,\n    height=8,\n    duration=0\n)\n</code></pre>"},{"location":"guide/framebuffers/#complete-example-updating-a-168-tile","title":"Complete Example: Updating a 16\u00d78 Tile","text":"<pre><code>from lifx_emulator import create_tile_device\nfrom lifx_emulator.protocol.packets import Tile\nfrom lifx_emulator.protocol.protocol_types import TileBufferRect, LightHsbk\n\n# Create 16\u00d78 tile (128 zones)\ndevice = create_tile_device(\n    serial=\"d073dc000001\",\n    tile_count=1,\n    tile_width=16,\n    tile_height=8\n)\n\n# Prepare colors for all 128 zones\nred = LightHsbk(hue=0, saturation=65535, brightness=65535, kelvin=3500)\ngreen = LightHsbk(hue=21845, saturation=65535, brightness=65535, kelvin=3500)\n\n# Step 1: Update first 64 zones in framebuffer 1 (rows 0-3)\nrect1 = TileBufferRect(fb_index=1, x=0, y=0, width=16)\nset1 = Tile.Set64(\n    tile_index=0,\n    rect=rect1,\n    duration=0,\n    colors=[red] * 64\n)\ndevice.process_packet(header, set1)\n\n# Step 2: Update next 64 zones in framebuffer 1 (rows 4-7)\nrect2 = TileBufferRect(fb_index=1, x=0, y=4, width=16)\nset2 = Tile.Set64(\n    tile_index=0,\n    rect=rect2,\n    duration=0,\n    colors=[green] * 64\n)\ndevice.process_packet(header, set2)\n\n# Step 3: Atomically display all 128 zones\ncopy = Tile.CopyFrameBuffer(\n    tile_index=0,\n    src_fb_index=1,\n    dst_fb_index=0,\n    src_x=0,\n    src_y=0,\n    dst_x=0,\n    dst_y=0,\n    width=16,\n    height=8,\n    duration=0\n)\ndevice.process_packet(header, copy)\n\n# All 128 zones now visible without flicker\n</code></pre>"},{"location":"guide/framebuffers/#implementation-details","title":"Implementation Details","text":""},{"location":"guide/framebuffers/#storage","title":"Storage","text":"<ul> <li>Framebuffer 0: Stored in <code>tile_devices[i][\"colors\"]</code> (protocol-defined)</li> <li>Framebuffers 1-7: Stored in <code>MatrixState.tile_framebuffers</code> (internal)</li> </ul>"},{"location":"guide/framebuffers/#lazy-initialization","title":"Lazy Initialization","text":"<p>Non-visible framebuffers are created on first access:</p> <pre><code># First Set64 to framebuffer 2 creates it automatically\n# Initialized with black (hue=0, saturation=0, brightness=0)\n</code></pre>"},{"location":"guide/framebuffers/#persistence","title":"Persistence","text":"<p>Non-visible framebuffers are saved with device state when persistence is enabled:</p> <pre><code>lifx-emulator --persistent --tile 1\n</code></pre>"},{"location":"guide/framebuffers/#best-practices","title":"Best Practices","text":""},{"location":"guide/framebuffers/#for-tiles-64-zones","title":"For Tiles \u226464 Zones","text":"<p>Update framebuffer 0 directly (no need for off-screen preparation):</p> <pre><code>rect = TileBufferRect(fb_index=0, x=0, y=0, width=8)\n</code></pre>"},{"location":"guide/framebuffers/#for-tiles-64-zones_1","title":"For Tiles &gt;64 Zones","text":"<p>Always use a non-visible framebuffer:</p> <ol> <li>Prepare all zones in framebuffer 1-7</li> <li>Use CopyFrameBuffer to make visible</li> <li>Prevents flicker during multi-packet updates</li> </ol>"},{"location":"guide/framebuffers/#partial-updates","title":"Partial Updates","text":"<p>Use CopyFrameBuffer with specific rectangles:</p> <pre><code># Copy only top-left 4\u00d74 area\ncopy = Tile.CopyFrameBuffer(\n    src_fb_index=1,\n    dst_fb_index=0,\n    src_x=0,\n    src_y=0,\n    dst_x=0,\n    dst_y=0,\n    width=4,\n    height=4,\n    duration=0\n)\n</code></pre>"},{"location":"guide/framebuffers/#related-documentation","title":"Related Documentation","text":"<ul> <li>Device Types - Matrix device capabilities</li> <li>Protocol - LIFX LAN protocol details</li> </ul>"},{"location":"guide/integration-testing/","title":"Integration Testing Guide","text":"<p>This comprehensive guide covers how to integrate the LIFX Emulator into your testing workflow using pytest and pytest-asyncio.</p>"},{"location":"guide/integration-testing/#overview","title":"Overview","text":"<p>Integration testing with the emulator allows you to test your LIFX client code against real protocol implementations without needing physical devices. This guide covers pytest patterns, fixture design, CI/CD integration, and best practices.</p>"},{"location":"guide/integration-testing/#quick-start","title":"Quick Start","text":""},{"location":"guide/integration-testing/#install-testing-dependencies","title":"Install Testing Dependencies","text":"<pre><code># Core testing tools\npip install pytest pytest-asyncio\n\n# Optional: Parallel testing\npip install pytest-xdist\n\n# Optional: Coverage reporting\npip install pytest-cov\n\n# Optional: Timeout handling\npip install pytest-timeout\n</code></pre>"},{"location":"guide/integration-testing/#basic-test-setup","title":"Basic Test Setup","text":"<pre><code># test_basic.py\nimport pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def emulator():\n    \"\"\"Basic emulator fixture.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_device_creation(emulator):\n    \"\"\"Test device is created correctly.\"\"\"\n    assert len(emulator.devices) == 1\n    assert emulator.devices[0].state.serial == \"d073d5000001\"\n</code></pre> <p>Run tests:</p> <pre><code>pytest test_basic.py -v\n</code></pre>"},{"location":"guide/integration-testing/#pytest-fixture-patterns","title":"pytest Fixture Patterns","text":""},{"location":"guide/integration-testing/#function-scoped-fixtures-default","title":"Function-Scoped Fixtures (Default)","text":"<p>Fresh emulator for each test - safest but slowest:</p> <pre><code>@pytest.fixture(scope=\"function\")\nasync def fresh_emulator():\n    \"\"\"New emulator for each test.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_one(fresh_emulator):\n    \"\"\"Each test gets fresh emulator.\"\"\"\n    assert len(fresh_emulator.devices) == 1\n\n@pytest.mark.asyncio\nasync def test_two(fresh_emulator):\n    \"\"\"Separate fresh emulator.\"\"\"\n    assert len(fresh_emulator.devices) == 1\n</code></pre> <p>Use When: - Tests modify device state - Perfect isolation is critical - Tests are few or parallelized</p>"},{"location":"guide/integration-testing/#module-scoped-fixtures","title":"Module-Scoped Fixtures","text":"<p>Shared emulator across one test file - good balance:</p> <pre><code>@pytest.fixture(scope=\"module\")\nasync def module_emulator():\n    \"\"\"Shared across entire module.\"\"\"\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n    ]\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_first_device(module_emulator):\n    \"\"\"Use shared emulator.\"\"\"\n    device = module_emulator.devices[0]\n    assert device.state.serial == \"d073d5000001\"\n\n@pytest.mark.asyncio\nasync def test_second_device(module_emulator):\n    \"\"\"Same emulator instance.\"\"\"\n    device = module_emulator.devices[1]\n    assert device.state.serial == \"d073d5000002\"\n</code></pre> <p>Use When: - Tests don't modify shared state - Want faster test execution - Testing read-only operations</p>"},{"location":"guide/integration-testing/#session-scoped-fixtures","title":"Session-Scoped Fixtures","text":"<p>One emulator for entire test session - fastest:</p> <pre><code>@pytest.fixture(scope=\"session\")\nasync def session_emulator():\n    \"\"\"Shared across all tests.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n</code></pre> <p>Use When: - Very large test suite - All tests are read-only - Speed is critical</p> <p>Warning: Tests can affect each other</p>"},{"location":"guide/integration-testing/#fixture-design-patterns","title":"Fixture Design Patterns","text":""},{"location":"guide/integration-testing/#composable-fixtures","title":"Composable Fixtures","text":"<p>Build complex setups from simple fixtures:</p> <pre><code>@pytest.fixture\nasync def basic_device():\n    \"\"\"Single device fixture.\"\"\"\n    return create_color_light(\"d073d5000001\")\n\n@pytest.fixture\nasync def server_with_device(basic_device):\n    \"\"\"Server using device fixture.\"\"\"\n    server = EmulatedLifxServer([basic_device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_with_composed_fixtures(server_with_device):\n    \"\"\"Use composed fixtures.\"\"\"\n    assert len(server_with_device.devices) == 1\n</code></pre>"},{"location":"guide/integration-testing/#parametrized-fixtures","title":"Parametrized Fixtures","text":"<p>Test against multiple configurations:</p> <pre><code>from lifx_emulator import (\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\n\n@pytest.fixture(params=[\n    (\"color\", lambda: create_color_light(\"d073d5000001\")),\n    (\"multizone\", lambda: create_multizone_light(\"d073d8000001\", zone_count=16)),\n    (\"tile\", lambda: create_tile_device(\"d073d9000001\", tile_count=5)),\n])\nasync def any_device(request):\n    \"\"\"Parametrized device fixture.\"\"\"\n    device_type, factory = request.param\n    device = factory()\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server, device_type\n\n@pytest.mark.asyncio\nasync def test_all_device_types(any_device):\n    \"\"\"Test runs 3 times (once per device type).\"\"\"\n    server, device_type = any_device\n    print(f\"Testing with {device_type} device\")\n    assert len(server.devices) == 1\n</code></pre>"},{"location":"guide/integration-testing/#conditional-fixtures","title":"Conditional Fixtures","text":"<p>Skip tests based on conditions:</p> <pre><code>import sys\n\n@pytest.fixture\nasync def emulator_windows_only():\n    \"\"\"Only run on Windows.\"\"\"\n    if sys.platform != 'win32':\n        pytest.skip(\"Windows-only test\")\n\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"guide/integration-testing/#conftestpy-organization","title":"conftest.py Organization","text":"<p>Centralize fixtures for reuse across test files:</p> <pre><code># tests/conftest.py\nimport pytest\nimport sys\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n)\n\n# Event loop configuration (especially for Windows)\nif sys.platform == 'win32':\n    import asyncio\n    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    import asyncio\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def single_device():\n    \"\"\"Reusable single device fixture.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.fixture\nasync def multi_device():\n    \"\"\"Reusable multi-device fixture.\"\"\"\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n        create_multizone_light(\"d073d8000001\", zone_count=16),\n    ]\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.fixture\nasync def unreliable_device():\n    \"\"\"Device configured for error testing.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    device.scenarios = {\n        'drop_packets': [101],\n        'response_delays': {102: 0.5},\n    }\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n</code></pre> <p>Now all test files can use these fixtures:</p> <pre><code># tests/test_colors.py\nimport pytest\n\n@pytest.mark.asyncio\nasync def test_color_device(single_device):\n    \"\"\"Uses fixture from conftest.py\"\"\"\n    assert single_device.devices[0].state.has_color\n</code></pre>"},{"location":"guide/integration-testing/#test-isolation-techniques","title":"Test Isolation Techniques","text":""},{"location":"guide/integration-testing/#state-reset-between-tests","title":"State Reset Between Tests","text":"<pre><code>@pytest.fixture\nasync def emulator_with_reset():\n    \"\"\"Emulator that resets state between tests.\"\"\"\n    from lifx_emulator.protocol.protocol_types import LightHsbk\n\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    # Store initial state\n    initial_color = device.state.color\n    initial_power = device.state.power\n\n    async with server:\n        yield server\n\n        # Reset state after test\n        device.state.color = initial_color\n        device.state.power = initial_power\n</code></pre>"},{"location":"guide/integration-testing/#separate-device-instances","title":"Separate Device Instances","text":"<pre><code>@pytest.fixture\ndef device_factory():\n    \"\"\"Factory for creating fresh devices.\"\"\"\n    def _create(serial=None):\n        if serial is None:\n            import uuid\n            serial = f\"d073d5{uuid.uuid4().hex[:6]}\"\n        return create_color_light(serial)\n    return _create\n\n@pytest.mark.asyncio\nasync def test_with_factory(device_factory):\n    \"\"\"Each call creates fresh device.\"\"\"\n    device1 = device_factory()\n    device2 = device_factory()\n    assert device1.state.serial != device2.state.serial\n</code></pre>"},{"location":"guide/integration-testing/#port-isolation","title":"Port Isolation","text":"<pre><code>import socket\n\ndef get_free_port():\n    \"\"\"Get available port.\"\"\"\n    with socket.socket() as s:\n        s.bind(('', 0))\n        return s.getsockname()[1]\n\n@pytest.fixture\nasync def isolated_emulator():\n    \"\"\"Emulator on unique port.\"\"\"\n    port = get_free_port()\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server, port\n</code></pre>"},{"location":"guide/integration-testing/#parallel-test-execution","title":"Parallel Test Execution","text":""},{"location":"guide/integration-testing/#basic-parallel-testing","title":"Basic Parallel Testing","text":"<p>Install pytest-xdist:</p> <pre><code>pip install pytest-xdist\n</code></pre> <p>Run tests in parallel:</p> <pre><code># Use all CPU cores\npytest -n auto\n\n# Use specific number of workers\npytest -n 4\n\n# Parallel within modules only\npytest -n auto --dist loadfile\n</code></pre>"},{"location":"guide/integration-testing/#worker-safe-fixtures","title":"Worker-Safe Fixtures","text":"<p>Ensure each worker gets unique ports:</p> <pre><code>@pytest.fixture\nasync def worker_safe_emulator(worker_id):\n    \"\"\"Safe for parallel execution.\"\"\"\n    if worker_id == 'master':\n        # Running in single-threaded mode\n        port = 56700\n        serial = \"d073d5000001\"\n    else:\n        # Running with pytest-xdist (gw0, gw1, etc.)\n        worker_num = int(worker_id.replace('gw', ''))\n        port = 56700 + worker_num + 1\n        serial = f\"d073d500{worker_num:04d}\"\n\n    device = create_color_light(serial)\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"guide/integration-testing/#parallel-test-best-practices","title":"Parallel Test Best Practices","text":"<pre><code># Mark tests as safe for parallel execution\n@pytest.mark.parallel\n@pytest.mark.asyncio\nasync def test_parallel_safe(worker_safe_emulator):\n    \"\"\"Can run in parallel with other tests.\"\"\"\n    assert len(worker_safe_emulator.devices) == 1\n\n# Mark tests that must run serially\n@pytest.mark.serial\n@pytest.mark.asyncio\nasync def test_must_run_alone():\n    \"\"\"Cannot run in parallel.\"\"\"\n    # Tests that modify global state, use hardcoded ports, etc.\n    ...\n</code></pre> <p>Configure in pytest.ini:</p> <pre><code>[pytest]\nmarkers =\n    parallel: Tests safe for parallel execution\n    serial: Tests that must run alone\n</code></pre>"},{"location":"guide/integration-testing/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"guide/integration-testing/#github-actions","title":"GitHub Actions","text":"<p>Basic workflow:</p> <pre><code># .github/workflows/test.yml\nname: Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.13', '3.14']\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v5\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install pytest pytest-asyncio pytest-xdist\n        pip install -e .\n\n    - name: Run tests\n      run: |\n        pytest tests/ -v -n auto\n</code></pre>"},{"location":"guide/integration-testing/#gitlab-ci","title":"GitLab CI","text":"<pre><code># .gitlab-ci.yml\ntest:\n  image: python:3.13\n  script:\n    - pip install pytest pytest-asyncio\n    - pip install -e .\n    - pytest tests/ -v --junitxml=report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n</code></pre>"},{"location":"guide/integration-testing/#docker-based-testing","title":"Docker-Based Testing","text":"<pre><code># Dockerfile.test\nFROM python:3.13-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install pytest pytest-asyncio &amp;&amp; \\\n    pip install -e .\n\nCMD [\"pytest\", \"tests/\", \"-v\"]\n</code></pre> <p>Run tests in Docker:</p> <pre><code>docker build -f Dockerfile.test -t lifx-tests .\ndocker run lifx-tests\n</code></pre>"},{"location":"guide/integration-testing/#handling-test-dependencies","title":"Handling Test Dependencies","text":""},{"location":"guide/integration-testing/#sequential-test-execution","title":"Sequential Test Execution","text":"<p>When tests must run in order:</p> <pre><code>import pytest\n\n@pytest.mark.asyncio\n@pytest.mark.order(1)\nasync def test_first():\n    \"\"\"Runs first.\"\"\"\n    ...\n\n@pytest.mark.asyncio\n@pytest.mark.order(2)\nasync def test_second():\n    \"\"\"Runs second.\"\"\"\n    ...\n</code></pre> <p>Requires pytest-order:</p> <pre><code>pip install pytest-order\n</code></pre>"},{"location":"guide/integration-testing/#test-data-dependencies","title":"Test Data Dependencies","text":"<p>Share data between tests:</p> <pre><code>import pytest\n\n@pytest.fixture(scope=\"module\")\ndef test_data():\n    \"\"\"Shared test data.\"\"\"\n    return {\"device_serial\": \"d073d5000001\"}\n\n@pytest.mark.asyncio\nasync def test_create(test_data):\n    \"\"\"Use shared data.\"\"\"\n    device = create_color_light(test_data[\"device_serial\"])\n    assert device is not None\n\n@pytest.mark.asyncio\nasync def test_query(test_data):\n    \"\"\"Use same data.\"\"\"\n    # Can use test_data[\"device_serial\"]\n    ...\n</code></pre>"},{"location":"guide/integration-testing/#cleanup-dependencies","title":"Cleanup Dependencies","text":"<p>Ensure cleanup happens in correct order:</p> <pre><code>@pytest.fixture\nasync def database():\n    \"\"\"Mock database.\"\"\"\n    db = setup_database()\n    yield db\n    teardown_database(db)\n\n@pytest.fixture\nasync def emulator_with_db(database):\n    \"\"\"Emulator using database.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n    # database fixture will clean up after this\n</code></pre>"},{"location":"guide/integration-testing/#advanced-testing-patterns","title":"Advanced Testing Patterns","text":""},{"location":"guide/integration-testing/#testing-error-handling","title":"Testing Error Handling","text":"<pre><code>@pytest.mark.asyncio\nasync def test_timeout_handling():\n    \"\"\"Test client handles timeouts.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n\n    # Drop all GetColor packets\n    device.scenarios = {'drop_packets': [101]}\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Your client should timeout gracefully\n        import asyncio\n        with pytest.raises(asyncio.TimeoutError):\n            await asyncio.wait_for(query_color(device), timeout=1.0)\n</code></pre>"},{"location":"guide/integration-testing/#testing-concurrent-operations","title":"Testing Concurrent Operations","text":"<pre><code>@pytest.mark.asyncio\nasync def test_concurrent_requests():\n    \"\"\"Test multiple concurrent operations.\"\"\"\n    devices = [create_color_light(f\"d073d500{i:04d}\") for i in range(5)]\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        # Send requests to all devices concurrently\n        tasks = [\n            query_device(device.state.serial)\n            for device in devices\n        ]\n        results = await asyncio.gather(*tasks)\n\n        assert len(results) == 5\n</code></pre>"},{"location":"guide/integration-testing/#testing-state-transitions","title":"Testing State Transitions","text":"<pre><code>@pytest.mark.asyncio\nasync def test_state_transitions():\n    \"\"\"Test device state changes.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Initial state\n        assert device.state.power == 65535  # On\n\n        # Transition to off\n        device.state.power = 0\n        assert device.state.power == 0\n\n        # Back to on\n        device.state.power = 65535\n        assert device.state.power == 65535\n</code></pre>"},{"location":"guide/integration-testing/#pytest-configuration","title":"pytest Configuration","text":""},{"location":"guide/integration-testing/#pytestini","title":"pytest.ini","text":"<pre><code>[pytest]\n# Test discovery\npython_files = test_*.py *_test.py\npython_classes = Test*\npython_functions = test_*\n\n# Async support\nasyncio_mode = auto\n\n# Output\naddopts =\n    -v\n    --strict-markers\n    --tb=short\n    --color=yes\n\n# Markers\nmarkers =\n    slow: Slow tests (deselect with '-m \"not slow\"')\n    integration: Integration tests\n    unit: Unit tests\n    parallel: Safe for parallel execution\n\n# Coverage\n[coverage:run]\nsource = src\nomit = */tests/*\n\n[coverage:report]\nprecision = 2\nshow_missing = True\n</code></pre>"},{"location":"guide/integration-testing/#pyprojecttoml","title":"pyproject.toml","text":"<pre><code>[tool.pytest.ini_options]\nminversion = \"7.0\"\ntestpaths = [\"tests\"]\nasyncio_mode = \"auto\"\n</code></pre>"},{"location":"guide/integration-testing/#test-organization-structure","title":"Test Organization Structure","text":"<pre><code>tests/\n\u251c\u2500\u2500 conftest.py              # Shared fixtures\n\u251c\u2500\u2500 unit/                    # Unit tests\n\u2502   \u251c\u2500\u2500 test_colors.py\n\u2502   \u251c\u2500\u2500 test_power.py\n\u2502   \u2514\u2500\u2500 test_labels.py\n\u251c\u2500\u2500 integration/             # Integration tests\n\u2502   \u251c\u2500\u2500 conftest.py         # Integration-specific fixtures\n\u2502   \u251c\u2500\u2500 test_discovery.py\n\u2502   \u251c\u2500\u2500 test_multidevice.py\n\u2502   \u2514\u2500\u2500 test_scenarios.py\n\u251c\u2500\u2500 performance/             # Performance tests\n\u2502   \u251c\u2500\u2500 test_load.py\n\u2502   \u2514\u2500\u2500 test_concurrent.py\n\u2514\u2500\u2500 fixtures/                # Shared test data\n    \u251c\u2500\u2500 device_configs.py\n    \u2514\u2500\u2500 scenarios.py\n</code></pre>"},{"location":"guide/integration-testing/#debugging-failed-tests","title":"Debugging Failed Tests","text":""},{"location":"guide/integration-testing/#capture-output","title":"Capture Output","text":"<pre><code>import pytest\n\n@pytest.mark.asyncio\nasync def test_with_capture(capfd):\n    \"\"\"Capture stdout/stderr.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    print(f\"Device created: {device.state.serial}\")\n\n    # Test code...\n\n    # Check captured output\n    captured = capfd.readouterr()\n    assert \"d073d5000001\" in captured.out\n</code></pre>"},{"location":"guide/integration-testing/#use-pytest-pdb","title":"Use pytest --pdb","text":"<pre><code># Drop into debugger on failure\npytest --pdb\n\n# Drop into debugger on first failure\npytest -x --pdb\n\n# Drop into debugger at start of test\npytest --trace\n</code></pre>"},{"location":"guide/integration-testing/#add-logging","title":"Add Logging","text":"<pre><code>import logging\nimport pytest\n\n@pytest.fixture(autouse=True)\ndef configure_logging():\n    \"\"\"Auto-configure logging for all tests.\"\"\"\n    logging.basicConfig(\n        level=logging.DEBUG,\n        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n    )\n</code></pre>"},{"location":"guide/integration-testing/#next-steps","title":"Next Steps","text":"<ul> <li>Best Practices - Testing best practices</li> <li>Testing Scenarios - Error injection</li> <li>CI/CD Tutorial - Detailed CI/CD setup</li> <li>Integration Examples - More examples</li> </ul>"},{"location":"guide/integration-testing/#see-also","title":"See Also","text":"<ul> <li>pytest Documentation</li> <li>pytest-asyncio Documentation</li> <li>pytest-xdist Documentation</li> <li>API Reference: Server</li> <li>API Reference: Device</li> </ul>"},{"location":"guide/products-and-specs/","title":"LIFX Product Registry and Specifications","text":"<p>This directory contains the product registry and specification library for the LIFX emulator.</p>"},{"location":"guide/products-and-specs/#files","title":"Files","text":""},{"location":"guide/products-and-specs/#registrypy-auto-generated","title":"<code>registry.py</code> (Auto-generated)","text":"<p>DO NOT EDIT MANUALLY</p> <p>Generated from the official LIFX products.json catalog. Contains:</p> <ul> <li>Product IDs and names</li> <li>Vendor IDs</li> <li>Capabilities (color, multizone, matrix, infrared, HEV, etc.)</li> <li>Temperature ranges</li> <li>Extended multizone firmware versions</li> </ul> <p>To regenerate: <pre><code>python -m lifx_emulator.products.generator\n</code></pre></p>"},{"location":"guide/products-and-specs/#specsyml-manual-configuration","title":"<code>specs.yml</code> (Manual configuration)","text":"<p>EDIT THIS FILE</p> <p>Contains product-specific details not available in the upstream catalog:</p> <ul> <li>Default zone counts for multizone devices</li> <li>Min/max zone counts</li> <li>Default tile counts for matrix devices</li> <li>Min/max tile counts</li> <li>Tile dimensions (width x height in zones)</li> <li>Product-specific notes</li> </ul>"},{"location":"guide/products-and-specs/#specspy","title":"<code>specs.py</code>","text":"<p>Python module for loading and accessing specification data.</p>"},{"location":"guide/products-and-specs/#generatorpy","title":"<code>generator.py</code>","text":"<p>Script to download and generate <code>registry.py</code> from the official LIFX products.json.</p>"},{"location":"guide/products-and-specs/#customizing-specifications","title":"Customizing Specifications","text":"<p>When the product generator creates specifications, you can edit them in <code>specs.yml</code> to customize defaults or add product-specific notes.</p>"},{"location":"guide/products-and-specs/#for-multizone-devices-strips-beams-neon","title":"For Multizone Devices (Strips, Beams, Neon)","text":"<pre><code>products:\n  &lt;product_id&gt;:\n    default_zone_count: &lt;number&gt;    # Typical zone count\n    min_zone_count: &lt;number&gt;        # Minimum zones supported\n    max_zone_count: &lt;number&gt;        # Maximum zones supported\n    notes: \"&lt;description&gt;\"\n</code></pre> <p>Example - LIFX Z Strip: <pre><code>products:\n  32:\n    default_zone_count: 16\n    min_zone_count: 1\n    max_zone_count: 16\n    notes: \"LIFX Z with extended multizone firmware support\"\n</code></pre></p> <p>Example - LIFX Beam: <pre><code>products:\n  38:\n    default_zone_count: 80\n    min_zone_count: 10\n    max_zone_count: 82\n    notes: \"LIFX Beam, 8 individual beams, each with 10 zones and up to 2 corners\"\n</code></pre></p>"},{"location":"guide/products-and-specs/#for-matrix-devices-tiles-candles-ceiling","title":"For Matrix Devices (Tiles, Candles, Ceiling)","text":"<pre><code>products:\n  &lt;product_id&gt;:\n    default_tile_count: &lt;number&gt;    # Typical number of tiles in chain\n    min_tile_count: &lt;number&gt;        # Minimum tiles supported\n    max_tile_count: &lt;number&gt;        # Maximum tiles supported\n    tile_width: &lt;zones&gt;            # Width of each tile\n    tile_height: &lt;zones&gt;           # Height of each tile\n    notes: \"&lt;description&gt;\"\n</code></pre> <p>Example - LIFX Tile: <pre><code>products:\n  55:\n    default_tile_count: 5\n    min_tile_count: 1\n    max_tile_count: 5\n    tile_width: 8\n    tile_height: 8\n    notes: \"LIFX Tile, 8x8 zone matrix, chainable up to 5\"\n</code></pre></p> <p>Example - LIFX Candle: <pre><code>products:\n  57:\n    default_tile_count: 1\n    min_tile_count: 1\n    max_tile_count: 1\n    tile_width: 5\n    tile_height: 6\n    notes: \"LIFX Candle, 5x6 zone matrix, single unit\"\n</code></pre></p> <p>Example - LIFX Ceiling: <pre><code>products:\n  176:\n    default_tile_count: 1\n    min_tile_count: 1\n    max_tile_count: 1\n    tile_width: 22\n    tile_height: 22\n    notes: \"LIFX Ceiling, 22x22 zone matrix\"\n</code></pre></p>"},{"location":"guide/products-and-specs/#how-specifications-are-used","title":"How Specifications Are Used","text":""},{"location":"guide/products-and-specs/#multizone-devices","title":"Multizone Devices","text":"<p>When creating a multizone device without specifying <code>zone_count</code>:</p> <ol> <li>Check <code>specs.yml</code> for <code>default_zone_count</code></li> <li>If not found, use registry capability defaults:</li> <li>Extended multizone: 82 zones</li> <li>Standard multizone: 16 zones</li> </ol> <pre><code># Uses specification default (80 zones for Beam)\ndevice = create_device(38)\n\n# Override with custom count\ndevice = create_device(38, zone_count=40)\n</code></pre>"},{"location":"guide/products-and-specs/#matrix-devices","title":"Matrix Devices","text":"<p>When creating a matrix device:</p> <ol> <li>Tile dimensions: Always from <code>specs.yml</code> (required for accuracy)</li> <li>Tile count: From <code>specs.yml</code> if not specified by user</li> </ol> <pre><code># Uses specification: 5 tiles of 8x8 zones\ndevice = create_device(55)\n\n# Custom tile count, specification dimensions\ndevice = create_device(55, tile_count=3)  # 3 tiles of 8x8 zones\n\n# Candle: 1 tile of 5x5 zones (from specification)\ndevice = create_device(57)\n\n# Ceiling: 1 tile of 22x22 zones (from specification)\ndevice = create_device(176)\n</code></pre>"},{"location":"guide/products-and-specs/#current-specification-coverage","title":"Current Specification Coverage","text":"<p>All multizone and matrix devices currently available have specifications defined:</p> <ul> <li>Multizone: 19 products (Z, Beam, Neon, String, Outdoor Neon, Indoor Neon, Permanent Outdoor - with US and international variants)</li> <li>Matrix: 22 products (Tile, Candle, Ceiling, Round Spot, Round Path, Square Path, Tube, Luna - with US and international variants)</li> <li>Total: 41 products with specifications defined</li> </ul> <p>See <code>specs.yml</code> for the complete list.</p>"},{"location":"guide/products-and-specs/#maintenance","title":"Maintenance","text":""},{"location":"guide/products-and-specs/#when-to-update-specifications","title":"When to Update Specifications","text":"<ol> <li>New LIFX products released: The generator automatically creates a specification - edit <code>specs.yml</code> to customize defaults or add product-specific notes</li> <li>Product specifications change: Update specification values in <code>specs.yml</code></li> <li>Better information available: Refine default values</li> <li>User reports incorrect defaults: Verify and update in <code>specs.yml</code></li> </ol>"},{"location":"guide/products-and-specs/#regenerating-registry","title":"Regenerating Registry","text":"<p>When LIFX releases new products or updates the catalog: <pre><code># Download latest products.json and regenerate registry.py\npython -m lifx_emulator.products.generator\n\n# Specifications are auto-generated; edit specs.yml to customize if needed\n# Test with: lifx-emulator --product &lt;new_pid&gt;\n</code></pre></p>"},{"location":"guide/products-and-specs/#api-reference","title":"API Reference","text":""},{"location":"guide/products-and-specs/#python-api","title":"Python API","text":"<pre><code>from lifx_emulator.products.specs import (\n    get_specs,\n    get_default_zone_count,\n    get_default_tile_count,\n    get_tile_dimensions,\n)\n\n# Get all specification for a product\nspecification = get_specs(55)  # LIFX Tile\nif specification:\n    print(f\"Default tiles: {specification.default_tile_count}\")\n    print(f\"Tile size: {specification.tile_width}x{specification.tile_height}\")\n\n# Get specific values\nzones = get_default_zone_count(32)  # 16 for LIFX Z\ntiles = get_default_tile_count(55)  # 5 for LIFX Tile\nwidth, height = get_tile_dimensions(176)  # (22, 22) for LIFX Ceiling\n</code></pre>"},{"location":"guide/products-and-specs/#contributing","title":"Contributing","text":"<p>When you discover more accurate specification information:</p> <ol> <li>Edit or refine the specification in <code>specs.yml</code></li> <li>Test with <code>python -m lifx_emulator --product &lt;product ID&gt;</code></li> <li>Include source/reference in the <code>notes</code> field</li> <li>Submit your refinement either as pull request or open an issue.</li> </ol> <p>For questions or help, check the main project README.</p>"},{"location":"guide/testing-scenarios/","title":"Testing Scenarios","text":"<p>The LIFX Emulator provides a powerful scenarios system that allows you to simulate various error conditions, network issues, and edge cases. This guide covers all available testing scenarios and how to use them effectively.</p>"},{"location":"guide/testing-scenarios/#overview","title":"Overview","text":"<p>Testing scenarios modify how emulated devices respond to protocol packets, allowing you to test your client's resilience and error handling.</p> Python LibraryREST API <p>Configure scenarios via the <code>scenarios</code> dictionary on an <code>EmulatedLifxDevice</code>:</p> <pre><code>from lifx_emulator import create_color_light\n\ndevice = create_color_light(\"d073d5000001\")\n\n# Configure scenarios\ndevice.scenarios = {\n    'drop_packets': {101: 1.0},  # Drop GetColor requests\n    'response_delays': {102: 0.5},  # Delay SetColor by 500ms\n    'malformed_packets': [107],  # Corrupt StateColor responses\n}\n</code></pre> <p>Configure scenarios via the Scenario REST API (requires <code>--api</code> flag):</p> <pre><code># Start emulator with API\nlifx-emulator --color 1 --api\n\n# Configure scenario for a specific device\ncurl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"drop_packets\": {\"101\": 1.0},\n    \"response_delays\": {\"102\": 0.5},\n    \"malformed_packets\": [107]\n  }'\n\n# Configure scenario for all color devices\ncurl -X PUT http://localhost:8080/api/scenarios/types/color \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"drop_packets\": {\"101\": 0.3}}'\n\n# Configure global scenario for all devices\ncurl -X PUT http://localhost:8080/api/scenarios/global \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"response_delays\": {\"101\": 0.5}}'\n</code></pre>"},{"location":"guide/testing-scenarios/#available-scenarios","title":"Available Scenarios","text":""},{"location":"guide/testing-scenarios/#1-packet-dropping-drop_packets","title":"1. Packet Dropping (<code>drop_packets</code>)","text":"<p>Silently ignore specific packet types to simulate network packet loss or device unresponsiveness. Supports both deterministic dropping (always drop) and probabilistic dropping (drop X% of packets).</p> <p>Configuration: Dictionary mapping packet type to drop rate (0.1-1.0) - <code>1.0</code> = always drop (100%) - <code>0.5</code> = drop 50% of packets - <code>0.1</code> = drop 10% of packets</p> <p>Use Cases: - Test client retry logic - Simulate network packet loss - Test timeout handling - Verify client doesn't hang on no response - Test resilience to intermittent failures</p> <p>Example - Always Drop:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Always drop GetColor (101) and GetPower (20) requests\n    device.scenarios = {\n        'drop_packets': {101: 1.0, 20: 1.0}\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will drop 100% of GetColor and GetPower packets\")\n        print(\"Clients should timeout and implement retry logic\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Example - Probabilistic Drop:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Drop packets probabilistically (simulating flaky network)\n    device.scenarios = {\n        'drop_packets': {\n            101: 0.3,   # Drop 30% of GetColor requests\n            102: 0.2,   # Drop 20% of SetColor requests\n            20: 0.4,    # Drop 40% of GetLabel requests\n        }\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will drop packets probabilistically\")\n        print(\"Simulating an unreliable network connection\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Common Packet Types to Drop: - <code>20</code> - GetLabel - <code>101</code> - GetColor (Light.GetColor) - <code>116</code> - GetPower (Light.GetPower) - <code>502</code> - GetColorZones (MultiZone.GetColorZones) - <code>707</code> - Get64 (Tile.Get64)</p> <p>Drop Rate Recommendations:</p> <ul> <li>Testing retry logic: 1.0 (always drop)</li> <li>Simulating flaky WiFi: 0.1-0.3 (10-30% drop rate)</li> <li>Simulating congestion: 0.2-0.4 (20-40% drop rate)</li> <li>Simulating very poor connection: 0.5-0.8 (50-80% drop rate)</li> </ul> <p>Testing Checklist: - [ ] Client implements retry logic - [ ] Client has appropriate timeouts - [ ] Client doesn't hang indefinitely - [ ] User gets feedback about timeout - [ ] Exponential backoff is implemented (if applicable) - [ ] Client recovers after transient failures (for probabilistic drops)</p>"},{"location":"guide/testing-scenarios/#2-response-delays-response_delays","title":"2. Response Delays (<code>response_delays</code>)","text":"<p>Add artificial delays to specific packet responses to simulate slow devices or network latency.</p> <p>Configuration: Dictionary mapping packet type to delay in seconds</p> <p>Use Cases: - Test timeout configuration - Simulate slow network conditions - Test concurrent request handling - Verify UI doesn't freeze during slow responses</p> <p>Example:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Add various delays\n    device.scenarios = {\n        'response_delays': {\n            101: 0.5,   # GetColor: 500ms delay\n            102: 1.0,   # SetColor: 1 second delay\n            20: 0.2,    # GetLabel: 200ms delay\n            117: 2.0,   # SetPower: 2 second delay (very slow)\n        }\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device configured with response delays\")\n        print(\"Test your client's async handling and timeouts\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Realistic Delay Values: - Fast local network: 0.01 - 0.05 seconds (10-50ms) - Normal local network: 0.05 - 0.2 seconds (50-200ms) - Slow/congested network: 0.5 - 2.0 seconds - Very slow/problematic: 2.0+ seconds</p> <p>Testing Checklist: - [ ] UI remains responsive during slow operations - [ ] Progress indicators show during slow requests - [ ] Timeout values are appropriate for expected delays - [ ] Multiple slow requests don't block each other - [ ] Cancel operations work correctly</p>"},{"location":"guide/testing-scenarios/#3-malformed-packets-malformed_packets","title":"3. Malformed Packets (<code>malformed_packets</code>)","text":"<p>Send truncated or corrupted packet responses to test client parsing robustness.</p> <p>Configuration: List of packet types to corrupt</p> <p>Use Cases: - Test packet parsing error handling - Verify client doesn't crash on bad data - Test protocol implementation resilience - Ensure graceful degradation</p> <p>Example:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Corrupt StateColor and StateLabel responses\n    device.scenarios = {\n        'malformed_packets': [107, 25]  # StateColor, StateLabel\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will send malformed StateColor and StateLabel packets\")\n        print(\"Your client should handle parsing errors gracefully\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Implementation Details: - Packets are truncated to 50% of their normal size - Binary data may be corrupted or incomplete - Header is still valid (so packet is delivered)</p> <p>Testing Checklist: - [ ] Client doesn't crash on malformed packets - [ ] Parsing errors are caught and logged - [ ] User sees error message (not crash) - [ ] Client can recover after parsing error - [ ] Invalid data is rejected, not used</p>"},{"location":"guide/testing-scenarios/#4-invalid-field-values-invalid_field_values","title":"4. Invalid Field Values (<code>invalid_field_values</code>)","text":"<p>Send packets with all fields set to invalid values (0xFF bytes).</p> <p>Configuration: List of packet types to send with invalid data</p> <p>Use Cases: - Test field validation - Verify bounds checking - Test handling of out-of-range values - Ensure client validates data</p> <p>Example:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Send StateColor with invalid field values\n    device.scenarios = {\n        'invalid_field_values': [107]  # StateColor\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will send StateColor with all 0xFF bytes\")\n        print(\"Hue, saturation, brightness, kelvin all invalid\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>What Gets Invalidated: - All numeric fields set to 0xFFFF or 0xFFFFFFFF - Strings filled with invalid characters - Enums set to undefined values</p> <p>Testing Checklist: - [ ] Client validates field ranges - [ ] Out-of-range values are rejected - [ ] Invalid enums are handled - [ ] Client uses safe defaults on invalid data - [ ] Errors are reported to user</p>"},{"location":"guide/testing-scenarios/#5-partial-responses-partial_responses","title":"5. Partial Responses (<code>partial_responses</code>)","text":"<p>Send incomplete packet payloads to test client's handling of truncated data.</p> <p>Configuration: List of packet types to truncate</p> <p>Use Cases: - Test buffer handling - Verify client doesn't read past buffer - Test partial data handling - Simulate network truncation</p> <p>Example:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Send partial StateColor responses\n    device.scenarios = {\n        'partial_responses': [107]  # StateColor\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will send truncated StateColor packets\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Testing Checklist: - [ ] Client detects truncated packets - [ ] No buffer overruns occur - [ ] Partial data is rejected - [ ] Client doesn't crash on short reads - [ ] Error is logged appropriately</p>"},{"location":"guide/testing-scenarios/#6-custom-firmware-version-firmware_version","title":"6. Custom Firmware Version (<code>firmware_version</code>)","text":"<p>Override the reported firmware version to test version compatibility.</p> <p>Configuration: Tuple of (major, minor) version numbers</p> <p>Use Cases: - Test version detection - Verify feature compatibility checks - Test upgrade/downgrade scenarios - Ensure graceful handling of unknown versions</p> <p>Example:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Pretend to be an older firmware version\n    device.scenarios = {\n        'firmware_version': (2, 50)  # Version 2.50 (old)\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Device reports firmware version: 2.50\")\n        print(\"Test your client's version compatibility logic\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Common Versions to Test: - <code>(2, 0)</code> - Very old firmware - <code>(3, 50)</code> - Mid-range firmware - <code>(3, 70)</code> - Current typical version - <code>(99, 99)</code> - Future/unknown version</p>"},{"location":"guide/testing-scenarios/#combining-multiple-scenarios","title":"Combining Multiple Scenarios","text":"<p>You can combine multiple scenarios to create complex test conditions:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Realistic \"problem device\" scenario\n    device.scenarios = {\n        'drop_packets': {101: 0.4},  # Drops 40% of GetColor requests\n        'response_delays': {\n            102: 0.8,  # Color changes are slow\n            20: 0.3,   # Label queries are slow\n        },\n        'malformed_packets': [25],  # StateLabel occasionally corrupted\n        'firmware_version': (2, 77),  # Older firmware\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Simulating a problematic device:\")\n        print(\"  - Drops 40% of GetColor requests\")\n        print(\"  - Slow to respond to commands\")\n        print(\"  - Occasionally sends corrupted labels\")\n        print(\"  - Reports older firmware\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/testing-scenarios/#real-world-test-scenarios","title":"Real-World Test Scenarios","text":""},{"location":"guide/testing-scenarios/#scenario-1-flaky-wifi-connection","title":"Scenario 1: Flaky WiFi Connection","text":"<p>Simulate a device on an unreliable network:</p> <pre><code>device.scenarios = {\n    'drop_packets': {\n        101: 0.3,  # Drop 30% of GetColor requests\n        20: 0.3,   # Drop 30% of GetLabel requests\n        116: 0.2,  # Drop 20% of GetPower requests\n    },\n    'response_delays': {\n        102: 1.5,  # Very slow commands\n        117: 2.0,  # Very slow power changes\n    },\n}\n</code></pre> <p>What to Test: - Does your client retry appropriately? - Are users informed about connectivity issues? - Does the UI remain responsive? - Does the client recover after transient failures?</p>"},{"location":"guide/testing-scenarios/#scenario-2-firmware-bugs","title":"Scenario 2: Firmware Bugs","text":"<p>Simulate a device with firmware issues:</p> <pre><code>device.scenarios = {\n    'malformed_packets': [107],  # Corrupted color state\n    'invalid_field_values': [25],  # Invalid label data\n    'firmware_version': (2, 50),  # Old firmware with known bugs\n}\n</code></pre> <p>What to Test: - Does your client validate responses? - Are parsing errors handled gracefully? - Is the user informed about potential device issues?</p>"},{"location":"guide/testing-scenarios/#scenario-3-overloaded-device","title":"Scenario 3: Overloaded Device","text":"<p>Simulate a busy device with limited resources:</p> <pre><code>device.scenarios = {\n    'response_delays': {\n        101: 0.5,\n        102: 1.0,\n        20: 0.4,\n        117: 1.2,\n        116: 0.6,\n    },\n}\n</code></pre> <p>What to Test: - Can your client handle slow devices? - Do multiple concurrent requests work? - Is there a loading indicator for slow operations?</p>"},{"location":"guide/testing-scenarios/#scenario-4-edge-case-testing","title":"Scenario 4: Edge Case Testing","text":"<p>Test unusual but valid conditions:</p> <pre><code>device.scenarios = {\n    'firmware_version': (0, 1),  # Very old firmware\n    'response_delays': {102: 5.0},  # Extremely slow (but valid)\n}\n</code></pre> <p>What to Test: - Minimum firmware version support - Maximum timeout handling - Version compatibility warnings</p>"},{"location":"guide/testing-scenarios/#per-device-scenarios","title":"Per-Device Scenarios","text":"<p>Apply different scenarios to different devices in a multi-device setup:</p> <pre><code>import asyncio\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n)\n\nasync def main():\n    # Device 1: Perfect device (no scenarios)\n    device1 = create_color_light(\"d073d5000001\")\n    device1.state.label = \"Perfect Light\"\n\n    # Device 2: Slow device\n    device2 = create_color_light(\"d073d5000002\")\n    device2.state.label = \"Slow Light\"\n    device2.scenarios = {\n        'response_delays': {102: 1.0, 117: 1.5}\n    }\n\n    # Device 3: Unreliable device (drops some packets)\n    device3 = create_multizone_light(\"d073d8000001\", zone_count=16)\n    device3.state.label = \"Flaky Strip\"\n    device3.scenarios = {\n        'drop_packets': {502: 0.4},  # Drop 40% of GetColorZones\n        'response_delays': {503: 0.8},  # Slow SetColorZones\n    }\n\n    server = EmulatedLifxServer([device1, device2, device3], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Testing with mixed device reliability:\")\n        print(f\"  {device1.state.label}: Normal\")\n        print(f\"  {device2.state.label}: Slow\")\n        print(f\"  {device3.state.label}: Unreliable (drops 40% of color zone queries)\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"guide/testing-scenarios/#debugging-scenario-issues","title":"Debugging Scenario Issues","text":""},{"location":"guide/testing-scenarios/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<p>When scenarios aren't behaving as expected:</p> <pre><code>import logging\n\n# Enable debug logging\nlogging.basicConfig(level=logging.DEBUG)\n\n# Your test code here\n</code></pre>"},{"location":"guide/testing-scenarios/#verify-packet-types","title":"Verify Packet Types","text":"<p>Make sure you're using the correct packet type numbers:</p> <pre><code>from lifx_emulator.protocol.packets import Device, Light, MultiZone, Tile\n\n# Common packet types\nprint(f\"GetColor: {Light.GetColor.PKT_TYPE}\")  # 101\nprint(f\"SetColor: {Light.SetColor.PKT_TYPE}\")  # 102\nprint(f\"StateColor: {Light.StateColor.PKT_TYPE}\")  # 107\nprint(f\"GetPower: {Light.GetPower.PKT_TYPE}\")  # 116\n</code></pre>"},{"location":"guide/testing-scenarios/#test-scenarios-independently","title":"Test Scenarios Independently","text":"<p>Test one scenario at a time to isolate issues:</p> <pre><code># Test drop_packets alone (always drop)\ndevice.scenarios = {'drop_packets': {101: 1.0}}\n\n# Then test response_delays alone\ndevice.scenarios = {'response_delays': {102: 0.5}}\n\n# Then combine them\ndevice.scenarios = {\n    'drop_packets': {101: 0.5},  # Drop 50% probabilistically\n    'response_delays': {102: 0.5},\n}\n</code></pre>"},{"location":"guide/testing-scenarios/#common-packet-types-reference","title":"Common Packet Types Reference","text":"Type Name Description 2 GetService Device discovery 12 GetHostInfo Get host firmware info 14 GetHostFirmware Get host firmware version 16 GetWifiInfo Get WiFi info 18 GetWifiFirmware Get WiFi firmware 20 GetLabel Get device label 23 SetLabel Set device label 32 GetLocation Get location 35 SetLocation Set location 48 GetGroup Get group 51 SetGroup Set group 101 GetColor Get light color 102 SetColor Set light color 116 GetLightPower Get light power 117 SetLightPower Set light power 502 GetColorZones Get multizone colors 503 SetColorZones Set multizone colors 510 GetMultiZoneEffect Get multizone effect 511 SetMultiZoneEffect Set multizone effect 701 GetDeviceChain Get tile chain 707 Get64 Get tile 64 zones 715 Set64 Set tile 64 zones"},{"location":"guide/testing-scenarios/#best-practices","title":"Best Practices","text":""},{"location":"guide/testing-scenarios/#1-start-simple","title":"1. Start Simple","text":"<p>Begin with one scenario type, verify it works, then add more:</p> <pre><code># Step 1: Test drops (always drop)\ndevice.scenarios = {'drop_packets': {101: 1.0}}\n\n# Step 2: Test probabilistic drops\ndevice.scenarios = {'drop_packets': {101: 0.5}}\n\n# Step 3: Add delays\ndevice.scenarios = {\n    'drop_packets': {101: 0.5},\n    'response_delays': {102: 0.5},\n}\n\n# Step 4: Add more complexity\ndevice.scenarios = {\n    'drop_packets': {101: 0.5},\n    'response_delays': {102: 0.5},\n    'malformed_packets': [107],\n}\n</code></pre>"},{"location":"guide/testing-scenarios/#2-use-realistic-values","title":"2. Use Realistic Values","text":"<p>Choose delay values that represent real-world conditions:</p> <ul> <li>Don't use 10-second delays (unrealistic)</li> <li>Do use 0.5-2 second delays (realistic for slow networks)</li> </ul>"},{"location":"guide/testing-scenarios/#3-test-error-recovery","title":"3. Test Error Recovery","text":"<p>Scenarios should test your recovery logic, not just error detection:</p> <ul> <li>After a drop, can the client retry successfully?</li> <li>After a timeout, can the client reconnect?</li> <li>After invalid data, can the client request fresh data?</li> </ul>"},{"location":"guide/testing-scenarios/#4-document-test-cases","title":"4. Document Test Cases","text":"<p>Create named scenario configurations for common tests:</p> <pre><code>SCENARIOS = {\n    'flaky_network': {\n        'drop_packets': {101: 0.3, 20: 0.3},  # 30% drop rate\n        'response_delays': {102: 1.0},\n    },\n    'firmware_bug': {\n        'malformed_packets': [107],\n        'firmware_version': (2, 50),\n    },\n    'slow_device': {\n        'response_delays': {\n            101: 0.5,\n            102: 1.0,\n            20: 0.3,\n        },\n    },\n    'intermittent_failures': {\n        'drop_packets': {101: 0.5, 116: 0.4},  # 50% and 40% drop rates\n    },\n}\n\n# Use in tests\ndevice.scenarios = SCENARIOS['flaky_network']\n</code></pre>"},{"location":"guide/testing-scenarios/#next-steps","title":"Next Steps","text":"<ul> <li>Advanced Examples - See scenarios in action</li> <li>Integration Testing - Use scenarios in test suites</li> <li>Best Practices - Testing strategies</li> <li>API Reference: Device - Full device API documentation</li> </ul>"},{"location":"guide/testing-scenarios/#see-also","title":"See Also","text":"<ul> <li>Protocol Types Reference - All packet types and numbers</li> <li>Device API - EmulatedLifxDevice documentation</li> <li>FAQ - Common issues and solutions</li> </ul>"},{"location":"library/","title":"Python Library Reference","text":"<p>Complete Python library documentation for the LIFX Emulator core library (<code>lifx-emulator-core</code>).</p>"},{"location":"library/#overview","title":"Overview","text":"<p>The LIFX Emulator library is designed for simplicity and ease of use. Most users only need the factory functions, server class, and required manager/repository components.</p>"},{"location":"library/#reading-this-guide","title":"Reading This Guide","text":"<p>This reference is organized from most common to advanced usage:</p> <ol> <li>Factory Functions - Creating devices (most common)</li> <li>Server - Server setup and configuration</li> <li>Device - Device API and state management</li> <li>Products - Product registry and specs</li> <li>Protocol - Low-level protocol types (advanced)</li> <li>Storage - Persistent state (advanced)</li> </ol>"},{"location":"library/#quick-start","title":"Quick Start","text":""},{"location":"library/#installation","title":"Installation","text":"<p>Recommended: Using uv:</p> <pre><code>uv add lifx-emulator-core\n</code></pre> <p>Alternative: Using pip:</p> <pre><code>pip install lifx-emulator-core\n</code></pre>"},{"location":"library/#basic-usage","title":"Basic Usage","text":"<pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def main():\n    # Create a device\n    device = create_color_light(\"d073d5000001\")\n\n    # Set up repository and manager (required)\n    device_repository = DeviceRepository()\n    device_manager = DeviceManager(device_repository)\n\n    # Start server\n    async with EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    ) as server:\n        # Server is running, test your LIFX library here\n        await asyncio.Event().wait()\n\nasyncio.run(main())\n</code></pre>"},{"location":"library/#core-components","title":"Core Components","text":""},{"location":"library/#1-factory-functions-most-common","title":"1. Factory Functions (Most Common)","text":"<p>Use these to create devices easily:</p> <pre><code>from lifx_emulator.factories import (\n    create_color_light,             # RGB color lights\n    create_color_temperature_light, # White temperature lights\n    create_infrared_light,          # IR-capable lights\n    create_hev_light,               # HEV cleaning lights\n    create_multizone_light,         # Linear strips\n    create_tile_device,             # Matrix tiles\n    create_switch,                  # Relay switches\n    create_device,                  # Universal factory\n)\n</code></pre> <p>\ud83d\udc49 Full Factory Documentation</p>"},{"location":"library/#2-server","title":"2. Server","text":"<p>The server manages UDP communication and device routing:</p> <pre><code>from lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\n# Create repository and manager (required)\ndevice_repository = DeviceRepository()\ndevice_manager = DeviceManager(device_repository)\n\n# Create server\nserver = EmulatedLifxServer(\n    devices, device_manager, \"127.0.0.1\", 56700\n)\n\n# Use as context manager (recommended)\nasync with server:\n    # Server running\n    pass\n\n# Or manual lifecycle\nawait server.start()\nawait server.stop()\n</code></pre> <p>\ud83d\udc49 Full Server Documentation</p>"},{"location":"library/#3-device-advanced","title":"3. Device (Advanced)","text":"<p>For custom device creation:</p> <pre><code>from lifx_emulator.devices import EmulatedLifxDevice, DeviceState\n\nstate = DeviceState(serial=\"d073d5000001\", label=\"Custom Device\")\ndevice = EmulatedLifxDevice(state)\n</code></pre> <p>\ud83d\udc49 Full Device Documentation</p>"},{"location":"library/#4-product-registry","title":"4. Product Registry","text":"<p>Access official LIFX product definitions:</p> <pre><code>from lifx_emulator.products.registry import get_product, get_registry\n\nproduct = get_product(27)  # LIFX A19\nall_products = get_registry()\n</code></pre> <p>\ud83d\udc49 Full Product Documentation</p>"},{"location":"library/#quick-reference","title":"Quick Reference","text":""},{"location":"library/#creating-devices","title":"Creating Devices","text":"Function Product Description <code>create_color_light()</code> LIFX A19 (27) Standard RGB color light <code>create_color_temperature_light()</code> LIFX Mini White to Warm (50) Variable color temperature <code>create_infrared_light()</code> LIFX A19 Night Vision (29) IR capable light <code>create_hev_light()</code> LIFX Clean (90) HEV cleaning light <code>create_multizone_light()</code> LIFX Z (32) or Beam (38) Linear multizone strip <code>create_tile_device()</code> LIFX Tile (55) Tile matrix <code>create_switch()</code> LIFX Switch (70) Relay-based switch <code>create_device()</code> Any product ID Universal factory"},{"location":"library/#server-context-manager","title":"Server Context Manager","text":"<p>The server can be used as an async context manager:</p> <pre><code>device_manager = DeviceManager(DeviceRepository())\n\nasync with EmulatedLifxServer(\n    devices, device_manager, \"127.0.0.1\", 56700\n) as server:\n    # Server is running\n    # Your test code here\n    pass\n# Server automatically stops\n</code></pre>"},{"location":"library/#server-lifecycle","title":"Server Lifecycle","text":"<p>Manual server lifecycle management:</p> <pre><code>device_manager = DeviceManager(DeviceRepository())\nserver = EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700)\n\nawait server.start()  # Start listening\n# ... do work ...\nawait server.stop()   # Stop server\n</code></pre>"},{"location":"library/#module-structure","title":"Module Structure","text":"<pre><code>lifx_emulator/\n\u251c\u2500\u2500 __init__.py           # Public exports\n\u251c\u2500\u2500 server.py             # EmulatedLifxServer\n\u251c\u2500\u2500 devices/\n\u2502   \u251c\u2500\u2500 device.py         # EmulatedLifxDevice\n\u2502   \u251c\u2500\u2500 states.py         # DeviceState\n\u2502   \u251c\u2500\u2500 manager.py        # DeviceManager\n\u2502   \u2514\u2500\u2500 persistence.py    # DevicePersistenceAsyncFile\n\u251c\u2500\u2500 repositories/\n\u2502   \u251c\u2500\u2500 device_repository.py  # DeviceRepository\n\u2502   \u2514\u2500\u2500 storage_backend.py    # Storage interfaces\n\u251c\u2500\u2500 factories/\n\u2502   \u2514\u2500\u2500 factory.py        # create_* factory functions\n\u251c\u2500\u2500 scenarios/\n\u2502   \u251c\u2500\u2500 manager.py        # HierarchicalScenarioManager\n\u2502   \u2514\u2500\u2500 models.py         # ScenarioConfig\n\u251c\u2500\u2500 protocol/\n\u2502   \u251c\u2500\u2500 header.py         # LifxHeader\n\u2502   \u251c\u2500\u2500 packets.py        # Packet definitions\n\u2502   \u251c\u2500\u2500 protocol_types.py # LightHsbk, etc.\n\u2502   \u2514\u2500\u2500 serializer.py     # Binary serialization\n\u2514\u2500\u2500 products/\n    \u251c\u2500\u2500 registry.py       # Product registry (137+ products)\n    \u2514\u2500\u2500 specs.py          # Product defaults\n</code></pre>"},{"location":"library/#public-exports","title":"Public Exports","text":"<p>The following are exported from <code>lifx_emulator</code>:</p> <pre><code>from lifx_emulator import (\n    # Server\n    EmulatedLifxServer,\n\n    # Device (for advanced usage)\n    EmulatedLifxDevice,\n\n    # Factory functions (recommended)\n    create_color_light,\n    create_color_temperature_light,\n    create_hev_light,\n    create_infrared_light,\n    create_multizone_light,\n    create_tile_device,\n    create_switch,\n    create_device,\n)\n</code></pre>"},{"location":"library/#common-patterns","title":"Common Patterns","text":""},{"location":"library/#basic-test-setup","title":"Basic Test Setup","text":"<pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def test_basic():\n    device = create_color_light(\"d073d5000001\")\n    device_manager = DeviceManager(DeviceRepository())\n\n    async with EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    ) as server:\n        # Your test code using your LIFX library\n        pass\n</code></pre>"},{"location":"library/#multiple-device-types","title":"Multiple Device Types","text":"<pre><code>from lifx_emulator.factories import (\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\ndevices = [\n    create_color_light(\"d073d5000001\"),\n    create_multizone_light(\"d073d8000001\", zone_count=16),\n    create_tile_device(\"d073d9000001\", tile_count=5),\n]\n\ndevice_manager = DeviceManager(DeviceRepository())\n\nasync with EmulatedLifxServer(\n    devices, device_manager, \"127.0.0.1\", 56700\n) as server:\n    # Test with multiple device types\n    pass\n</code></pre>"},{"location":"library/#custom-serials","title":"Custom Serials","text":"<pre><code>devices = [\n    create_color_light(\"cafe00000001\"),\n    create_color_light(\"cafe00000002\"),\n    create_color_light(\"cafe00000003\"),\n]\n</code></pre>"},{"location":"library/#accessing-device-state","title":"Accessing Device State","text":"<pre><code>device = create_color_light(\"d073d5000001\")\n\n# Check initial state\nprint(f\"Label: {device.state.label}\")\nprint(f\"Power: {device.state.power_level}\")\nprint(f\"Color: {device.state.color}\")\n\n# After commands are sent to the device\nprint(f\"New color: {device.state.color}\")\n</code></pre>"},{"location":"library/#next-steps","title":"Next Steps","text":"<ul> <li>Server API - EmulatedLifxServer documentation</li> <li>Device API - EmulatedLifxDevice and DeviceState</li> <li>Factory Functions - All create_* functions</li> <li>Protocol Types - LightHsbk and other types</li> <li>Product Registry - Product database</li> </ul>"},{"location":"library/device/","title":"Device API Reference","text":"<p>Device state management and emulated device implementation.</p> <p>The device module provides the core classes for emulating LIFX devices: <code>DeviceState</code> holds all stateful information, and <code>EmulatedLifxDevice</code> processes incoming LIFX protocol packets and generates appropriate responses.</p>"},{"location":"library/device/#table-of-contents","title":"Table of Contents","text":""},{"location":"library/device/#classes","title":"Classes","text":"<ul> <li>DeviceState</li> <li>EmulatedLifxDevice</li> </ul>"},{"location":"library/device/#key-concepts","title":"Key Concepts","text":"<ul> <li>Capability Flags</li> <li>Testing Scenarios</li> <li>State Access Patterns</li> <li>Packet Processing Flow</li> </ul>"},{"location":"library/device/#devicestate","title":"DeviceState","text":"<p>Dataclass holding all stateful information for an emulated LIFX device.</p> <p><code>DeviceState</code> represents the complete state of a virtual LIFX device, including identity (serial, product ID), current settings (color, power, label), capabilities (color, multizone, matrix, etc.), and feature-specific state (zones, tiles, HEV cycle status).</p>"},{"location":"library/device/#fields","title":"Fields","text":""},{"location":"library/device/#identity","title":"Identity","text":"<ul> <li><code>serial</code> (<code>str</code> = <code>'d073d5123456'</code>) - 12-character hexadecimal device serial number</li> <li><code>mac_address</code> (<code>bytes</code> = <code>bytes.fromhex('d073d5123456')</code>) - 6-byte MAC address (derived from serial)</li> <li><code>vendor</code> (<code>int</code> = <code>1</code>) - LIFX vendor ID (always 1)</li> <li><code>product</code> (<code>int</code> = <code>27</code>) - Product ID (e.g., 27 for A19, 32 for Z strip)</li> <li><code>version_major</code> (<code>int</code> = <code>3</code>) - Firmware major version</li> <li><code>version_minor</code> (<code>int</code> = <code>70</code>) - Firmware minor version</li> </ul>"},{"location":"library/device/#basic-state","title":"Basic State","text":"<ul> <li><code>port</code> (<code>int</code> = <code>56700</code>) - UDP port for communication</li> <li><code>label</code> (<code>str</code> = <code>'Emulated LIFX'</code>) - Device label (max 32 bytes)</li> <li><code>power_level</code> (<code>int</code> = <code>0</code>) - Power state (0=off, 65535=on)</li> <li><code>color</code> (<code>LightHsbk</code>) - Current HSBK color</li> <li><code>uptime_ns</code> (<code>int</code> = <code>0</code>) - Device uptime in nanoseconds</li> <li><code>build_timestamp</code> (<code>int</code>) - Firmware build timestamp (Unix epoch)</li> </ul>"},{"location":"library/device/#capability-flags","title":"Capability Flags","text":"<ul> <li><code>has_color</code> (<code>bool</code> = <code>True</code>) - Supports full RGB color</li> <li><code>has_infrared</code> (<code>bool</code> = <code>False</code>) - Supports infrared (night vision)</li> <li><code>has_multizone</code> (<code>bool</code> = <code>False</code>) - Supports multizone (linear strips)</li> <li><code>has_matrix</code> (<code>bool</code> = <code>False</code>) - Supports matrix (2D tiles)</li> <li><code>has_hev</code> (<code>bool</code> = <code>False</code>) - Supports HEV (germicidal light)</li> </ul>"},{"location":"library/device/#location-group","title":"Location &amp; Group","text":"<ul> <li><code>location_id</code> (<code>bytes</code>) - 16-byte location UUID</li> <li><code>location_label</code> (<code>str</code> = <code>'Test Location'</code>) - Location name</li> <li><code>location_updated_at</code> (<code>int</code>) - Location update timestamp (nanoseconds)</li> <li><code>group_id</code> (<code>bytes</code>) - 16-byte group UUID</li> <li><code>group_label</code> (<code>str</code> = <code>'Test Group'</code>) - Group name</li> <li><code>group_updated_at</code> (<code>int</code>) - Group update timestamp (nanoseconds)</li> </ul>"},{"location":"library/device/#network","title":"Network","text":"<ul> <li><code>wifi_signal</code> (<code>float</code> = <code>-45.0</code>) - WiFi signal strength in dBm</li> </ul>"},{"location":"library/device/#infrared-night-vision","title":"Infrared (Night Vision)","text":"<ul> <li><code>infrared_brightness</code> (<code>int</code> = <code>0</code>) - IR brightness (0-65535)</li> </ul>"},{"location":"library/device/#hev-germicidal-light","title":"HEV (Germicidal Light)","text":"<ul> <li><code>hev_cycle_duration_s</code> (<code>int</code> = <code>7200</code>) - HEV cycle duration in seconds</li> <li><code>hev_cycle_remaining_s</code> (<code>int</code> = <code>0</code>) - Remaining time in current cycle</li> <li><code>hev_cycle_last_power</code> (<code>bool</code> = <code>False</code>) - Last power state before cycle</li> <li><code>hev_indication</code> (<code>bool</code> = <code>True</code>) - Enable visual indication during cycle</li> <li><code>hev_last_result</code> (<code>int</code> = <code>0</code>) - Result of last HEV cycle</li> </ul>"},{"location":"library/device/#multizone-linear-strips","title":"Multizone (Linear Strips)","text":"<ul> <li><code>zone_count</code> (<code>int</code> = <code>0</code>) - Number of zones (0 if not multizone)</li> <li><code>zone_colors</code> (<code>list[LightHsbk]</code> = <code>[]</code>) - Color for each zone</li> </ul>"},{"location":"library/device/#matrix-tiles","title":"Matrix (Tiles)","text":"<ul> <li><code>tile_count</code> (<code>int</code> = <code>0</code>) - Number of tiles in chain</li> <li><code>tile_devices</code> (<code>list[dict]</code> = <code>[]</code>) - Per-tile state (position, colors)</li> <li><code>tile_width</code> (<code>int</code> = <code>8</code>) - Width of each tile in zones</li> <li><code>tile_height</code> (<code>int</code> = <code>8</code>) - Height of each tile in zones</li> </ul>"},{"location":"library/device/#effects-waveforms-animations","title":"Effects (Waveforms &amp; Animations)","text":"<ul> <li><code>waveform_active</code> (<code>bool</code> = <code>False</code>) - Whether a waveform is running</li> <li><code>waveform_type</code> (<code>int</code> = <code>0</code>) - Waveform type (saw, sine, etc.)</li> <li><code>waveform_transient</code> (<code>bool</code> = <code>False</code>) - Return to original color after waveform</li> <li><code>waveform_color</code> (<code>LightHsbk</code>) - Target waveform color</li> <li><code>waveform_period_ms</code> (<code>int</code> = <code>0</code>) - Waveform period in milliseconds</li> <li><code>waveform_cycles</code> (<code>float</code> = <code>0</code>) - Number of cycles (0 = infinite)</li> <li><code>waveform_duty_cycle</code> (<code>int</code> = <code>0</code>) - Duty cycle for pulse waveform</li> <li><code>waveform_skew_ratio</code> (<code>int</code> = <code>0</code>) - Skew ratio for waveform</li> <li><code>multizone_effect_type</code> (<code>int</code> = <code>0</code>) - Multizone effect type (move, etc.)</li> <li><code>multizone_effect_speed</code> (<code>int</code> = <code>5</code>) - Multizone effect speed</li> <li><code>tile_effect_type</code> (<code>int</code> = <code>0</code>) - Tile effect type</li> <li><code>tile_effect_speed</code> (<code>int</code> = <code>5</code>) - Tile effect speed</li> <li><code>tile_effect_palette_count</code> (<code>int</code> = <code>0</code>) - Number of colors in effect palette</li> <li><code>tile_effect_palette</code> (<code>list[LightHsbk]</code> = <code>[]</code>) - Effect palette colors</li> </ul>"},{"location":"library/device/#methods","title":"Methods","text":""},{"location":"library/device/#get_target_bytes-bytes","title":"<code>get_target_bytes() -&gt; bytes</code>","text":"<p>Get the 8-byte target field for this device (6-byte serial + 2 null bytes).</p> <p>Returns: <code>bytes</code> - Target bytes for packet header</p> <p>Example: <pre><code>device_state = DeviceState(serial=\"d073d5000001\")\ntarget = device_state.get_target_bytes()\n# Returns: b'\\xd0\\x73\\xd5\\x00\\x00\\x01\\x00\\x00'\n</code></pre></p>"},{"location":"library/device/#emulatedlifxdevice","title":"EmulatedLifxDevice","text":"<p>Emulated LIFX device that processes protocol packets and manages state.</p> <p><code>EmulatedLifxDevice</code> is the main class for emulating a LIFX device. It receives LIFX protocol packets via <code>process_packet()</code>, updates internal state, and returns appropriate response packets. It supports configurable testing scenarios for error injection, delays, and malformed responses.</p>"},{"location":"library/device/#constructor","title":"Constructor","text":""},{"location":"library/device/#emulatedlifxdevicedevice_state-scenariosnone-storagenone-handler_registrynone","title":"<code>EmulatedLifxDevice(device_state, scenarios=None, storage=None, handler_registry=None)</code>","text":"<p>Create a new emulated LIFX device.</p> <p>Parameters:</p> <ul> <li><code>device_state</code> (<code>DeviceState</code>) - Initial device state</li> <li><code>scenarios</code> (<code>dict | None</code>) - Optional testing scenarios configuration (see Testing Scenarios)</li> <li><code>storage</code> (<code>AsyncDeviceStorage | None</code>) - Optional async persistent storage for state</li> <li><code>handler_registry</code> (<code>HandlerRegistry | None</code>) - Optional custom packet handler registry</li> </ul> <p>Example: <pre><code>from lifx_emulator.devices import DeviceState, EmulatedLifxDevice\n\n# Create basic device\nstate = DeviceState(serial=\"d073d5000001\", product=27, label=\"Living Room\")\ndevice = EmulatedLifxDevice(state)\n\n# Create device with testing scenarios\nscenarios = {\n    \"drop_packets\": {116: 1.0},  # Drop all SetColor packets (100% drop rate)\n    \"response_delays\": {2: 0.5},  # Delay GetService responses by 500ms\n}\ndevice = EmulatedLifxDevice(state, scenarios=scenarios)\n</code></pre></p>"},{"location":"library/device/#methods_1","title":"Methods","text":""},{"location":"library/device/#get_uptime_ns-int","title":"<code>get_uptime_ns() -&gt; int</code>","text":"<p>Calculate current uptime in nanoseconds since device creation.</p> <p>Returns: <code>int</code> - Uptime in nanoseconds</p>"},{"location":"library/device/#should_respondpacket_type-int-bool","title":"<code>should_respond(packet_type: int) -&gt; bool</code>","text":"<p>Check if device should respond to a packet (for testing packet drop scenarios).</p> <p>Parameters: - <code>packet_type</code> (<code>int</code>) - LIFX packet type number</p> <p>Returns: <code>bool</code> - <code>False</code> if packet should be dropped, <code>True</code> otherwise</p>"},{"location":"library/device/#get_response_delaypacket_type-int-float","title":"<code>get_response_delay(packet_type: int) -&gt; float</code>","text":"<p>Get configured response delay for a packet type (for testing timeout scenarios).</p> <p>Parameters: - <code>packet_type</code> (<code>int</code>) - LIFX packet type number</p> <p>Returns: <code>float</code> - Delay in seconds (0.0 if no delay configured)</p>"},{"location":"library/device/#should_send_malformedpacket_type-int-bool","title":"<code>should_send_malformed(packet_type: int) -&gt; bool</code>","text":"<p>Check if response packet should be malformed (for testing error handling).</p> <p>Parameters: - <code>packet_type</code> (<code>int</code>) - LIFX packet type number</p> <p>Returns: <code>bool</code> - <code>True</code> if response should be truncated/corrupted</p>"},{"location":"library/device/#should_send_invalid_fieldspacket_type-int-bool","title":"<code>should_send_invalid_fields(packet_type: int) -&gt; bool</code>","text":"<p>Check if response packet should have invalid field values (all 0xFF bytes).</p> <p>Parameters: - <code>packet_type</code> (<code>int</code>) - LIFX packet type number</p> <p>Returns: <code>bool</code> - <code>True</code> if response fields should be invalid</p>"},{"location":"library/device/#get_firmware_version_override-tupleint-int-none","title":"<code>get_firmware_version_override() -&gt; tuple[int, int] | None</code>","text":"<p>Get firmware version override from scenarios configuration.</p> <p>Returns: <code>tuple[int, int] | None</code> - (major, minor) version tuple or <code>None</code></p>"},{"location":"library/device/#should_send_partial_responsepacket_type-int-bool","title":"<code>should_send_partial_response(packet_type: int) -&gt; bool</code>","text":"<p>Check if multizone/tile response should be partial (incomplete data for testing).</p> <p>Parameters: - <code>packet_type</code> (<code>int</code>) - LIFX packet type number</p> <p>Returns: <code>bool</code> - <code>True</code> if response should be incomplete</p>"},{"location":"library/device/#process_packetheader-lifxheader-packet-any-none-listtuplelifxheader-any","title":"<code>process_packet(header: LifxHeader, packet: Any | None) -&gt; list[tuple[LifxHeader, Any]]</code>","text":"<p>Process an incoming LIFX protocol packet and generate response packets.</p> <p>This is the main entry point for packet processing. It:</p> <ol> <li>Checks if an acknowledgment is required (<code>ack_required</code> flag)</li> <li>Routes the packet to the appropriate handler based on packet type</li> <li>Applies testing scenarios (delays, drops, malformed responses)</li> <li>Returns a list of response packets (header, payload) tuples</li> </ol> <p>Parameters: - <code>header</code> (<code>LifxHeader</code>) - Parsed packet header - <code>packet</code> (<code>Any | None</code>) - Parsed packet payload (None for header-only packets)</p> <p>Returns: <code>list[tuple[LifxHeader, Any]]</code> - List of response packets to send</p> <p>Example: <pre><code>from lifx_emulator.protocol.header import LifxHeader\nfrom lifx_emulator.protocol.packets import Light\n\n# Parse incoming packet\nheader = LifxHeader.unpack(raw_header)\npacket = Light.SetColor.unpack(raw_payload)\n\n# Process and get responses\nresponses = device.process_packet(header, packet)\n\n# Send each response\nfor resp_header, resp_packet in responses:\n    raw_response = resp_header.pack() + resp_packet.pack()\n    sock.sendto(raw_response, client_address)\n</code></pre></p>"},{"location":"library/device/#capability-flags_1","title":"Capability Flags","text":"<p>Capability flags in <code>DeviceState</code> determine which features the device supports and which packet types it can handle.</p> Flag Description Example Products Supported Packets <code>has_color</code> Full RGB color control A19 (27), BR30 (43), GU10 (66) <code>Light.Get</code>, <code>Light.SetColor</code>, <code>Light.State</code> <code>has_infrared</code> Night vision IR capability A19 Night Vision (29), BR30 NV (44) <code>Light.GetInfrared</code>, <code>Light.SetInfrared</code>, <code>Light.StateInfrared</code> <code>has_multizone</code> Linear zone control (strips) LIFX Z (32), Beam (38) <code>MultiZone.GetColorZones</code>, <code>MultiZone.SetColorZones</code>, <code>MultiZone.StateZone</code>, <code>MultiZone.StateMultiZone</code> <code>has_matrix</code> 2D tile/matrix control Tile (55), Candle (57), Ceiling (176) <code>Tile.GetDeviceChain</code>, <code>Tile.Get64</code>, <code>Tile.Set64</code>, <code>Tile.StateDeviceChain</code>, <code>Tile.State64</code> <code>has_hev</code> Germicidal UV-C light LIFX Clean (90) <code>Hev.GetCycle</code>, <code>Hev.SetCycle</code>, <code>Hev.StateCycle</code> <p>Notes: - Devices without a capability flag will ignore related packets - Most devices have <code>has_color=True</code> (except switches and relays) - Extended multizone (&gt;16 zones) is indicated by <code>zone_count &gt; 16</code> - Matrix devices store tile data in <code>tile_devices</code> list</p> <p>Example: <pre><code># Create a multizone device\nstate = DeviceState(\n    serial=\"d073d5000002\",\n    product=32,  # LIFX Z\n    has_multizone=True,\n    zone_count=16,\n    zone_colors=[LightHsbk(hue=0, saturation=65535, brightness=32768, kelvin=3500) for _ in range(16)]\n)\n\n# Create a tile device\nstate = DeviceState(\n    serial=\"d073d5000003\",\n    product=55,  # LIFX Tile\n    has_matrix=True,\n    tile_count=5,\n    tile_width=8,\n    tile_height=8,\n)\n</code></pre></p>"},{"location":"library/device/#testing-scenarios","title":"Testing Scenarios","text":"<p>The <code>scenarios</code> parameter allows you to configure error injection and testing behaviors for emulated devices. This is useful for testing client library error handling, timeouts, and edge cases.</p>"},{"location":"library/device/#available-scenarios","title":"Available Scenarios","text":"Scenario Type Description Example <code>drop_packets</code> <code>dict[int, float]</code> Packet types to drop with rates (0.0-1.0) <code>{116: 1.0, 117: 0.5}</code> - Always drop 116, drop 117 50% <code>response_delays</code> <code>dict[int, float]</code> Delay (seconds) before responding to packet type <code>{2: 1.5}</code> - Delay GetService by 1.5s <code>malformed_packets</code> <code>list[int]</code> Packet types to send truncated/corrupted <code>[107]</code> - Corrupt State packets <code>invalid_field_values</code> <code>list[int]</code> Packet types to send with invalid fields (0xFF) <code>[107]</code> - Invalid State values <code>partial_responses</code> <code>list[int]</code> Multizone/tile packets to send incomplete <code>[506]</code> - Partial zone data <code>firmware_version</code> <code>tuple[int, int]</code> Override firmware version <code>(2, 80)</code> - Report v2.80"},{"location":"library/device/#examples","title":"Examples","text":"<p>Simulate network issues: <pre><code>scenarios = {\n    \"drop_packets\": {2: 1.0},  # Drop all GetService packets - simulate discovery failure\n    \"response_delays\": {116: 2.0},  # Delay SetColor by 2 seconds\n}\ndevice = EmulatedLifxDevice(state, scenarios=scenarios)\n</code></pre></p> <p>Test error handling: <pre><code>scenarios = {\n    \"malformed_packets\": [107],  # Corrupt Light.State responses\n    \"invalid_field_values\": [118],  # Invalid Light.StatePower values\n}\ndevice = EmulatedLifxDevice(state, scenarios=scenarios)\n</code></pre></p> <p>Test multizone edge cases: <pre><code>scenarios = {\n    \"partial_responses\": [506],  # Send incomplete StateMultiZone packets\n}\ndevice = EmulatedLifxDevice(state, scenarios=scenarios)\n</code></pre></p> <p>Test firmware compatibility: <pre><code>scenarios = {\n    \"firmware_version\": (2, 77),  # Report older firmware version\n}\ndevice = EmulatedLifxDevice(state, scenarios=scenarios)\n</code></pre></p>"},{"location":"library/device/#state-access-patterns","title":"State Access Patterns","text":""},{"location":"library/device/#reading-state","title":"Reading State","text":"<p>Access device state directly through the <code>state</code> attribute:</p> <pre><code>device = EmulatedLifxDevice(state)\n\n# Check power\nif device.state.power_level == 65535:\n    print(\"Device is on\")\n\n# Check color\nprint(f\"Hue: {device.state.color.hue}\")\nprint(f\"Brightness: {device.state.color.brightness}\")\n\n# Check zones (multizone)\nif device.state.has_multizone:\n    for i, color in enumerate(device.state.zone_colors):\n        print(f\"Zone {i}: {color}\")\n</code></pre>"},{"location":"library/device/#modifying-state","title":"Modifying State","text":"<p>Modify state fields directly and optionally save to persistent storage:</p> <pre><code># Change color\ndevice.state.color = LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500)\n\n# Change label\ndevice.state.label = \"Kitchen Light\"\n\n# Power on\ndevice.state.power_level = 65535\n\n# Save to persistent storage (if configured)\n# State changes are automatically queued for async save\n# If needed, manually queue a save:\n# await device.storage.save_device_state(device.state)\n</code></pre>"},{"location":"library/device/#persistent-storage-integration","title":"Persistent Storage Integration","text":"<p>Use <code>AsyncDeviceStorage</code> to persist state across restarts:</p> <pre><code>import asyncio\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\nasync def main():\n    storage = AsyncDeviceStorage()  # Uses ~/.lifx-emulator by default\n    device = EmulatedLifxDevice(state, storage=storage)\n\n    # State changes are automatically queued for async save\n    # Manual async save:\n    await storage.save_device_state(device.state)\n\n    # On next run, state is automatically restored\n\nasyncio.run(main())\nrestored_device = EmulatedLifxDevice(DeviceState(serial=state.serial), storage=storage)\n# restored_device.state.label == \"Kitchen Light\"\n</code></pre>"},{"location":"library/device/#packet-processing-flow","title":"Packet Processing Flow","text":"<p>The packet processing flow in <code>EmulatedLifxDevice.process_packet()</code> follows these steps:</p> <pre><code>graph TD\n    A[Incoming Packet] --&gt; B{ack_required?}\n    B --&gt;|Yes| C[Add Acknowledgment]\n    B --&gt;|No| D{res_required?}\n\n    D --&gt;|Yes| E[Route to Handler]\n    D --&gt;|No| F[Route to Handler]\n\n    E --&gt; G{Handler Returns Response?}\n    F --&gt; H{Handler Returns Response?}\n\n    G --&gt;|Yes| I[Apply Scenarios]\n    G --&gt;|No| J[Return Responses]\n\n    H --&gt;|Yes| I\n    H --&gt;|No| J\n\n    I --&gt; K{Drop Packet?}\n    K --&gt;|Yes| L[Return Empty]\n    K --&gt;|No| M{Delay?}\n\n    M --&gt;|Yes| N[Wait Delay Time]\n    M --&gt;|No| O{Malformed?}\n\n    N --&gt; O\n    O --&gt;|Yes| P[Truncate Packet]\n    O --&gt;|No| Q{Invalid Fields?}\n\n    P --&gt; J\n    Q --&gt;|Yes| R[Set Fields to 0xFF]\n    Q --&gt;|No| J\n\n    R --&gt; J\n    C --&gt; J\n    J[Return Responses]</code></pre> <p>Key Points: - Acknowledgments (packet type 45) are sent when <code>ack_required=True</code> in header - Response packets are sent when <code>res_required=True</code> in header - Handlers are registered by packet type and dispatched via <code>HandlerRegistry</code> - Testing scenarios are applied after handler execution, before returning responses - Multiple response packets may be returned (e.g., multizone queries return multiple <code>StateMultiZone</code> packets)</p> <p>See Also: - EmulatedLifxServer - UDP server that routes packets to devices - Protocol Packets - LIFX protocol packet definitions - Factories - Helper functions for creating pre-configured devices - Storage - Persistent state storage API</p>"},{"location":"library/device/#references","title":"References","text":"<p>Source: <code>src/lifx_emulator/device.py</code></p> <p>Related Documentation: - Getting Started - Quick start guide - Device Types - Supported device types and capabilities - Testing Scenarios - Detailed testing scenario guide - Architecture Overview - System architecture</p>"},{"location":"library/factories/","title":"Factory Functions","text":"<p>Factory functions provide the easiest way to create emulated LIFX devices with sensible defaults.</p>"},{"location":"library/factories/#overview","title":"Overview","text":"<p>All factory functions return an <code>EmulatedLifxDevice</code> instance configured for a specific product type. They automatically load product-specific defaults (like zone counts and tile dimensions) from the product registry.</p> <p>Device factory for creating emulated LIFX devices.</p> <p>This package provides a clean, testable API for creating LIFX devices using: - Builder pattern for flexible device construction - Separate services for serial generation, color config, firmware config - Product registry integration for accurate device specifications</p> FUNCTION DESCRIPTION <code>create_color_light</code> <p>Create a regular color light (LIFX Color)</p> <code>create_color_temperature_light</code> <p>Create a color temperature light (LIFX Mini White to Warm).</p> <code>create_infrared_light</code> <p>Create an infrared-enabled light (LIFX A19 Night Vision)</p> <code>create_hev_light</code> <p>Create an HEV-enabled light (LIFX Clean)</p> <code>create_multizone_light</code> <p>Create a multizone light (LIFX Beam)</p> <code>create_tile_device</code> <p>Create a tile device (LIFX Tile)</p> <code>create_device</code> <p>Create a device for any LIFX product using the product registry.</p>"},{"location":"library/factories/#lifx_emulator.factories-functions","title":"Functions","text":""},{"location":"library/factories/#lifx_emulator.factories.create_color_light","title":"create_color_light","text":"<pre><code>create_color_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create a regular color light (LIFX Color)</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_color_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create a regular color light (LIFX Color)\"\"\"\n    return create_device(\n        91,\n        serial=serial,\n        firmware_version=firmware_version,\n        storage=storage,\n        scenario_manager=scenario_manager,\n    )  # LIFX Color\n</code></pre>"},{"location":"library/factories/#lifx_emulator.factories.create_color_temperature_light","title":"create_color_temperature_light","text":"<pre><code>create_color_temperature_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create a color temperature light (LIFX Mini White to Warm).</p> <p>Variable color temperature, no RGB.</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_color_temperature_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create a color temperature light (LIFX Mini White to Warm).\n\n    Variable color temperature, no RGB.\n    \"\"\"\n    return create_device(\n        50,\n        serial=serial,\n        firmware_version=firmware_version,\n        storage=storage,\n        scenario_manager=scenario_manager,\n    )  # LIFX Mini White to Warm\n</code></pre>"},{"location":"library/factories/#lifx_emulator.factories.create_infrared_light","title":"create_infrared_light","text":"<pre><code>create_infrared_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create an infrared-enabled light (LIFX A19 Night Vision)</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_infrared_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create an infrared-enabled light (LIFX A19 Night Vision)\"\"\"\n    return create_device(\n        29,\n        serial=serial,\n        firmware_version=firmware_version,\n        storage=storage,\n        scenario_manager=scenario_manager,\n    )  # LIFX A19 Night Vision\n</code></pre>"},{"location":"library/factories/#lifx_emulator.factories.create_hev_light","title":"create_hev_light","text":"<pre><code>create_hev_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create an HEV-enabled light (LIFX Clean)</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_hev_light(\n    serial: str | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create an HEV-enabled light (LIFX Clean)\"\"\"\n    return create_device(\n        90,\n        serial=serial,\n        firmware_version=firmware_version,\n        storage=storage,\n        scenario_manager=scenario_manager,\n    )  # LIFX Clean\n</code></pre>"},{"location":"library/factories/#lifx_emulator.factories.create_multizone_light","title":"create_multizone_light","text":"<pre><code>create_multizone_light(\n    serial: str | None = None,\n    zone_count: int | None = None,\n    extended_multizone: bool = True,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create a multizone light (LIFX Beam)</p> PARAMETER DESCRIPTION <code>serial</code> <p>Optional serial</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>zone_count</code> <p>Optional zone count (uses product default if not specified)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>extended_multizone</code> <p>enables support for extended multizone requests</p> <p> TYPE: <code>bool</code> DEFAULT: <code>True</code> </p> <code>firmware_version</code> <p>Optional firmware version tuple (major, minor)</p> <p> TYPE: <code>tuple[int, int] | None</code> DEFAULT: <code>None</code> </p> <code>storage</code> <p>Optional storage for persistence</p> <p> TYPE: <code>DevicePersistenceAsyncFile | None</code> DEFAULT: <code>None</code> </p> <code>scenario_manager</code> <p>Optional scenario manager</p> <p> TYPE: <code>HierarchicalScenarioManager | None</code> DEFAULT: <code>None</code> </p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_multizone_light(\n    serial: str | None = None,\n    zone_count: int | None = None,\n    extended_multizone: bool = True,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create a multizone light (LIFX Beam)\n\n    Args:\n        serial: Optional serial\n        zone_count: Optional zone count (uses product default if not specified)\n        extended_multizone: enables support for extended multizone requests\n        firmware_version: Optional firmware version tuple (major, minor)\n        storage: Optional storage for persistence\n        scenario_manager: Optional scenario manager\n    \"\"\"\n    return create_device(\n        38,\n        serial=serial,\n        zone_count=zone_count,\n        extended_multizone=extended_multizone,\n        firmware_version=firmware_version,\n        storage=storage,\n        scenario_manager=scenario_manager,\n    )\n</code></pre>"},{"location":"library/factories/#lifx_emulator.factories.create_tile_device","title":"create_tile_device","text":"<pre><code>create_tile_device(\n    serial: str | None = None,\n    tile_count: int | None = None,\n    tile_width: int | None = None,\n    tile_height: int | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create a tile device (LIFX Tile)</p> PARAMETER DESCRIPTION <code>serial</code> <p>Optional serial</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>tile_count</code> <p>Optional tile count (uses product default)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>tile_width</code> <p>Optional tile width in zones (uses product default)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>tile_height</code> <p>Optional tile height in zones (uses product default)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>firmware_version</code> <p>Optional firmware version tuple (major, minor)</p> <p> TYPE: <code>tuple[int, int] | None</code> DEFAULT: <code>None</code> </p> <code>storage</code> <p>Optional storage for persistence</p> <p> TYPE: <code>DevicePersistenceAsyncFile | None</code> DEFAULT: <code>None</code> </p> <code>scenario_manager</code> <p>Optional scenario manager</p> <p> TYPE: <code>HierarchicalScenarioManager | None</code> DEFAULT: <code>None</code> </p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_tile_device(\n    serial: str | None = None,\n    tile_count: int | None = None,\n    tile_width: int | None = None,\n    tile_height: int | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create a tile device (LIFX Tile)\n\n    Args:\n        serial: Optional serial\n        tile_count: Optional tile count (uses product default)\n        tile_width: Optional tile width in zones (uses product default)\n        tile_height: Optional tile height in zones (uses product default)\n        firmware_version: Optional firmware version tuple (major, minor)\n        storage: Optional storage for persistence\n        scenario_manager: Optional scenario manager\n    \"\"\"\n    return create_device(\n        55,\n        serial=serial,\n        tile_count=tile_count,\n        tile_width=tile_width,\n        tile_height=tile_height,\n        firmware_version=firmware_version,\n        storage=storage,\n        scenario_manager=scenario_manager,\n    )  # LIFX Tile\n</code></pre>"},{"location":"library/factories/#lifx_emulator.factories.create_device","title":"create_device","text":"<pre><code>create_device(\n    product_id: int,\n    serial: str | None = None,\n    zone_count: int | None = None,\n    extended_multizone: bool | None = None,\n    tile_count: int | None = None,\n    tile_width: int | None = None,\n    tile_height: int | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice\n</code></pre> <p>Create a device for any LIFX product using the product registry.</p> <p>This function uses the DeviceBuilder pattern to construct devices with clean separation of concerns and testable components.</p> PARAMETER DESCRIPTION <code>product_id</code> <p>Product ID from the LIFX product registry</p> <p> TYPE: <code>int</code> </p> <code>serial</code> <p>Optional serial (auto-generated if not provided)</p> <p> TYPE: <code>str | None</code> DEFAULT: <code>None</code> </p> <code>zone_count</code> <p>Number of zones for multizone devices (auto-determined)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>extended_multizone</code> <p>Enable extended multizone requests</p> <p> TYPE: <code>bool | None</code> DEFAULT: <code>None</code> </p> <code>tile_count</code> <p>Number of tiles for matrix devices (default: 5)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>tile_width</code> <p>Width of each tile in zones (default: 8)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>tile_height</code> <p>Height of each tile in zones (default: 8)</p> <p> TYPE: <code>int | None</code> DEFAULT: <code>None</code> </p> <code>firmware_version</code> <p>Optional firmware version tuple (major, minor).              If not specified, uses 3.70 for extended_multizone              or 2.60 otherwise</p> <p> TYPE: <code>tuple[int, int] | None</code> DEFAULT: <code>None</code> </p> <code>storage</code> <p>Optional storage for persistence</p> <p> TYPE: <code>DevicePersistenceAsyncFile | None</code> DEFAULT: <code>None</code> </p> <code>scenario_manager</code> <p>Optional scenario manager for testing</p> <p> TYPE: <code>HierarchicalScenarioManager | None</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>EmulatedLifxDevice</code> <p>EmulatedLifxDevice configured for the specified product</p> RAISES DESCRIPTION <code>ValueError</code> <p>If product_id is not found in registry</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Create LIFX A19 (PID 27)\n&gt;&gt;&gt; device = create_device(27)\n&gt;&gt;&gt; # Create LIFX Z strip (PID 32) with 24 zones\n&gt;&gt;&gt; strip = create_device(32, zone_count=24)\n&gt;&gt;&gt; # Create LIFX Tile (PID 55) with 10 tiles\n&gt;&gt;&gt; tiles = create_device(55, tile_count=10)\n</code></pre> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/factories/factory.py</code> <pre><code>def create_device(\n    product_id: int,\n    serial: str | None = None,\n    zone_count: int | None = None,\n    extended_multizone: bool | None = None,\n    tile_count: int | None = None,\n    tile_width: int | None = None,\n    tile_height: int | None = None,\n    firmware_version: tuple[int, int] | None = None,\n    storage: DevicePersistenceAsyncFile | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n) -&gt; EmulatedLifxDevice:\n    \"\"\"Create a device for any LIFX product using the product registry.\n\n    This function uses the DeviceBuilder pattern to construct devices with\n    clean separation of concerns and testable components.\n\n    Args:\n        product_id: Product ID from the LIFX product registry\n        serial: Optional serial (auto-generated if not provided)\n        zone_count: Number of zones for multizone devices (auto-determined)\n        extended_multizone: Enable extended multizone requests\n        tile_count: Number of tiles for matrix devices (default: 5)\n        tile_width: Width of each tile in zones (default: 8)\n        tile_height: Height of each tile in zones (default: 8)\n        firmware_version: Optional firmware version tuple (major, minor).\n                         If not specified, uses 3.70 for extended_multizone\n                         or 2.60 otherwise\n        storage: Optional storage for persistence\n        scenario_manager: Optional scenario manager for testing\n\n    Returns:\n        EmulatedLifxDevice configured for the specified product\n\n    Raises:\n        ValueError: If product_id is not found in registry\n\n    Examples:\n        &gt;&gt;&gt; # Create LIFX A19 (PID 27)\n        &gt;&gt;&gt; device = create_device(27)\n        &gt;&gt;&gt; # Create LIFX Z strip (PID 32) with 24 zones\n        &gt;&gt;&gt; strip = create_device(32, zone_count=24)\n        &gt;&gt;&gt; # Create LIFX Tile (PID 55) with 10 tiles\n        &gt;&gt;&gt; tiles = create_device(55, tile_count=10)\n    \"\"\"\n    # Get product info from registry\n    product_info = get_product(product_id)\n    if product_info is None:\n        raise ValueError(f\"Unknown product ID: {product_id}\")\n\n    # Build device using builder pattern\n    builder = DeviceBuilder(product_info)\n\n    if serial is not None:\n        builder.with_serial(serial)\n\n    if zone_count is not None:\n        builder.with_zone_count(zone_count)\n\n    if extended_multizone is not None:\n        builder.with_extended_multizone(extended_multizone)\n\n    if tile_count is not None:\n        builder.with_tile_count(tile_count)\n\n    if tile_width is not None and tile_height is not None:\n        builder.with_tile_dimensions(tile_width, tile_height)\n\n    if firmware_version is not None:\n        builder.with_firmware_version(*firmware_version)\n\n    if storage is not None:\n        builder.with_storage(storage)\n\n    if scenario_manager is not None:\n        builder.with_scenario_manager(scenario_manager)\n\n    return builder.build()\n</code></pre>"},{"location":"library/factories/#usage-examples","title":"Usage Examples","text":""},{"location":"library/factories/#color-light","title":"Color Light","text":"<p>Create a standard RGB color light (LIFX A19):</p> <pre><code>from lifx_emulator import create_color_light\n\n# Auto-generated serial\ndevice = create_color_light()\n\n# Custom serial\ndevice = create_color_light(\"d073d5000001\")\n\n# Access state\nprint(f\"Label: {device.state.label}\")\nprint(f\"Product: {device.state.product}\")  # 27 (LIFX A19)\nprint(f\"Has color: {device.state.has_color}\")  # True\n</code></pre>"},{"location":"library/factories/#color-temperature-light","title":"Color Temperature Light","text":"<p>Create a white light with variable color temperature:</p> <pre><code>from lifx_emulator import create_color_temperature_light\n\ndevice = create_color_temperature_light(\"d073d5000001\")\n\nprint(f\"Has color: {device.state.has_color}\")  # False\nprint(f\"Product: {device.state.product}\")  # 50 (LIFX Mini White to Warm)\n</code></pre>"},{"location":"library/factories/#infrared-light","title":"Infrared Light","text":"<p>Create a light with infrared capability:</p> <pre><code>from lifx_emulator import create_infrared_light\n\ndevice = create_infrared_light(\"d073d5000002\")\n\nprint(f\"Has infrared: {device.state.has_infrared}\")  # True\nprint(f\"Product: {device.state.product}\")  # 29 (LIFX A19 Night Vision)\nprint(f\"IR brightness: {device.state.infrared_brightness}\")  # 16384 (25%)\n</code></pre>"},{"location":"library/factories/#hev-light","title":"HEV Light","text":"<p>Create a light with HEV cleaning capability:</p> <pre><code>from lifx_emulator import create_hev_light\n\ndevice = create_hev_light(\"d073d5000003\")\n\nprint(f\"Has HEV: {device.state.has_hev}\")  # True\nprint(f\"Product: {device.state.product}\")  # 90 (LIFX Clean)\nprint(f\"HEV cycle duration: {device.state.hev_cycle_duration_s}\")  # 7200 (2 hours)\n</code></pre>"},{"location":"library/factories/#multizone-light","title":"Multizone Light","text":"<p>Create a linear multizone device (strip or beam):</p> <pre><code>from lifx_emulator import create_multizone_light\n\n# Standard LIFX Z with default 16 zones\nstrip = create_multizone_light(\"d073d8000001\")\n\n# Custom zone count\nstrip_custom = create_multizone_light(\"d073d8000002\", zone_count=24)\n\n# Extended multizone (LIFX Beam) with default 80 zones\nbeam = create_multizone_light(\"d073d8000003\", extended_multizone=True)\n\n# Custom extended multizone\nbeam_custom = create_multizone_light(\n    \"d073d8000004\",\n    zone_count=60,\n    extended_multizone=True\n)\n\nprint(f\"Strip zones: {strip.state.zone_count}\")  # 16\nprint(f\"Beam zones: {beam.state.zone_count}\")   # 80\nprint(f\"Strip product: {strip.state.product}\")  # 32 (LIFX Z)\nprint(f\"Beam product: {beam.state.product}\")    # 38 (LIFX Beam)\n</code></pre>"},{"location":"library/factories/#tile-device","title":"Tile Device","text":"<p>Create a matrix tile device:</p> <pre><code>from lifx_emulator import create_tile_device\n\n# Default configuration (5 tiles of 8x8)\ntiles = create_tile_device(\"d073d9000001\")\n\n# Custom tile count\ntiles_custom = create_tile_device(\"d073d9000002\", tile_count=10)\n\n# Custom tile dimensions (e.g., 16x8 with &gt;64 zones per tile)\nlarge_tile = create_tile_device(\n    \"d073d9000003\",\n    tile_count=1,\n    tile_width=16,\n    tile_height=8\n)\n\nprint(f\"Tile count: {tiles.state.tile_count}\")      # 5\nprint(f\"Tile width: {tiles.state.tile_width}\")      # 8\nprint(f\"Tile height: {tiles.state.tile_height}\")    # 8\nprint(f\"Product: {tiles.state.product}\")            # 55 (LIFX Tile)\n\n# Tiles with &gt;64 zones require multiple Get64 requests (16x8 = 128 zones)\nprint(f\"Large tile zones: {large_tile.state.tile_width * large_tile.state.tile_height}\")  # 128\n</code></pre>"},{"location":"library/factories/#generic-device-creation","title":"Generic Device Creation","text":"<p>Create any device by product ID:</p> <pre><code>from lifx_emulator.factories import create_device\n\n# LIFX A19 (product ID 27)\na19 = create_device(27, serial=\"d073d5000001\")\n\n# LIFX Z (product ID 32) with custom zones\nz_strip = create_device(32, serial=\"d073d8000001\", zone_count=24)\n\n# LIFX Tile (product ID 55) with custom configuration\ntiles = create_device(\n    55,\n    serial=\"d073d9000001\",\n    tile_count=10,\n    tile_width=8,\n    tile_height=8\n)\n\n# LIFX Candle (product ID 57) - loads 5x6 dimensions from product defaults\ncandle = create_device(57, serial=\"d073d9000002\")\nprint(f\"Candle size: {candle.state.tile_width}x{candle.state.tile_height}\")  # 5x6\n</code></pre>"},{"location":"library/factories/#serial-format","title":"Serial Format","text":"<p>Serials must be 12 hex characters (6 bytes):</p> <pre><code># Valid formats\ndevice = create_color_light(\"d073d5000001\")  # Serial with LIFX prefix (\"d073d5\")\ndevice = create_color_light(\"cafe00abcdef\")  # Serial with custom prefix\ndevice = create_color_light()                # Auto-generate serial\n\n# Invalid (will raise error)\ndevice = create_color_light(\"123\")           # Too short\ndevice = create_color_light(\"xyz\")           # Not hex\n</code></pre> <p>Auto-generated serials use prefixes based on device type:</p> <ul> <li><code>d073d5</code> - Regular lights</li> <li><code>d073d6</code> - Infrared lights</li> <li><code>d073d7</code> - HEV lights</li> <li><code>d073d8</code> - Multizone strips/beams</li> <li><code>d073d9</code> - Matrix tiles</li> </ul>"},{"location":"library/factories/#product-defaults","title":"Product Defaults","text":"<p>When parameters like <code>zone_count</code> or <code>tile_count</code> are not specified, the factory functions automatically load defaults from the product registry's specs system:</p> <pre><code># Uses product default (16 zones for LIFX Z)\nstrip = create_multizone_light(\"d073d8000001\")\n\n# Uses product default (80 zones for LIFX Beam)\nbeam = create_multizone_light(\"d073d8000002\", extended_multizone=True)\n\n# Uses product default (5 tiles for LIFX Tile)\ntiles = create_tile_device(\"d073d9000001\")\n\n# Uses product default (5x6 for LIFX Candle)\ncandle = create_device(57, serial=\"d073d9000002\")\n</code></pre> <p>See Product Registry for all product definitions and defaults.</p>"},{"location":"library/factories/#device-state-access","title":"Device State Access","text":"<p>After creation, access device state:</p> <pre><code>device = create_color_light(\"d073d5000001\")\n\n# Device identity\nprint(device.state.serial)          # \"d073d5000001\"\nprint(device.state.label)           # \"A19 d073d5\"\nprint(device.state.vendor)          # 1 (LIFX)\nprint(device.state.product)         # 27 (LIFX A19)\n\n# Device capabilities\nprint(device.state.has_color)       # True\nprint(device.state.has_infrared)    # False\nprint(device.state.has_multizone)   # False\nprint(device.state.has_matrix)      # False\nprint(device.state.has_hev)         # False\n\n# Light state\nprint(device.state.power_level)     # 65535 (on)\nprint(device.state.color)           # LightHsbk(...)\nprint(device.state.port)            # 56700 (default)\n\n# Firmware version\nprint(device.state.version_major)   # 2\nprint(device.state.version_minor)   # 80\n</code></pre>"},{"location":"library/factories/#multiple-devices","title":"Multiple Devices","text":"<p>Create multiple devices for testing:</p> <pre><code>from lifx_emulator import (\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n    EmulatedLifxServer,\n)\n\n# Create a diverse set of devices\ndevices = [\n    create_color_light(\"d073d5000001\"),\n    create_color_light(\"d073d5000002\"),\n    create_multizone_light(\"d073d8000001\", zone_count=16),\n    create_multizone_light(\"d073d8000002\", zone_count=82, extended_multizone=True),\n    create_tile_device(\"d073d9000001\", tile_count=5),\n]\n\n# Start server with all devices\nserver = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\nawait server.start()\n</code></pre>"},{"location":"library/factories/#advanced-options","title":"Advanced Options","text":""},{"location":"library/factories/#persistent-storage","title":"Persistent Storage","text":"<p>Devices can automatically persist state across restarts:</p> <pre><code>from lifx_emulator import create_color_light\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\n# Create storage (uses ~/.lifx-emulator by default)\nstorage = AsyncDeviceStorage()\n\n# Create device with storage enabled\ndevice = create_color_light(\"d073d5000001\", storage=storage)\n\n# State changes are automatically saved asynchronously\ndevice.state.label = \"My Light\"\n\n# On next run, state is automatically restored from disk\n</code></pre>"},{"location":"library/factories/#test-scenarios","title":"Test Scenarios","text":"<p>Inject test scenarios (packet loss, delays, etc.) for error testing:</p> <pre><code>from lifx_emulator import create_color_light\nfrom lifx_emulator.scenarios.manager import HierarchicalScenarioManager, ScenarioConfig\n\n# Create scenario manager\nmanager = HierarchicalScenarioManager()\n\n# Create device with scenario support\ndevice = create_color_light(\"d073d5000001\", scenario_manager=manager)\n\n# Configure scenarios for testing error handling\nmanager.set_device_scenario(\n    device.state.serial,\n    ScenarioConfig(\n        drop_packets={101: 0.3},  # Drop 30% of GetColor packets\n        response_delays={102: 0.5},  # Add 500ms delay to SetColor\n    )\n)\n</code></pre>"},{"location":"library/factories/#custom-firmware-versions","title":"Custom Firmware Versions","text":"<p>Override firmware version for compatibility testing:</p> <pre><code>from lifx_emulator import create_color_light\n\n# Simulate older firmware\nold_device = create_color_light(\n    \"d073d5000001\",\n    firmware_version=(2, 60)\n)\n\n# Simulate newer firmware\nnew_device = create_color_light(\n    \"d073d5000002\",\n    firmware_version=(3, 90)\n)\n</code></pre>"},{"location":"library/factories/#next-steps","title":"Next Steps","text":"<ul> <li>Server API - Running the emulator server</li> <li>Device API - Device and state details</li> <li>Product Registry - All available products</li> <li>Basic Tutorial - Complete usage examples</li> </ul>"},{"location":"library/products/","title":"Products API Reference","text":"<p>LIFX product registry and capability detection</p> <p>The products module provides auto-generated product definitions from the official LIFX product registry, including product IDs, capabilities, temperature ranges, and device specifications. This enables accurate emulation of specific LIFX device types.</p>"},{"location":"library/products/#table-of-contents","title":"Table of Contents","text":""},{"location":"library/products/#core-components","title":"Core Components","text":"<ul> <li>ProductInfo - Product metadata and capabilities</li> <li>ProductCapability - Capability flags enum</li> <li>Product Registry - Accessing product database</li> <li>ProductSpecs - Device-specific specifications</li> </ul>"},{"location":"library/products/#concepts","title":"Concepts","text":"<ul> <li>Capability Matrix - Complete product capabilities</li> <li>Product Filtering - Query products by capability</li> <li>Using Products - Creating devices from products</li> </ul>"},{"location":"library/products/#productinfo","title":"ProductInfo","text":"<p>Dataclass containing complete information about a LIFX product.</p> <pre><code>@dataclass\nclass ProductInfo:\n    pid: int                              # Product ID\n    name: str                             # Product name (e.g., \"LIFX A19\")\n    vendor: int                           # Vendor ID (always 1 for LIFX)\n    capabilities: int                     # Bitfield of capabilities\n    temperature_range: TemperatureRange | None  # Min/max Kelvin\n    min_ext_mz_firmware: int | None       # Min firmware for extended multizone\n</code></pre>"},{"location":"library/products/#fields","title":"Fields","text":""},{"location":"library/products/#pid-int","title":"<code>pid</code> (int)","text":"<p>Product ID number. Common examples:</p> <ul> <li><code>27</code>: LIFX A19</li> <li><code>32</code>: LIFX Z (multizone strip)</li> <li><code>38</code>: LIFX Beam (extended multizone)</li> <li><code>55</code>: LIFX Tile</li> <li><code>90</code>: LIFX Clean (HEV)</li> </ul>"},{"location":"library/products/#name-str","title":"<code>name</code> (str)","text":"<p>Human-readable product name (e.g., \"LIFX A19\", \"LIFX Z\", \"LIFX Tile\").</p>"},{"location":"library/products/#vendor-int","title":"<code>vendor</code> (int)","text":"<p>Vendor ID. Always <code>1</code> for LIFX products.</p>"},{"location":"library/products/#capabilities-int","title":"<code>capabilities</code> (int)","text":"<p>Bitfield of <code>ProductCapability</code> flags. Use <code>has_capability()</code> or property methods to check.</p>"},{"location":"library/products/#temperature_range-temperaturerange-none","title":"<code>temperature_range</code> (TemperatureRange | None)","text":"<p>Supported color temperature range in Kelvin.</p> <ul> <li><code>min</code>: Minimum Kelvin (e.g., 2500 for warm white)</li> <li><code>max</code>: Maximum Kelvin (e.g., 9000 for cool white)</li> <li><code>None</code> for non-color-temperature devices (relays, switches)</li> </ul>"},{"location":"library/products/#min_ext_mz_firmware-int-none","title":"<code>min_ext_mz_firmware</code> (int | None)","text":"<p>Minimum firmware version required for extended multizone support (&gt;16 zones).</p> <ul> <li><code>None</code> if not applicable or always supported</li> </ul>"},{"location":"library/products/#methods","title":"Methods","text":""},{"location":"library/products/#has_capabilitycapability-productcapability-bool","title":"<code>has_capability(capability: ProductCapability) -&gt; bool</code>","text":"<p>Check if product has a specific capability.</p> <p>Parameters: - <code>capability</code> (<code>ProductCapability</code>) - Capability to check</p> <p>Returns: <code>bool</code> - <code>True</code> if product has the capability</p> <p>Example: <pre><code>from lifx_emulator.products import get_product, ProductCapability\n\nproduct = get_product(32)  # LIFX Z\nif product.has_capability(ProductCapability.MULTIZONE):\n    print(f\"{product.name} supports multizone\")\n</code></pre></p>"},{"location":"library/products/#property-methods","title":"Property Methods","text":"<p>Convenience properties for common capability checks:</p> <ul> <li><code>has_color</code> \u2192 <code>bool</code> - Full RGB color support</li> <li><code>has_infrared</code> \u2192 <code>bool</code> - Infrared (night vision) support</li> <li><code>has_multizone</code> \u2192 <code>bool</code> - Multizone (linear strips) support</li> <li><code>has_chain</code> \u2192 <code>bool</code> - Device chaining support</li> <li><code>has_matrix</code> \u2192 <code>bool</code> - 2D matrix/tile support</li> <li><code>has_relays</code> \u2192 <code>bool</code> - Relay switches</li> <li><code>has_buttons</code> \u2192 <code>bool</code> - Physical buttons</li> <li><code>has_hev</code> \u2192 <code>bool</code> - HEV (germicidal light) support</li> <li><code>has_extended_multizone</code> \u2192 <code>bool</code> - Extended multizone (&gt;16 zones)</li> </ul> <p>Example: <pre><code>product = get_product(55)  # LIFX Tile\nprint(f\"Color: {product.has_color}\")         # True\nprint(f\"Matrix: {product.has_matrix}\")       # True\nprint(f\"Multizone: {product.has_multizone}\") # False\n</code></pre></p>"},{"location":"library/products/#supports_extended_multizonefirmware_version-int-none-none-bool","title":"<code>supports_extended_multizone(firmware_version: int | None = None) -&gt; bool</code>","text":"<p>Check if extended multizone is supported for a given firmware version.</p> <p>Parameters: - <code>firmware_version</code> (<code>int | None</code>) - Firmware version to check (optional)</p> <p>Returns: <code>bool</code> - <code>True</code> if extended multizone is supported</p> <p>Example: <pre><code>product = get_product(38)  # LIFX Beam\nif product.supports_extended_multizone():\n    print(\"Supports 80 zones!\")\n</code></pre></p>"},{"location":"library/products/#productcapability","title":"ProductCapability","text":"<p>Enum of capability flags used in product definitions.</p> <pre><code>class ProductCapability(IntEnum):\n    COLOR = 1               # Full RGB color\n    INFRARED = 2            # Night vision IR\n    MULTIZONE = 4           # Linear zones (strips)\n    CHAIN = 8               # Device chaining\n    MATRIX = 16             # 2D tile grid\n    RELAYS = 32             # Relay switches\n    BUTTONS = 64            # Physical buttons\n    HEV = 128               # Germicidal light\n    EXTENDED_MULTIZONE = 256  # &gt;16 zones\n</code></pre>"},{"location":"library/products/#usage","title":"Usage","text":"<pre><code>from lifx_emulator.products import ProductCapability\n\n# Check multiple capabilities\ncapabilities = ProductCapability.COLOR | ProductCapability.INFRARED\nhas_color = bool(capabilities &amp; ProductCapability.COLOR)        # True\nhas_multizone = bool(capabilities &amp; ProductCapability.MULTIZONE) # False\n</code></pre>"},{"location":"library/products/#product-registry","title":"Product Registry","text":"<p>The <code>PRODUCTS</code> dictionary and helper functions provide access to the product database.</p>"},{"location":"library/products/#get_productpid-int-productinfo-none","title":"<code>get_product(pid: int) -&gt; ProductInfo | None</code>","text":"<p>Retrieve product information by product ID.</p> <p>Parameters: - <code>pid</code> (<code>int</code>) - Product ID</p> <p>Returns: <code>ProductInfo | None</code> - Product information or <code>None</code> if not found</p> <p>Example: <pre><code>from lifx_emulator.products import get_product\n\nproduct = get_product(27)  # LIFX A19\nif product:\n    print(f\"Product: {product.name}\")\n    print(f\"Capabilities: {product.capabilities}\")\n    print(f\"Temperature range: {product.temperature_range.min}-{product.temperature_range.max}K\")\n</code></pre></p>"},{"location":"library/products/#get_registry-dictint-productinfo","title":"<code>get_registry() -&gt; dict[int, ProductInfo]</code>","text":"<p>Get the complete product registry.</p> <p>Returns: <code>dict[int, ProductInfo]</code> - Mapping of product ID to ProductInfo</p> <p>Example: <pre><code>from lifx_emulator.products import get_registry\n\nregistry = get_registry()\nprint(f\"Total products: {len(registry)}\")\n\nfor pid, product in registry.items():\n    if product.has_multizone:\n        print(f\"{pid}: {product.name}\")\n</code></pre></p>"},{"location":"library/products/#get_device_class_nameproduct-productinfo-str","title":"<code>get_device_class_name(product: ProductInfo) -&gt; str</code>","text":"<p>Get the device class name based on capabilities.</p> <p>Parameters: - <code>product</code> (<code>ProductInfo</code>) - Product to classify</p> <p>Returns: <code>str</code> - Device class name (\"color\", \"multizone\", \"matrix\", \"hev\", etc.)</p> <p>Example: <pre><code>from lifx_emulator.products import get_product, get_device_class_name\n\nproduct = get_product(32)\nclass_name = get_device_class_name(product)\nprint(f\"Device class: {class_name}\")  # \"multizone\"\n</code></pre></p>"},{"location":"library/products/#productspecs","title":"ProductSpecs","text":"<p>Device-specific specifications (zone counts, tile dimensions, etc.) are stored in the specs system.</p>"},{"location":"library/products/#get_product_specsproduct_id-int-dict-none","title":"<code>get_product_specs(product_id: int) -&gt; dict | None</code>","text":"<p>Get detailed specifications for a product.</p> <p>Parameters: - <code>product_id</code> (<code>int</code>) - Product ID</p> <p>Returns: <code>dict | None</code> - Specifications dictionary or <code>None</code></p> <p>Spec Fields: - <code>zone_count</code>: Number of zones (multizone devices) - <code>extended_multizone</code>: Extended multizone support flag - <code>tile_count</code>: Default number of tiles (matrix devices) - <code>tile_width</code>: Tile width in zones (matrix devices) - <code>tile_height</code>: Tile height in zones (matrix devices)</p> <p>Example: <pre><code>from lifx_emulator.specs import get_product_specs\n\n# LIFX Z (standard multizone)\nspecs = get_product_specs(32)\nprint(f\"Zones: {specs['zone_count']}\")  # 16\n\n# LIFX Beam (extended multizone)\nspecs = get_product_specs(38)\nprint(f\"Zones: {specs['zone_count']}\")           # 80\nprint(f\"Extended: {specs['extended_multizone']}\") # True\n\n# LIFX Tile\nspecs = get_product_specs(55)\nprint(f\"Tiles: {specs['tile_count']}\")     # 5\nprint(f\"Dimensions: {specs['tile_width']}x{specs['tile_height']}\")  # 8x8\n</code></pre></p>"},{"location":"library/products/#capability-matrix","title":"Capability Matrix","text":"<p>Complete capability matrix for major LIFX products:</p> Product ID Name Color Infrared Multizone Extended MZ Matrix HEV Temp Range (K) 1 LIFX Original 1000 \u2713 2500-9000 27 LIFX A19 \u2713 2500-9000 29 LIFX A19 Night Vision \u2713 \u2713 2500-9000 32 LIFX Z \u2713 \u2713 2500-9000 36 LIFX Downlight \u2713 2500-9000 38 LIFX Beam \u2713 \u2713 \u2713 2500-9000 43 LIFX BR30 \u2713 2500-9000 44 LIFX BR30 Night Vision \u2713 \u2713 2500-9000 50 LIFX Mini White to Warm 2700-6500 55 LIFX Tile \u2713 \u2713 2500-9000 57 LIFX Candle \u2713 \u2713 2500-9000 66 LIFX GU10 \u2713 2500-9000 90 LIFX Clean \u2713 \u2713 2500-9000 141 LIFX Neon \u2713 \u2713 2500-9000 176 LIFX Ceiling \u2713 \u2713 2500-9000 <p>Legend: - Color: Full RGB color control - Infrared: Night vision capability - Multizone: Linear zone control (up to 16 zones) - Extended MZ: Extended multizone (&gt;16 zones) - Matrix: 2D tile/matrix control - HEV: Germicidal UV-C light - Temp Range: Color temperature range in Kelvin</p>"},{"location":"library/products/#product-filtering","title":"Product Filtering","text":"<p>Filter products by capabilities using the registry:</p>"},{"location":"library/products/#filter-by-single-capability","title":"Filter by Single Capability","text":"<pre><code>from lifx_emulator.products import get_registry, ProductCapability\n\nregistry = get_registry()\n\n# Find all multizone products\nmultizone_products = [\n    product for product in registry.values()\n    if product.has_multizone\n]\n\nfor product in multizone_products:\n    print(f\"{product.pid}: {product.name}\")\n# Output: 32: LIFX Z, 38: LIFX Beam, 141: LIFX Neon, etc.\n</code></pre>"},{"location":"library/products/#filter-by-multiple-capabilities","title":"Filter by Multiple Capabilities","text":"<pre><code># Find all color + infrared products\ncolor_ir_products = [\n    product for product in registry.values()\n    if product.has_color and product.has_infrared\n]\n\nfor product in color_ir_products:\n    print(f\"{product.pid}: {product.name}\")\n# Output: 29: LIFX A19 Night Vision, 44: LIFX BR30 Night Vision\n</code></pre>"},{"location":"library/products/#filter-by-temperature-range","title":"Filter by Temperature Range","text":"<pre><code># Find products that support warm white (&lt; 3000K)\nwarm_white_products = [\n    product for product in registry.values()\n    if product.temperature_range and product.temperature_range.min &lt; 3000\n]\n\nfor product in warm_white_products:\n    print(f\"{product.pid}: {product.name} ({product.temperature_range.min}K)\")\n</code></pre>"},{"location":"library/products/#filter-extended-multizone","title":"Filter Extended Multizone","text":"<pre><code># Find extended multizone products (&gt;16 zones)\nextended_mz_products = [\n    product for product in registry.values()\n    if product.has_extended_multizone\n]\n\nfor product in extended_mz_products:\n    print(f\"{product.pid}: {product.name}\")\n# Output: 38: LIFX Beam, etc.\n</code></pre>"},{"location":"library/products/#custom-filter-function","title":"Custom Filter Function","text":"<pre><code>def filter_products(\n    color: bool = False,\n    multizone: bool = False,\n    matrix: bool = False,\n    hev: bool = False,\n) -&gt; list[ProductInfo]:\n    \"\"\"Filter products by capabilities.\"\"\"\n    registry = get_registry()\n    results = []\n\n    for product in registry.values():\n        if color and not product.has_color:\n            continue\n        if multizone and not product.has_multizone:\n            continue\n        if matrix and not product.has_matrix:\n            continue\n        if hev and not product.has_hev:\n            continue\n        results.append(product)\n\n    return results\n\n# Usage\nmatrix_products = filter_products(matrix=True)\ncolor_multizone = filter_products(color=True, multizone=True)\n</code></pre>"},{"location":"library/products/#using-products","title":"Using Products","text":""},{"location":"library/products/#creating-devices-from-product-ids","title":"Creating Devices from Product IDs","text":"<pre><code>from lifx_emulator.factories import create_device\nfrom lifx_emulator.products import get_product\n\n# Create device by product ID\ndevice = create_device(product_id=27)  # LIFX A19\n\n# Get product info\nproduct = get_product(27)\nprint(f\"Created: {product.name}\")\nprint(f\"Color: {device.state.has_color}\")\nprint(f\"Multizone: {device.state.has_multizone}\")\n</code></pre>"},{"location":"library/products/#using-product-specs-for-configuration","title":"Using Product Specs for Configuration","text":"<pre><code>from lifx_emulator.factories import create_device\nfrom lifx_emulator.specs import get_product_specs\n\n# Create LIFX Z with product defaults\ndevice = create_device(product_id=32)\n\n# Specs are automatically applied\nspecs = get_product_specs(32)\nassert device.state.zone_count == specs['zone_count']  # 16 zones\n\n# Override defaults\ndevice = create_device(product_id=32, zone_count=8)  # Custom: 8 zones\n</code></pre>"},{"location":"library/products/#listing-available-products","title":"Listing Available Products","text":"<p>Command-line tool to list all products:</p> <pre><code># List all products\nlifx-emulator list-products\n\n# Filter by capability\nlifx-emulator list-products --filter-type multizone\nlifx-emulator list-products --filter-type matrix\nlifx-emulator list-products --filter-type hev\n</code></pre> <p>Example Output: <pre><code>LIFX Product Registry\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 ID   \u2502 Product Name                               \u2502 Capabilities             \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502 27   \u2502 LIFX A19                                   \u2502 full color               \u2502\n\u2502 29   \u2502 LIFX A19 Night Vision                      \u2502 full color, infrared     \u2502\n\u2502 32   \u2502 LIFX Z                                     \u2502 full color, multizone    \u2502\n\u2502 38   \u2502 LIFX Beam                                  \u2502 full color, extended-mz  \u2502\n\u2502 55   \u2502 LIFX Tile                                  \u2502 full color, matrix       \u2502\n\u2502 90   \u2502 LIFX Clean                                 \u2502 full color, HEV          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"library/products/#programmatic-product-listing","title":"Programmatic Product Listing","text":"<pre><code>from lifx_emulator.products import get_registry\n\ndef list_products(filter_capability: str | None = None):\n    \"\"\"List all products with optional capability filter.\"\"\"\n    registry = get_registry()\n\n    for pid, product in sorted(registry.items()):\n        # Apply filter\n        if filter_capability == \"multizone\" and not product.has_multizone:\n            continue\n        if filter_capability == \"matrix\" and not product.has_matrix:\n            continue\n        if filter_capability == \"hev\" and not product.has_hev:\n            continue\n\n        # Print product info\n        capabilities = []\n        if product.has_color:\n            capabilities.append(\"color\")\n        if product.has_infrared:\n            capabilities.append(\"infrared\")\n        if product.has_multizone:\n            capabilities.append(\"multizone\")\n        if product.has_extended_multizone:\n            capabilities.append(\"extended-mz\")\n        if product.has_matrix:\n            capabilities.append(\"matrix\")\n        if product.has_hev:\n            capabilities.append(\"HEV\")\n\n        print(f\"{pid:3d}  {product.name:40s}  {', '.join(capabilities)}\")\n\n# Usage\nlist_products()\nlist_products(filter_capability=\"matrix\")\n</code></pre>"},{"location":"library/products/#product-data-source","title":"Product Data Source","text":"<p>The product registry is auto-generated from the official LIFX product database:</p> <ul> <li>Source: LIFX/products on GitHub</li> <li>Generator: <code>src/lifx_emulator/products/generator.py</code></li> <li>Registry: <code>src/lifx_emulator/products/registry.py</code> (auto-generated)</li> <li>Specs: <code>src/lifx_emulator/specs/</code> (manually curated device specifications)</li> </ul>"},{"location":"library/products/#updating-products","title":"Updating Products","text":"<p>To update the product registry with the latest LIFX products:</p> <pre><code># Run the generator (fetches latest from GitHub)\npython -m lifx_emulator.products.generator\n\n# Verify changes\ngit diff src/lifx_emulator/products/registry.py\n</code></pre>"},{"location":"library/products/#references","title":"References","text":"<p>Source Files: - <code>src/lifx_emulator/products/registry.py</code> - Product registry (auto-generated) - <code>src/lifx_emulator/products/generator.py</code> - Registry generator - <code>src/lifx_emulator/specs/</code> - Product specifications</p> <p>Related Documentation: - Factories API - Device creation from product IDs - Device API - Device capabilities and state - Device Types Guide - Supported device types - CLI Reference - Command-line product usage</p> <p>External Resources: - LIFX Products GitHub - Official product database - LIFX Developer Docs - Protocol specification</p>"},{"location":"library/protocol/","title":"Protocol API Reference","text":"<p>LIFX LAN Protocol implementation - packet types, headers, and serialization</p> <p>The protocol module provides a complete implementation of the LIFX LAN binary protocol, including packet definitions, header parsing, type serialization, and packet registry management.</p>"},{"location":"library/protocol/#table-of-contents","title":"Table of Contents","text":""},{"location":"library/protocol/#core-components","title":"Core Components","text":"<ul> <li>LifxHeader - Packet header structure</li> <li>Packet Types - Protocol packet definitions</li> <li>Protocol Types - Structured data types (HSBK, TileState, etc.)</li> <li>Packet Registry - Mapping packet type numbers to classes</li> </ul>"},{"location":"library/protocol/#concepts","title":"Concepts","text":"<ul> <li>Binary Format Overview</li> <li>Serialization and Deserialization</li> <li>Working with Packets</li> <li>Type Conversion</li> </ul>"},{"location":"library/protocol/#lifxheader","title":"LifxHeader","text":"<p>The LIFX protocol header is a 36-byte structure that precedes every packet payload.</p>"},{"location":"library/protocol/#structure","title":"Structure","text":"<pre><code>@dataclass\nclass LifxHeader:\n    # Frame\n    size: int = 0                # Total packet size (header + payload)\n    origin: int = 0              # Message origin (always 0)\n    tagged: bool = False         # Broadcast flag (True = all devices)\n    addressable: bool = True     # Addressable flag (always True)\n    protocol: int = 1024         # Protocol number (always 1024)\n    source: int = 0              # Unique client identifier\n\n    # Frame Address\n    target: bytes = b'\\x00' * 8  # 6-byte serial + 2 null bytes\n    ack_required: bool = False   # Request acknowledgment\n    res_required: bool = False   # Request response\n    sequence: int = 0            # Message sequence number (0-255)\n\n    # Protocol Header\n    pkt_type: int = 0            # Packet type number (e.g., 2, 101, 116)\n</code></pre>"},{"location":"library/protocol/#key-fields","title":"Key Fields","text":""},{"location":"library/protocol/#tagged-bool","title":"<code>tagged</code> (bool)","text":"<ul> <li><code>True</code>: Broadcast packet - sent to all devices on network</li> <li><code>False</code>: Unicast packet - sent to specific device (requires valid <code>target</code>)</li> </ul>"},{"location":"library/protocol/#target-bytes","title":"<code>target</code> (bytes)","text":"<ul> <li>8-byte field: 6-byte device serial + 2 null bytes</li> <li>Example: <code>b'\\xd0\\x73\\xd5\\x00\\x00\\x01\\x00\\x00'</code> for serial <code>d073d5000001</code></li> <li>All zeros (<code>b'\\x00' * 8</code>) when <code>tagged=True</code></li> </ul>"},{"location":"library/protocol/#ack_required-bool","title":"<code>ack_required</code> (bool)","text":"<ul> <li><code>True</code>: Device must send acknowledgment (packet type 45)</li> <li><code>False</code>: No acknowledgment needed</li> </ul>"},{"location":"library/protocol/#res_required-bool","title":"<code>res_required</code> (bool)","text":"<ul> <li><code>True</code>: Device must send response packet (e.g., <code>State</code> for <code>Get</code>)</li> <li><code>False</code>: No response packet expected</li> </ul>"},{"location":"library/protocol/#source-int","title":"<code>source</code> (int)","text":"<ul> <li>32-bit client identifier</li> <li>Used to match responses to requests</li> <li>Should be unique per client instance</li> </ul>"},{"location":"library/protocol/#sequence-int","title":"<code>sequence</code> (int)","text":"<ul> <li>8-bit sequence number (0-255, wraps around)</li> <li>Used to match responses to specific requests</li> <li>Client should increment for each request</li> </ul>"},{"location":"library/protocol/#pkt_type-int","title":"<code>pkt_type</code> (int)","text":"<ul> <li>Identifies the packet payload type</li> <li>Common types: 2 (<code>GetService</code>), 101 (<code>Get</code>), 102 (<code>SetColor</code>), 107 (<code>State</code>), etc.</li> </ul>"},{"location":"library/protocol/#methods","title":"Methods","text":""},{"location":"library/protocol/#pack-bytes","title":"<code>pack() -&gt; bytes</code>","text":"<p>Serialize header to 36-byte binary format.</p> <p>Returns: <code>bytes</code> - 36-byte header</p> <p>Example: <pre><code>from lifx_emulator.protocol.header import LifxHeader\n\nheader = LifxHeader(\n    size=36,\n    source=12345,\n    target=bytes.fromhex(\"d073d5000001\") + b'\\x00\\x00',\n    res_required=True,\n    sequence=1,\n    pkt_type=101,  # Light.Get\n)\nraw_header = header.pack()\n# Returns: 36 bytes\n</code></pre></p>"},{"location":"library/protocol/#unpackdata-bytes-lifxheader","title":"<code>unpack(data: bytes) -&gt; LifxHeader</code>","text":"<p>Parse 36 bytes into a LifxHeader object.</p> <p>Parameters: - <code>data</code> (<code>bytes</code>) - 36-byte header data</p> <p>Returns: <code>LifxHeader</code> - Parsed header object</p> <p>Example: <pre><code>raw_header = sock.recv(36)\nheader = LifxHeader.unpack(raw_header)\nprint(f\"Packet type: {header.pkt_type}\")\nprint(f\"Source: {header.source}\")\nprint(f\"Target: {header.target.hex()}\")\n</code></pre></p>"},{"location":"library/protocol/#packet-types","title":"Packet Types","text":"<p>The protocol module provides classes for all LIFX protocol packets, organized into namespaces:</p>"},{"location":"library/protocol/#packet-organization","title":"Packet Organization","text":"<pre><code>from lifx_emulator.protocol.packets import Device, Light, MultiZone, Tile, Relay, Hev\n\n# Device discovery and information\nDevice.GetService             # Type 2\nDevice.StateService           # Type 3\nDevice.GetHostInfo            # Type 12\nDevice.StateHostInfo          # Type 13\nDevice.GetVersion             # Type 32\nDevice.StateVersion           # Type 33\nDevice.GetLocation            # Type 48\nDevice.StateLocation          # Type 50\nDevice.GetGroup               # Type 51\nDevice.StateGroup             # Type 53\nDevice.Acknowledgement        # Type 45\nDevice.EchoRequest            # Type 58\nDevice.EchoResponse           # Type 59\n\n# Light control (all color-capable devices)\nLight.Get                     # Type 101\nLight.SetColor                # Type 102\nLight.SetWaveform             # Type 103\nLight.State                   # Type 107\nLight.GetPower                # Type 116\nLight.SetPower                # Type 117\nLight.StatePower              # Type 118\nLight.GetInfrared             # Type 120 (infrared devices only)\nLight.SetInfrared             # Type 122\nLight.StateInfrared           # Type 121\n\n# Multizone control (strips/beams)\nMultiZone.SetColorZones       # Type 501\nMultiZone.GetColorZones       # Type 502\nMultiZone.StateZone           # Type 503\nMultiZone.StateMultiZone      # Type 506\nMultiZone.SetMultiZoneEffect  # Type 508\nMultiZone.GetMultiZoneEffect  # Type 509\nMultiZone.StateMultiZoneEffect # Type 510\n\n# Extended multizone (&gt;16 zones)\nMultiZone.SetExtendedColorZones       # Type 510\nMultiZone.GetExtendedColorZones       # Type 511\nMultiZone.StateExtendedColorZones     # Type 512\n\n# Tile/Matrix control (2D arrangements)\nTile.GetDeviceChain           # Type 701\nTile.StateDeviceChain         # Type 702\nTile.Get64                    # Type 707\nTile.State64                  # Type 711\nTile.Set64                    # Type 715\nTile.SetUserPosition          # Type 703\nTile.GetTileEffect            # Type 718\nTile.SetTileEffect            # Type 719\nTile.StateTileEffect          # Type 720\n\n# HEV (germicidal light)\nHev.GetCycle                  # Type 142\nHev.SetCycle                  # Type 143\nHev.StateCycle                # Type 144\nHev.GetConfiguration          # Type 145\nHev.StateConfiguration        # Type 146\n</code></pre>"},{"location":"library/protocol/#packet-class-structure","title":"Packet Class Structure","text":"<p>Each packet class has:</p> <ul> <li><code>PKT_TYPE</code>: Class constant with packet type number</li> <li><code>pack()</code>: Serialize to binary format</li> <li><code>unpack(data)</code>: Parse from binary format</li> </ul>"},{"location":"library/protocol/#example-lightsetcolor","title":"Example: Light.SetColor","text":"<pre><code>from lifx_emulator.protocol.packets import Light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\n# Create SetColor packet\npacket = Light.SetColor(\n    reserved=0,\n    color=LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500),\n    duration_ms=1000,\n)\n\n# Serialize to bytes\nraw_payload = packet.pack()\n\n# Parse from bytes\nreceived_packet = Light.SetColor.unpack(raw_payload)\nprint(f\"Color: H={received_packet.color.hue} S={received_packet.color.saturation}\")\nprint(f\"Duration: {received_packet.duration_ms}ms\")\n</code></pre>"},{"location":"library/protocol/#example-multizonegetcolorzones","title":"Example: MultiZone.GetColorZones","text":"<pre><code>from lifx_emulator.protocol.packets import MultiZone\n\n# Request zones 0-7\npacket = MultiZone.GetColorZones(\n    start_index=0,\n    end_index=7,\n)\n\nraw_payload = packet.pack()\n</code></pre>"},{"location":"library/protocol/#example-tileget64","title":"Example: Tile.Get64","text":"<pre><code>from lifx_emulator.protocol.packets import Tile\n\n# Request 8x8 rectangle starting at (0,0) from tile 0\npacket = Tile.Get64(\n    tile_index=0,\n    length=1,      # Not used for Get64\n    rect_x=0,\n    rect_y=0,\n    rect_width=8,\n)\n\nraw_payload = packet.pack()\n</code></pre>"},{"location":"library/protocol/#protocol-types","title":"Protocol Types","text":"<p>Protocol types are structured data types used within packets.</p>"},{"location":"library/protocol/#lighthsbk","title":"LightHsbk","text":"<p>HSBK color representation (Hue, Saturation, Brightness, Kelvin).</p> <pre><code>@dataclass\nclass LightHsbk:\n    hue: int          # 0-65535 (0\u00b0 to 360\u00b0)\n    saturation: int   # 0-65535 (0% to 100%)\n    brightness: int   # 0-65535 (0% to 100%)\n    kelvin: int       # 1500-9000 (color temperature)\n</code></pre> <p>Color Conversion: - Hue: <code>degrees * 65535 / 360</code> - Saturation: <code>percent * 65535 / 100</code> - Brightness: <code>percent * 65535 / 100</code> - Kelvin: Absolute value (e.g., 3500 for warm white)</p> <p>Examples: <pre><code>from lifx_emulator.protocol.protocol_types import LightHsbk\n\n# Red at 50% brightness\nred = LightHsbk(hue=0, saturation=65535, brightness=32768, kelvin=3500)\n\n# Green at full brightness\ngreen = LightHsbk(hue=21845, saturation=65535, brightness=65535, kelvin=3500)\n\n# Blue at 75% brightness\nblue = LightHsbk(hue=43690, saturation=65535, brightness=49152, kelvin=3500)\n\n# Warm white (no color)\nwarm_white = LightHsbk(hue=0, saturation=0, brightness=65535, kelvin=2700)\n\n# Cool white (no color)\ncool_white = LightHsbk(hue=0, saturation=0, brightness=65535, kelvin=6500)\n</code></pre></p>"},{"location":"library/protocol/#tilestatedevice","title":"TileStateDevice","text":"<p>Tile position and metadata in a matrix chain.</p> <pre><code>@dataclass\nclass TileStateDevice:\n    accel_meas_x: int\n    accel_meas_y: int\n    accel_meas_z: int\n    user_x: float         # User-configured X position\n    user_y: float         # User-configured Y position\n    width: int            # Tile width in zones (e.g., 8)\n    height: int           # Tile height in zones (e.g., 8)\n    device_version_vendor: int\n    device_version_product: int\n    device_version_version: int\n    firmware_build: int\n    firmware_version_minor: int\n    firmware_version_major: int\n</code></pre>"},{"location":"library/protocol/#enums","title":"Enums","text":"<p>The protocol defines several enums for packet fields:</p> <pre><code>from lifx_emulator.protocol.protocol_types import (\n    DeviceService,\n    LightWaveform,\n    LightLastHevCycleResult,\n    MultiZoneEffectType,\n    MultiZoneApplicationRequest,\n    TileEffectType,\n)\n\n# Service types\nDeviceService.UDP                          # 1\n\n# Waveform types for Light.SetWaveform\nLightWaveform.SAW                          # 0\nLightWaveform.SINE                         # 1\nLightWaveform.HALF_SINE                    # 2\nLightWaveform.TRIANGLE                     # 3\nLightWaveform.PULSE                        # 4\n\n# Multizone effects\nMultiZoneEffectType.OFF                    # 0\nMultiZoneEffectType.MOVE                   # 1\n\n# Tile effects\nTileEffectType.OFF                         # 0\nTileEffectType.MORPH                       # 2\nTileEffectType.FLAME                       # 3\n</code></pre>"},{"location":"library/protocol/#packet-registry","title":"Packet Registry","text":"<p>The <code>PACKET_REGISTRY</code> maps packet type numbers to packet classes.</p>"},{"location":"library/protocol/#usage","title":"Usage","text":"<pre><code>from lifx_emulator.protocol.packets import PACKET_REGISTRY, get_packet_class\n\n# Get packet class by type number\npacket_class = PACKET_REGISTRY[102]  # Light.SetColor\nprint(packet_class.PKT_TYPE)  # 102\n\n# Or use the helper function\npacket_class = get_packet_class(102)\n\n# Parse unknown packet type\nraw_payload = receive_payload()\npacket_class = get_packet_class(header.pkt_type)\nif packet_class:\n    packet = packet_class.unpack(raw_payload)\nelse:\n    print(f\"Unknown packet type: {header.pkt_type}\")\n</code></pre>"},{"location":"library/protocol/#complete-packet-type-list","title":"Complete Packet Type List","text":"Type Packet Description 2 <code>Device.GetService</code> Device discovery request 3 <code>Device.StateService</code> Device discovery response 12 <code>Device.GetHostInfo</code> Get host MCU info 13 <code>Device.StateHostInfo</code> Host MCU info response 14 <code>Device.GetHostFirmware</code> Get host firmware 15 <code>Device.StateHostFirmware</code> Host firmware response 16 <code>Device.GetWifiInfo</code> Get WiFi info 17 <code>Device.StateWifiInfo</code> WiFi info response 18 <code>Device.GetWifiFirmware</code> Get WiFi firmware 19 <code>Device.StateWifiFirmware</code> WiFi firmware response 20 <code>Device.GetPower</code> Get device power 21 <code>Device.SetPower</code> Set device power 22 <code>Device.StatePower</code> Device power response 23 <code>Device.GetLabel</code> Get device label 24 <code>Device.SetLabel</code> Set device label 25 <code>Device.StateLabel</code> Device label response 32 <code>Device.GetVersion</code> Get firmware version 33 <code>Device.StateVersion</code> Firmware version response 34 <code>Device.GetInfo</code> Get device info 35 <code>Device.StateInfo</code> Device info response 45 <code>Device.Acknowledgement</code> Acknowledgment response 48 <code>Device.GetLocation</code> Get location 50 <code>Device.StateLocation</code> Location response 51 <code>Device.GetGroup</code> Get group 53 <code>Device.StateGroup</code> Group response 58 <code>Device.EchoRequest</code> Echo request 59 <code>Device.EchoResponse</code> Echo response 101 <code>Light.Get</code> Get light state 102 <code>Light.SetColor</code> Set color 103 <code>Light.SetWaveform</code> Set waveform effect 107 <code>Light.State</code> Light state response 116 <code>Light.GetPower</code> Get light power 117 <code>Light.SetPower</code> Set light power 118 <code>Light.StatePower</code> Light power response 120 <code>Light.GetInfrared</code> Get IR brightness 121 <code>Light.StateInfrared</code> IR brightness response 122 <code>Light.SetInfrared</code> Set IR brightness 142 <code>Hev.GetCycle</code> Get HEV cycle 143 <code>Hev.SetCycle</code> Set HEV cycle 144 <code>Hev.StateCycle</code> HEV cycle response 501 <code>MultiZone.SetColorZones</code> Set zone colors 502 <code>MultiZone.GetColorZones</code> Get zone colors 503 <code>MultiZone.StateZone</code> Single zone response 506 <code>MultiZone.StateMultiZone</code> Multiple zones response 508 <code>MultiZone.SetMultiZoneEffect</code> Set zone effect 509 <code>MultiZone.GetMultiZoneEffect</code> Get zone effect 510 <code>MultiZone.StateMultiZoneEffect</code> Zone effect response 511 <code>MultiZone.GetExtendedColorZones</code> Get extended zones 512 <code>MultiZone.StateExtendedColorZones</code> Extended zones response 513 <code>MultiZone.SetExtendedColorZones</code> Set extended zones 701 <code>Tile.GetDeviceChain</code> Get tile chain info 702 <code>Tile.StateDeviceChain</code> Tile chain response 703 <code>Tile.SetUserPosition</code> Set tile position 707 <code>Tile.Get64</code> Get tile colors (64 zones) 711 <code>Tile.State64</code> Tile colors response 715 <code>Tile.Set64</code> Set tile colors 718 <code>Tile.GetTileEffect</code> Get tile effect 719 <code>Tile.SetTileEffect</code> Set tile effect 720 <code>Tile.StateTileEffect</code> Tile effect response"},{"location":"library/protocol/#binary-format-overview","title":"Binary Format Overview","text":""},{"location":"library/protocol/#packet-structure","title":"Packet Structure","text":"<p>Every LIFX packet consists of:</p> <ol> <li>Header (36 bytes) - See LifxHeader</li> <li>Payload (variable length) - Packet-specific data</li> </ol> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         Header (36 bytes)           \u2502\n\u2502  - Frame (8 bytes)                  \u2502\n\u2502  - Frame Address (16 bytes)         \u2502\n\u2502  - Protocol Header (12 bytes)       \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502         Payload (variable)          \u2502\n\u2502  - Packet-specific fields           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"library/protocol/#header-binary-layout","title":"Header Binary Layout","text":"<pre><code>Bytes 0-1:   Size (uint16, little-endian)\nBytes 2-3:   Protocol/Origin/Tagged/Addressable (bitfield)\nBytes 4-7:   Source (uint32, little-endian)\nBytes 8-15:  Target (6-byte MAC + 2 reserved bytes)\nBytes 16-21: Reserved\nByte  22:    Ack/Res flags + reserved bits\nByte  23:    Sequence (uint8)\nBytes 24-31: Reserved\nBytes 32-33: Packet type (uint16, little-endian)\nBytes 34-35: Reserved\n</code></pre>"},{"location":"library/protocol/#payload-encoding","title":"Payload Encoding","text":"<p>Payload fields are serialized using little-endian byte order:</p> <ul> <li>Integers: <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, <code>uint64</code></li> <li>Floats: <code>float32</code> (IEEE 754)</li> <li>Booleans: <code>uint8</code> (0=False, 1=True)</li> <li>Strings: UTF-8 encoded, null-padded to fixed length</li> <li>Bytes: Raw byte arrays</li> <li>Nested types: Recursively serialized structures</li> <li>Arrays: Consecutive serialized elements</li> </ul>"},{"location":"library/protocol/#serialization-and-deserialization","title":"Serialization and Deserialization","text":""},{"location":"library/protocol/#packing-python-binary","title":"Packing (Python \u2192 Binary)","text":"<pre><code>from lifx_emulator.protocol.header import LifxHeader\nfrom lifx_emulator.protocol.packets import Light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\n# Create header\nheader = LifxHeader(\n    size=0,  # Will be calculated\n    source=12345,\n    target=bytes.fromhex(\"d073d5000001\") + b'\\x00\\x00',\n    res_required=True,\n    sequence=1,\n    pkt_type=102,  # SetColor\n)\n\n# Create packet\npacket = Light.SetColor(\n    reserved=0,\n    color=LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500),\n    duration_ms=1000,\n)\n\n# Pack to binary\npayload = packet.pack()\nheader.size = 36 + len(payload)\nheader_bytes = header.pack()\n\n# Send over UDP\nfull_packet = header_bytes + payload\nsock.sendto(full_packet, (device_ip, 56700))\n</code></pre>"},{"location":"library/protocol/#unpacking-binary-python","title":"Unpacking (Binary \u2192 Python)","text":"<pre><code>from lifx_emulator.protocol.header import LifxHeader\nfrom lifx_emulator.protocol.packets import get_packet_class\n\n# Receive packet\ndata, addr = sock.recvfrom(1024)\n\n# Parse header\nheader = LifxHeader.unpack(data[:36])\nprint(f\"Received packet type: {header.pkt_type}\")\n\n# Parse payload\npacket_class = get_packet_class(header.pkt_type)\nif packet_class:\n    payload_data = data[36:]\n    packet = packet_class.unpack(payload_data)\n    print(f\"Packet: {packet}\")\nelse:\n    print(f\"Unknown packet type: {header.pkt_type}\")\n</code></pre>"},{"location":"library/protocol/#working-with-packets","title":"Working with Packets","text":""},{"location":"library/protocol/#complete-requestresponse-example","title":"Complete Request/Response Example","text":"<pre><code>import socket\nfrom lifx_emulator.protocol.header import LifxHeader\nfrom lifx_emulator.protocol.packets import Light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\n# Create UDP socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\nsock.settimeout(2.0)\n\n# Build GetService request (discovery)\nheader = LifxHeader(\n    size=36,\n    tagged=True,  # Broadcast\n    source=12345,\n    res_required=True,\n    sequence=1,\n    pkt_type=2,  # GetService\n)\n\n# Send discovery\nsock.sendto(header.pack(), ('&lt;broadcast&gt;', 56700))\n\n# Receive StateService response\ndata, addr = sock.recvfrom(1024)\nresp_header = LifxHeader.unpack(data[:36])\nprint(f\"Device found at {addr}: serial={resp_header.target[:6].hex()}\")\n\n# Get light state\nheader = LifxHeader(\n    size=36,\n    source=12345,\n    target=resp_header.target,\n    res_required=True,\n    sequence=2,\n    pkt_type=101,  # Light.Get\n)\nsock.sendto(header.pack(), addr)\n\n# Receive Light.State response\ndata, addr = sock.recvfrom(1024)\nresp_header = LifxHeader.unpack(data[:36])\nstate = Light.State.unpack(data[36:])\nprint(f\"Color: H={state.color.hue} S={state.color.saturation} B={state.color.brightness}\")\nprint(f\"Power: {state.power}\")\nprint(f\"Label: {state.label}\")\n\nsock.close()\n</code></pre>"},{"location":"library/protocol/#handling-acknowledgments","title":"Handling Acknowledgments","text":"<pre><code># Request acknowledgment\nheader = LifxHeader(\n    size=36 + len(payload),\n    source=12345,\n    target=device_target,\n    ack_required=True,  # Request ack\n    res_required=False,  # Don't need state response\n    sequence=3,\n    pkt_type=117,  # SetPower\n)\n\nsock.sendto(header.pack() + payload, addr)\n\n# Wait for acknowledgment (type 45)\ndata, addr = sock.recvfrom(1024)\nack_header = LifxHeader.unpack(data[:36])\nif ack_header.pkt_type == 45:\n    print(\"Command acknowledged\")\n</code></pre>"},{"location":"library/protocol/#type-conversion","title":"Type Conversion","text":""},{"location":"library/protocol/#hsbk-to-rgb","title":"HSBK to RGB","text":"<pre><code>import colorsys\n\ndef hsbk_to_rgb(hsbk: LightHsbk) -&gt; tuple[int, int, int]:\n    \"\"\"Convert HSBK to RGB (0-255 range).\"\"\"\n    h = hsbk.hue / 65535.0  # 0-1\n    s = hsbk.saturation / 65535.0  # 0-1\n    v = hsbk.brightness / 65535.0  # 0-1\n\n    r, g, b = colorsys.hsv_to_rgb(h, s, v)\n    return int(r * 255), int(g * 255), int(b * 255)\n</code></pre>"},{"location":"library/protocol/#rgb-to-hsbk","title":"RGB to HSBK","text":"<pre><code>import colorsys\n\ndef rgb_to_hsbk(r: int, g: int, b: int, kelvin: int = 3500) -&gt; LightHsbk:\n    \"\"\"Convert RGB (0-255) to HSBK.\"\"\"\n    h, s, v = colorsys.rgb_to_hsv(r / 255.0, g / 255.0, b / 255.0)\n\n    return LightHsbk(\n        hue=int(h * 65535),\n        saturation=int(s * 65535),\n        brightness=int(v * 65535),\n        kelvin=kelvin,\n    )\n</code></pre>"},{"location":"library/protocol/#percentage-conversions","title":"Percentage Conversions","text":"<pre><code>def percent_to_uint16(percent: float) -&gt; int:\n    \"\"\"Convert percentage (0-100) to uint16 (0-65535).\"\"\"\n    return int(percent * 65535 / 100)\n\ndef uint16_to_percent(value: int) -&gt; float:\n    \"\"\"Convert uint16 (0-65535) to percentage (0-100).\"\"\"\n    return value * 100 / 65535\n</code></pre>"},{"location":"library/protocol/#references","title":"References","text":"<p>Source Files: - <code>src/lifx_emulator/protocol/header.py</code> - Header implementation - <code>src/lifx_emulator/protocol/packets.py</code> - Packet definitions (auto-generated) - <code>src/lifx_emulator/protocol/protocol_types.py</code> - Type definitions (auto-generated) - <code>src/lifx_emulator/protocol/serializer.py</code> - Serialization utilities - <code>src/lifx_emulator/protocol/generator.py</code> - Code generator from YAML spec</p> <p>Related Documentation: - Device API - Device state and packet processing - Server API - UDP server implementation - LIFX LAN Protocol Specification - Official protocol docs - Architecture Overview - System architecture</p> <p>Protocol Specification: - Auto-generated from LIFX public-protocol - Generator: <code>src/lifx_emulator/protocol/generator.py</code> - Source: <code>protocol.yml</code> from LIFX/public-protocol repository</p>"},{"location":"library/server/","title":"EmulatedLifxServer","text":"<p>The <code>EmulatedLifxServer</code> class manages the UDP server and routes packets to emulated devices.</p>"},{"location":"library/server/#overview","title":"Overview","text":"<p>The server:</p> <ul> <li>Listens on a UDP socket for LIFX protocol packets</li> <li>Parses packet headers to determine routing</li> <li>Forwards packets to appropriate devices</li> <li>Sends response packets back to clients</li> <li>Supports both targeted and broadcast packets</li> </ul>"},{"location":"library/server/#api-reference","title":"API Reference","text":""},{"location":"library/server/#lifx_emulator.server.EmulatedLifxServer","title":"EmulatedLifxServer","text":"<pre><code>EmulatedLifxServer(\n    devices: list[EmulatedLifxDevice],\n    device_manager: IDeviceManager,\n    bind_address: str = \"127.0.0.1\",\n    port: int = LIFX_UDP_PORT,\n    track_activity: bool = True,\n    storage=None,\n    activity_observer: ActivityObserver | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n    persist_scenarios: bool = False,\n    scenario_storage: IScenarioStorageBackend | None = None,\n)\n</code></pre> <p>UDP server that simulates LIFX devices</p> METHOD DESCRIPTION <code>start</code> <p>Start the server</p> <code>stop</code> <p>Stop the server</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/server.py</code> <pre><code>def __init__(\n    self,\n    devices: list[EmulatedLifxDevice],\n    device_manager: IDeviceManager,\n    bind_address: str = \"127.0.0.1\",\n    port: int = LIFX_UDP_PORT,\n    track_activity: bool = True,\n    storage=None,\n    activity_observer: ActivityObserver | None = None,\n    scenario_manager: HierarchicalScenarioManager | None = None,\n    persist_scenarios: bool = False,\n    scenario_storage: IScenarioStorageBackend | None = None,\n):\n    # Device manager (required dependency injection)\n    self._device_manager = device_manager\n    self.bind_address = bind_address\n    self.port = port\n    self.transport = None\n    self.storage = storage\n\n    # Scenario storage backend (optional - only needed for persistence)\n    self.scenario_persistence: IScenarioStorageBackend | None = None\n    if persist_scenarios:\n        if scenario_storage is None:\n            raise ValueError(\n                \"scenario_storage is required when persist_scenarios=True\"\n            )\n        if scenario_manager is None:\n            raise ValueError(\n                \"scenario_manager is required when persist_scenarios=True \"\n                \"(must be pre-loaded from storage before server initialization)\"\n            )\n        self.scenario_persistence = scenario_storage\n\n    # Scenario manager (shared across all devices for runtime updates)\n    self.scenario_manager = scenario_manager or HierarchicalScenarioManager()\n\n    # Add initial devices to the device manager\n    for device in devices:\n        # Update device port to match server port\n        device.state.port = self.port\n        self._device_manager.add_device(device, self.scenario_manager)\n\n    # Activity observer - defaults to ActivityLogger if track_activity=True\n    if activity_observer is not None:\n        self.activity_observer = activity_observer\n    elif track_activity:\n        self.activity_observer = ActivityLogger(max_events=100)\n    else:\n        self.activity_observer = NullObserver()\n\n    # Statistics tracking\n    self.start_time = time.time()\n    self.packets_received = 0\n    self.packets_sent = 0\n    self.packets_received_by_type: dict[int, int] = defaultdict(int)\n    self.packets_sent_by_type: dict[int, int] = defaultdict(int)\n    self.error_count = 0\n</code></pre>"},{"location":"library/server/#lifx_emulator.server.EmulatedLifxServer-functions","title":"Functions","text":""},{"location":"library/server/#lifx_emulator.server.EmulatedLifxServer.start","title":"start  <code>async</code>","text":"<pre><code>start()\n</code></pre> <p>Start the server</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/server.py</code> <pre><code>async def start(self):\n    \"\"\"Start the server\"\"\"\n    loop = asyncio.get_running_loop()\n    self.transport, _ = await loop.create_datagram_endpoint(\n        lambda: self.LifxProtocol(self), local_addr=(self.bind_address, self.port)\n    )\n</code></pre>"},{"location":"library/server/#lifx_emulator.server.EmulatedLifxServer.stop","title":"stop  <code>async</code>","text":"<pre><code>stop()\n</code></pre> <p>Stop the server</p> Source code in <code>packages/lifx-emulator-core/src/lifx_emulator/server.py</code> <pre><code>async def stop(self):\n    \"\"\"Stop the server\"\"\"\n    if self.transport:\n        self.transport.close()\n</code></pre>"},{"location":"library/server/#usage","title":"Usage","text":""},{"location":"library/server/#basic-server","title":"Basic Server","text":"<pre><code>from lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\n# Create devices\ndevices = [create_color_light(\"d073d5000001\")]\n\n# Set up repository and manager (required)\ndevice_repository = DeviceRepository()\ndevice_manager = DeviceManager(device_repository)\n\n# Create server\nserver = EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700)\n\n# Start server\nawait server.start()\n\n# ... do work ...\n\n# Stop server\nawait server.stop()\n</code></pre>"},{"location":"library/server/#context-manager","title":"Context Manager","text":"<p>The recommended way to use the server:</p> <pre><code>from lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\ndevices = [create_color_light(\"d073d5000001\")]\ndevice_manager = DeviceManager(DeviceRepository())\n\nasync with EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700) as server:\n    # Server automatically starts\n    # Your test code here\n    pass\n# Server automatically stops\n</code></pre>"},{"location":"library/server/#multiple-devices","title":"Multiple Devices","text":"<pre><code>from lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import (\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\ndevices = [\n    create_color_light(\"d073d5000001\"),\n    create_multizone_light(\"d073d8000001\", zone_count=16),\n    create_tile_device(\"d073d9000001\", tile_count=5),\n]\n\ndevice_manager = DeviceManager(DeviceRepository())\n\nasync with EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700) as server:\n    # All devices are discoverable and controllable\n    pass\n</code></pre>"},{"location":"library/server/#parameters","title":"Parameters","text":""},{"location":"library/server/#devices","title":"<code>devices</code>","text":"<p>List of <code>EmulatedLifxDevice</code> instances to emulate.</p> <p>Type: <code>list[EmulatedLifxDevice]</code></p>"},{"location":"library/server/#device_manager","title":"<code>device_manager</code>","text":"<p>The device manager handling device lifecycle and packet routing.</p> <p>Type: <code>DeviceManager</code></p> <p>Required: Yes</p> <p>Notes: - The server delegates all device management operations to this manager - Must be created with a <code>DeviceRepository</code> instance - This is a required parameter in v2.0.0+</p> <p>Example: <pre><code>from lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\ndevice_repository = DeviceRepository()\ndevice_manager = DeviceManager(device_repository)\n</code></pre></p>"},{"location":"library/server/#bind_address","title":"<code>bind_address</code>","text":"<p>IP address to bind the UDP server to.</p> <p>Type: <code>str</code></p> <p>Examples: - <code>\"0.0.0.0\"</code> - Listen on all interfaces - <code>\"127.0.0.1\"</code> - Localhost only - <code>\"192.168.1.100\"</code> - Specific interface</p>"},{"location":"library/server/#port","title":"<code>port</code>","text":"<p>UDP port to listen on.</p> <p>Type: <code>int</code></p> <p>Default: 56700 (standard LIFX port)</p>"},{"location":"library/server/#track_activity","title":"<code>track_activity</code>","text":"<p>Enable packet activity tracking for the HTTP API dashboard.</p> <p>Type: <code>bool</code></p> <p>Default: <code>True</code></p> <p>Notes: - When enabled, the server tracks recent packet activity for the API dashboard - Disable to reduce memory usage in production or CI environments - Activity tracking is independent of packet logging (controlled by <code>--verbose</code> CLI flag)</p> <p>Example: <pre><code># Disable activity tracking\nserver = EmulatedLifxServer(\n    devices,\n    \"127.0.0.1\",\n    56700,\n    track_activity=False\n)\n</code></pre></p>"},{"location":"library/server/#storage","title":"<code>storage</code>","text":"<p>Optional persistent storage backend for device state.</p> <p>Type: <code>DevicePersistenceAsyncFile | None</code></p> <p>Default: <code>None</code></p> <p>Notes: - When provided, device state changes are automatically saved asynchronously - Allows device state to persist across emulator restarts - Must be used with devices created with the same storage instance - See Persistent Storage Guide for details</p> <p>Example: <pre><code>from lifx_emulator.devices import DevicePersistenceAsyncFile\nfrom lifx_emulator.factories import create_color_light\n\nstorage = DevicePersistenceAsyncFile()\ndevice = create_color_light(\"d073d5000001\", storage=storage)\n\ndevice_manager = DeviceManager(DeviceRepository())\n\n# Create server with storage support\nserver = EmulatedLifxServer(\n    [device],\n    device_manager,\n    \"127.0.0.1\",\n    56700,\n    storage=storage\n)\n</code></pre></p>"},{"location":"library/server/#activity_observer","title":"<code>activity_observer</code>","text":"<p>Optional observer for packet activity events.</p> <p>Type: <code>ActivityObserver | None</code></p> <p>Default: <code>None</code></p> <p>Notes: - Implement <code>ActivityObserver</code> protocol to receive packet events - Useful for custom activity tracking or metrics collection - Receives events for all packets sent and received</p>"},{"location":"library/server/#scenario_manager","title":"<code>scenario_manager</code>","text":"<p>Optional scenario manager for test scenario configuration.</p> <p>Type: <code>HierarchicalScenarioManager | None</code></p> <p>Default: <code>None</code></p> <p>Notes: - When provided, enables runtime scenario management via REST API - Supports device-specific, type-specific, location-based, group-based, and global scenarios - Scenarios control packet dropping, delays, malformed responses, etc. - See Testing Scenarios Guide for detailed examples</p> <p>Example: <pre><code>from lifx_emulator.scenarios import HierarchicalScenarioManager\nfrom lifx_emulator.devices import DeviceManager\nfrom lifx_emulator.repositories import DeviceRepository\n\nmanager = HierarchicalScenarioManager()\ndevice_manager = DeviceManager(DeviceRepository())\n\nserver = EmulatedLifxServer(\n    devices,\n    device_manager,\n    \"127.0.0.1\",\n    56700,\n    scenario_manager=manager\n)\n\n# Now scenario management API is available\n</code></pre></p>"},{"location":"library/server/#persist_scenarios","title":"<code>persist_scenarios</code>","text":"<p>Enable persistent storage of scenario configurations.</p> <p>Type: <code>bool</code></p> <p>Default: <code>False</code></p> <p>Notes: - When enabled, scenario configurations are saved to <code>~/.lifx-emulator/scenarios.json</code> - Scenarios are restored from disk on startup - Requires <code>scenario_manager</code> to be provided - Ignored if <code>scenario_manager</code> is <code>None</code></p> <p>Example: <pre><code># Enable both state and scenario persistence\ndevice_manager = DeviceManager(DeviceRepository())\nserver = EmulatedLifxServer(\n    devices,\n    device_manager,\n    \"127.0.0.1\",\n    56700,\n    storage=storage,\n    scenario_manager=manager,\n    persist_scenarios=True\n)\n</code></pre></p>"},{"location":"library/server/#methods","title":"Methods","text":""},{"location":"library/server/#lifecycle-methods","title":"Lifecycle Methods","text":""},{"location":"library/server/#async-start","title":"<code>async start()</code>","text":"<p>Start the UDP server and begin accepting connections.</p> <p>Notes: - Call this method before sending any packets to the emulator - Binds to the configured address and port - Logs server startup information - Required if not using context manager</p> <p>Example: <pre><code>device_manager = DeviceManager(DeviceRepository())\nserver = EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700)\nawait server.start()\ntry:\n    # Use server\n    pass\nfinally:\n    await server.stop()\n</code></pre></p>"},{"location":"library/server/#async-stop","title":"<code>async stop()</code>","text":"<p>Stop the UDP server and clean up resources.</p> <p>Notes: - Gracefully closes the UDP endpoint - Cleans up internal state - Safe to call multiple times - Automatically called by context manager</p>"},{"location":"library/server/#context-manager-protocol","title":"Context Manager Protocol","text":"<p>The server implements the async context manager protocol for clean resource management:</p>"},{"location":"library/server/#async-__aenter__","title":"<code>async __aenter__()</code>","text":"<p>Enter async context manager - automatically calls <code>start()</code>.</p>"},{"location":"library/server/#async-__aexit__","title":"<code>async __aexit__()</code>","text":"<p>Exit async context manager - automatically calls <code>stop()</code>.</p> <p>Recommended Usage: <pre><code>device_manager = DeviceManager(DeviceRepository())\nasync with EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700) as server:\n    # Server is automatically started\n    # Perform your tests\n    pass\n# Server is automatically stopped\n</code></pre></p>"},{"location":"library/server/#utility-methods","title":"Utility Methods","text":""},{"location":"library/server/#get_uptime_ns","title":"<code>get_uptime_ns()</code>","text":"<p>Get the server uptime in nanoseconds since startup.</p> <p>Returns: <code>int</code> - Nanoseconds elapsed since server started</p> <p>Notes: - Returns 0 if server hasn't started yet - Useful for performance testing and benchmarking - Uses monotonic clock for accurate timing</p> <p>Example: <pre><code>device_manager = DeviceManager(DeviceRepository())\nasync with EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700) as server:\n    await asyncio.sleep(1)\n    uptime_ns = server.get_uptime_ns()\n    uptime_ms = uptime_ns / 1_000_000\n    print(f\"Server uptime: {uptime_ms:.2f}ms\")\n</code></pre></p>"},{"location":"library/server/#invalidate_scenario_cache","title":"<code>invalidate_scenario_cache()</code>","text":"<p>Clear the internal scenario precedence cache.</p> <p>Notes: - Normally called automatically after scenario updates via API - Only needed if modifying scenario manager state outside of API - Safe to call - no side effects - Non-blocking operation</p> <p>Example: <pre><code>from lifx_emulator.scenarios import HierarchicalScenarioManager, ScenarioConfig\n\nmanager = HierarchicalScenarioManager()\ndevice_manager = DeviceManager(DeviceRepository())\nserver = EmulatedLifxServer(\n    devices, device_manager, \"127.0.0.1\", 56700, scenario_manager=manager\n)\n\nasync with server:\n    # Update scenarios externally\n    manager.set_global_scenario(ScenarioConfig(...))\n    # Invalidate cache to apply changes immediately\n    server.invalidate_scenario_cache()\n</code></pre></p>"},{"location":"library/server/#packet-routing","title":"Packet Routing","text":""},{"location":"library/server/#broadcast-packets","title":"Broadcast Packets","text":"<p>Packets with <code>tagged=True</code> or <code>target=000000000000</code> are forwarded to all devices:</p> <pre><code># GetService broadcasts are answered by all devices\n# Client discovers all emulated devices\n</code></pre>"},{"location":"library/server/#targeted-packets","title":"Targeted Packets","text":"<p>Packets with a specific target serial are routed to that device:</p> <pre><code># LightSetColor for d073d5000001 goes only to that device\n# Other devices don't see the packet\n</code></pre>"},{"location":"library/server/#unknown-targets","title":"Unknown Targets","text":"<p>Packets for unknown serial addresses are silently dropped:</p> <pre><code># Packet for d073d5999999 (not in server) is ignored\n# No error or response generated\n</code></pre>"},{"location":"library/server/#response-handling","title":"Response Handling","text":"<p>The server handles responses automatically:</p> <ol> <li>Device processes packet and returns response(s)</li> <li>Server packs response packets to bytes</li> <li>Server sends responses back to source address</li> <li>Multiple responses (e.g., multizone StateMultiZone) are sent sequentially</li> </ol>"},{"location":"library/server/#concurrency","title":"Concurrency","text":"<p>The server uses asyncio for concurrent operation:</p> <pre><code># Multiple clients can send packets concurrently\n# Each device processes packets independently\n# Responses are sent asynchronously\n</code></pre>"},{"location":"library/server/#error-handling","title":"Error Handling","text":"<p>The server handles errors gracefully:</p> <ul> <li>Invalid packets are logged and dropped</li> <li>Device exceptions are caught and logged</li> <li>Server continues running despite errors</li> <li>Malformed headers don't crash the server</li> </ul>"},{"location":"library/server/#lifecycle","title":"Lifecycle","text":""},{"location":"library/server/#startup","title":"Startup","text":"<ol> <li>Create UDP endpoint</li> <li>Bind to address and port</li> <li>Start receiving packets</li> <li>Log server start</li> </ol>"},{"location":"library/server/#runtime","title":"Runtime","text":"<ol> <li>Receive packet bytes</li> <li>Parse header</li> <li>Route to device(s)</li> <li>Get responses</li> <li>Send responses</li> </ol>"},{"location":"library/server/#shutdown","title":"Shutdown","text":"<ol> <li>Stop accepting packets</li> <li>Close UDP endpoint</li> <li>Clean up resources</li> <li>Log server stop</li> </ol>"},{"location":"library/server/#testing-integration","title":"Testing Integration","text":""},{"location":"library/server/#pytest-asyncio","title":"pytest-asyncio","text":"<pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer\nfrom lifx_emulator.factories import create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\n@pytest.fixture\ndef device_manager():\n    return DeviceManager(DeviceRepository())\n\n@pytest.fixture\nasync def lifx_server(device_manager):\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], device_manager, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_discovery(lifx_server):\n    # Test code using the server\n    pass\n</code></pre>"},{"location":"library/server/#module-scoped-fixture","title":"Module-Scoped Fixture","text":"<p>For faster tests, use module scope:</p> <pre><code>@pytest.fixture(scope=\"module\")\ndef device_manager():\n    return DeviceManager(DeviceRepository())\n\n@pytest.fixture(scope=\"module\")\nasync def lifx_server(device_manager):\n    devices = [create_color_light(f\"d073d500000{i}\") for i in range(5)]\n    server = EmulatedLifxServer(devices, device_manager, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"library/server/#next-steps","title":"Next Steps","text":"<ul> <li>Device API - EmulatedLifxDevice documentation</li> <li>Factory Functions - Device creation</li> <li>Integration Testing Tutorial - Integration test examples</li> </ul>"},{"location":"library/storage/","title":"Storage API Reference","text":"<p>Persistent storage for device state across emulator restarts</p> <p>The storage module provides asynchronous persistent storage of device state using JSON files on disk. When enabled, device state (color, power, label, zones, tiles, etc.) is automatically saved and restored across emulator sessions with high-performance non-blocking I/O.</p>"},{"location":"library/storage/#table-of-contents","title":"Table of Contents","text":""},{"location":"library/storage/#core-components","title":"Core Components","text":"<ul> <li>AsyncDeviceStorage - Async storage handler class</li> <li>File Format - JSON state file specification</li> <li>State Serialization - Converting state to/from JSON</li> </ul>"},{"location":"library/storage/#concepts","title":"Concepts","text":"<ul> <li>Storage Location - Where files are stored</li> <li>Device Lifecycle - State save/load during device lifecycle</li> <li>Backup and Restore - Managing saved states</li> <li>CLI Integration - Using persistent storage from CLI</li> </ul>"},{"location":"library/storage/#asyncdevicestorage","title":"AsyncDeviceStorage","text":"<p>Main class for handling asynchronous persistent device state storage with smart debouncing and batch writes.</p>"},{"location":"library/storage/#constructor","title":"Constructor","text":""},{"location":"library/storage/#asyncdevicestoragestorage_dir-path-str-default_storage_dir-debounce_ms-int-100-batch_size_threshold-int-50","title":"<code>AsyncDeviceStorage(storage_dir: Path | str = DEFAULT_STORAGE_DIR, debounce_ms: int = 100, batch_size_threshold: int = 50)</code>","text":"<p>Initialize an async storage handler for device state persistence.</p> <p>Parameters: - <code>storage_dir</code> (<code>Path | str</code>) - Directory to store state files (default: <code>~/.lifx-emulator</code>) - <code>debounce_ms</code> (<code>int</code>) - Milliseconds to wait before flushing pending saves (default: 100ms) - <code>batch_size_threshold</code> (<code>int</code>) - Flush early if queue exceeds this size (default: 50)</p> <p>Example: <pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\n# Use default location (~/.lifx-emulator)\nstorage = AsyncDeviceStorage()\n\n# Use custom location with custom debounce settings\nstorage = AsyncDeviceStorage(\n    \"/var/lib/lifx-emulator\",\n    debounce_ms=200,\n    batch_size_threshold=100\n)\n</code></pre></p>"},{"location":"library/storage/#methods","title":"Methods","text":""},{"location":"library/storage/#async-save_device_statedevice_state-devicestate-none","title":"<code>async save_device_state(device_state: DeviceState) -&gt; None</code>","text":"<p>Queue device state for saving (non-blocking async).</p> <p>Queues the device state for saving. The write is performed asynchronously with debouncing to minimize I/O overhead.</p> <p>Parameters: - <code>device_state</code> (<code>DeviceState</code>) - Device state to persist</p> <p>Returns: <code>None</code> (task runs in background)</p> <p>Example: <pre><code>import asyncio\nfrom lifx_emulator.devices import DeviceState\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\nasync def main():\n    state = DeviceState(serial=\"d073d5000001\", label=\"Living Room\", power_level=65535)\n    storage = AsyncDeviceStorage()\n\n    # Queue state for async save (non-blocking)\n    await storage.save_device_state(state)\n\n    # File will be created at: ~/.lifx-emulator/d073d5000001.json\n\nasyncio.run(main())\n</code></pre></p>"},{"location":"library/storage/#load_device_stateserial-str-dictstr-any-none","title":"<code>load_device_state(serial: str) -&gt; dict[str, Any] | None</code>","text":"<p>Load device state from disk (synchronous).</p> <p>Reads the JSON file for the specified serial and returns the deserialized state dictionary. Returns <code>None</code> if the file doesn't exist or cannot be loaded.</p> <p>Parameters: - <code>serial</code> (<code>str</code>) - Device serial to load</p> <p>Returns: <code>dict[str, Any] | None</code> - State dictionary or <code>None</code> if not found</p> <p>Example: <pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\nstate_dict = storage.load_device_state(\"d073d5000001\")\n\nif state_dict:\n    print(f\"Label: {state_dict['label']}\")\n    print(f\"Power: {state_dict['power_level']}\")\nelse:\n    print(\"No saved state found\")\n</code></pre></p>"},{"location":"library/storage/#delete_device_stateserial-str-none","title":"<code>delete_device_state(serial: str) -&gt; None</code>","text":"<p>Delete saved state for a device (synchronous).</p> <p>Removes the JSON file for the specified serial from disk.</p> <p>Parameters: - <code>serial</code> (<code>str</code>) - Device serial to delete</p> <p>Returns: <code>None</code></p> <p>Example: <pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\nstorage.delete_device_state(\"d073d5000001\")\n# Removes: ~/.lifx-emulator/d073d5000001.json\n</code></pre></p>"},{"location":"library/storage/#list_devices-liststr","title":"<code>list_devices() -&gt; list[str]</code>","text":"<p>List all devices with saved state (synchronous).</p> <p>Returns a list of device serials that have saved state files in the storage directory.</p> <p>Returns: <code>list[str]</code> - List of device serials</p> <p>Example: <pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\ndevices = storage.list_devices()\nprint(f\"Found {len(devices)} saved devices:\")\nfor serial in devices:\n    print(f\"  - {serial}\")\n</code></pre></p>"},{"location":"library/storage/#delete_all_device_states-int","title":"<code>delete_all_device_states() -&gt; int</code>","text":"<p>Delete all saved device states (synchronous).</p> <p>Removes all <code>.json</code> files from the storage directory.</p> <p>Returns: <code>int</code> - Number of devices deleted</p> <p>Example: <pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\ncount = storage.delete_all_device_states()\nprint(f\"Deleted {count} device states\")\n</code></pre></p>"},{"location":"library/storage/#file-format","title":"File Format","text":"<p>Device state is saved as JSON files with the naming convention <code>{serial}.json</code>.</p>"},{"location":"library/storage/#json-structure","title":"JSON Structure","text":"<pre><code>{\n  \"serial\": \"d073d5000001\",\n  \"product\": 27,\n  \"label\": \"Living Room Light\",\n  \"power_level\": 65535,\n  \"color\": {\n    \"hue\": 21845,\n    \"saturation\": 65535,\n    \"brightness\": 32768,\n    \"kelvin\": 3500\n  },\n  \"location_id\": \"01234567-89ab-cdef-0123-456789abcdef\",\n  \"location_label\": \"Home\",\n  \"group_id\": \"fedcba98-7654-3210-fedc-ba9876543210\",\n  \"group_label\": \"Living Room\",\n  \"infrared_brightness\": 0,\n  \"hev_cycle_duration_s\": 7200,\n  \"hev_cycle_remaining_s\": 0,\n  \"zone_count\": 0,\n  \"zone_colors\": [],\n  \"tile_count\": 0,\n  \"tile_devices\": []\n}\n</code></pre>"},{"location":"library/storage/#multizone-device-example","title":"Multizone Device Example","text":"<pre><code>{\n  \"serial\": \"d073d5000002\",\n  \"product\": 32,\n  \"label\": \"Kitchen Strip\",\n  \"power_level\": 65535,\n  \"color\": {\n    \"hue\": 0,\n    \"saturation\": 0,\n    \"brightness\": 65535,\n    \"kelvin\": 3500\n  },\n  \"zone_count\": 16,\n  \"zone_colors\": [\n    {\"hue\": 0, \"saturation\": 65535, \"brightness\": 32768, \"kelvin\": 3500},\n    {\"hue\": 21845, \"saturation\": 65535, \"brightness\": 32768, \"kelvin\": 3500},\n    ...\n  ]\n}\n</code></pre>"},{"location":"library/storage/#matrix-device-example","title":"Matrix Device Example","text":"<pre><code>{\n  \"serial\": \"d073d5000003\",\n  \"product\": 55,\n  \"label\": \"Wall Art\",\n  \"power_level\": 65535,\n  \"tile_count\": 5,\n  \"tile_width\": 8,\n  \"tile_height\": 8,\n  \"tile_devices\": [\n    {\n      \"user_x\": 0.0,\n      \"user_y\": 0.0,\n      \"width\": 8,\n      \"height\": 8,\n      \"colors\": [...]\n    },\n    ...\n  ]\n}\n</code></pre>"},{"location":"library/storage/#state-serialization","title":"State Serialization","text":"<p>The <code>state_serializer</code> module handles conversion between DeviceState objects and JSON-compatible dictionaries.</p>"},{"location":"library/storage/#serialize_device_statedevice_state-devicestate-dict","title":"<code>serialize_device_state(device_state: DeviceState) -&gt; dict</code>","text":"<p>Convert DeviceState to JSON-compatible dictionary.</p> <p>Parameters: - <code>device_state</code> (<code>DeviceState</code>) - State to serialize</p> <p>Returns: <code>dict</code> - JSON-compatible dictionary</p> <p>Example: <pre><code>from lifx_emulator.devices import DeviceState\nfrom lifx_emulator.state_serializer import serialize_device_state\n\nstate = DeviceState(serial=\"d073d5000001\", label=\"Test Light\")\nstate_dict = serialize_device_state(state)\n# state_dict is JSON-compatible dict\n</code></pre></p>"},{"location":"library/storage/#deserialize_device_statestate_dict-dict-dict","title":"<code>deserialize_device_state(state_dict: dict) -&gt; dict</code>","text":"<p>Convert JSON dictionary back to DeviceState-compatible format.</p> <p>Parameters: - <code>state_dict</code> (<code>dict</code>) - Serialized state dictionary</p> <p>Returns: <code>dict</code> - Deserialized state dictionary</p> <p>Example: <pre><code>from lifx_emulator.state_serializer import deserialize_device_state\n\nloaded_dict = storage.load_device_state(\"d073d5000001\")\nif loaded_dict:\n    # Already deserialized by load_device_state\n    print(f\"Label: {loaded_dict['label']}\")\n</code></pre></p>"},{"location":"library/storage/#storage-location","title":"Storage Location","text":""},{"location":"library/storage/#default-location","title":"Default Location","text":"<p>By default, device state files are stored in:</p> <ul> <li>Linux/macOS: <code>~/.lifx-emulator/</code></li> <li>Windows: <code>C:\\Users\\{username}\\.lifx-emulator\\</code></li> </ul>"},{"location":"library/storage/#custom-location","title":"Custom Location","text":"<p>You can specify a custom storage directory:</p> <pre><code>from pathlib import Path\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\n# Project-specific storage\nstorage = AsyncDeviceStorage(\"./lifx_state\")\n\n# System-wide storage (requires permissions)\nstorage = AsyncDeviceStorage(\"/var/lib/lifx-emulator\")\n\n# Temporary storage (for testing)\nimport tempfile\nstorage = AsyncDeviceStorage(tempfile.mkdtemp())\n</code></pre>"},{"location":"library/storage/#device-lifecycle","title":"Device Lifecycle","text":""},{"location":"library/storage/#state-restoration-on-device-creation","title":"State Restoration on Device Creation","text":"<p>When creating a device with storage enabled, existing state is automatically restored:</p> <pre><code>from lifx_emulator.factories import create_color_light\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\n\n# First run: Create device and save state\ndevice = create_color_light(serial=\"d073d5000001\", storage=storage)\ndevice.state.label = \"Living Room\"\ndevice.state.power_level = 65535\nawait storage.save_device_state(device.state)  # Queue async save\n\n# Later run: State is automatically restored\ndevice = create_color_light(serial=\"d073d5000001\", storage=storage)\nprint(device.state.label)  # \"Living Room\"\nprint(device.state.power_level)  # 65535\n</code></pre>"},{"location":"library/storage/#automatic-state-saving","title":"Automatic State Saving","text":"<p>Device state is automatically saved when:</p> <ul> <li>Device properties are updated via protocol packets (SetColor, SetPower, SetLabel, etc.)</li> <li>Device is properly shut down (via context manager or explicit save)</li> </ul> <p>Example with automatic saving: <pre><code>from lifx_emulator.devices import EmulatedLifxDevice, DeviceState\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\nfrom lifx_emulator.protocol.header import LifxHeader\nfrom lifx_emulator.protocol.packets import Light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\nstorage = AsyncDeviceStorage()\nstate = DeviceState(serial=\"d073d5000001\")\ndevice = EmulatedLifxDevice(state, storage=storage)\n\n# Simulate SetLabel packet\nheader = LifxHeader(pkt_type=24, source=1, sequence=1)\npacket = Light.SetLabel(label=\"Kitchen Light\")\ndevice.process_packet(header, packet)\n\n# State is automatically saved after processing\n# Restarting the emulator will restore \"Kitchen Light\" label\n</code></pre></p>"},{"location":"library/storage/#manual-state-management","title":"Manual State Management","text":"<p>For fine-grained control, use manual save/load:</p> <pre><code>import asyncio\n\n# Manual async save\nawait storage.save_device_state(device.state)\n\n# Manual load (during initialization)\nstate_dict = storage.load_device_state(serial)\nif state_dict:\n    # Apply loaded state to device\n    device.state.label = state_dict['label']\n    device.state.power_level = state_dict['power_level']\n    # ... etc\n</code></pre>"},{"location":"library/storage/#backup-and-restore","title":"Backup and Restore","text":""},{"location":"library/storage/#creating-backups","title":"Creating Backups","text":"<pre><code>import shutil\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\n\n# Backup entire storage directory\nshutil.copytree(storage.storage_dir, \"/backup/lifx-emulator-backup\")\n\n# Backup single device\ndevice_path = storage.storage_dir / \"d073d5000001.json\"\nshutil.copy(device_path, \"/backup/d073d5000001.json.bak\")\n</code></pre>"},{"location":"library/storage/#restoring-from-backup","title":"Restoring from Backup","text":"<pre><code>import shutil\n\n# Restore entire storage directory\nshutil.copytree(\"/backup/lifx-emulator-backup\", \"~/.lifx-emulator\", dirs_exist_ok=True)\n\n# Restore single device\nshutil.copy(\"/backup/d073d5000001.json.bak\", \"~/.lifx-emulator/d073d5000001.json\")\n</code></pre>"},{"location":"library/storage/#exporting-device-state","title":"Exporting Device State","text":"<pre><code>import json\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\n\n# Export all device states to a single file\nall_states = {}\nfor serial in storage.list_devices():\n    state = storage.load_device_state(serial)\n    if state:\n        all_states[serial] = state\n\nwith open(\"lifx-export.json\", \"w\") as f:\n    json.dump(all_states, f, indent=2)\n</code></pre>"},{"location":"library/storage/#importing-device-state","title":"Importing Device State","text":"<pre><code>import json\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\nfrom lifx_emulator.devices import DeviceState\n\nstorage = AsyncDeviceStorage()\n\n# Import from exported file\nwith open(\"lifx-export.json\") as f:\n    all_states = json.load(f)\n\nfor serial, state_dict in all_states.items():\n    # Create device state and save\n    state = DeviceState(**state_dict)\n    storage.save_device_state(state)\n\nprint(f\"Imported {len(all_states)} devices\")\n</code></pre>"},{"location":"library/storage/#cli-integration","title":"CLI Integration","text":""},{"location":"library/storage/#enabling-persistent-storage-from-cli","title":"Enabling Persistent Storage from CLI","text":"<p>Use the <code>--persistent</code> flag to enable state persistence:</p> <pre><code># Enable persistence with default location (~/.lifx-emulator)\nlifx-emulator --persistent\n\n# Create devices and modify state\n# State changes are automatically saved\n\n# Stop and restart emulator - state is restored\nlifx-emulator --persistent\n</code></pre>"},{"location":"library/storage/#viewing-saved-devices","title":"Viewing Saved Devices","text":"<pre><code># List saved devices\nls ~/.lifx-emulator/\n\n# View device state\ncat ~/.lifx-emulator/d073d5000001.json\n\n# Pretty print\npython -m json.tool ~/.lifx-emulator/d073d5000001.json\n</code></pre>"},{"location":"library/storage/#clearing-persistent-storage","title":"Clearing Persistent Storage","text":"<pre><code># Remove all saved states\nrm -rf ~/.lifx-emulator/\n\n# Remove specific device\nrm ~/.lifx-emulator/d073d5000001.json\n</code></pre>"},{"location":"library/storage/#programmatic-cli-access","title":"Programmatic CLI Access","text":"<pre><code>from lifx_emulator.async_storage import AsyncDeviceStorage\n\nstorage = AsyncDeviceStorage()\n\n# List devices\nprint(\"Saved devices:\")\nfor serial in storage.list_devices():\n    state = storage.load_device_state(serial)\n    if state:\n        print(f\"  {serial}: {state.get('label', 'Unnamed')}\")\n\n# Clear all\ncount = storage.delete_all_device_states()\nprint(f\"Cleared {count} device states\")\n</code></pre>"},{"location":"library/storage/#best-practices","title":"Best Practices","text":""},{"location":"library/storage/#1-always-use-same-serial-numbers","title":"1. Always Use Same Serial Numbers","text":"<p>For state persistence to work, devices must use consistent serial numbers:</p> <pre><code># Good: Fixed serial\ndevice = create_color_light(serial=\"d073d5000001\", storage=storage)\n\n# Bad: Random serial (state won't persist)\nimport uuid\ndevice = create_color_light(serial=uuid.uuid4().hex[:12], storage=storage)\n</code></pre>"},{"location":"library/storage/#2-handle-storage-errors-gracefully","title":"2. Handle Storage Errors Gracefully","text":"<p>Storage operations may fail due to permissions, disk space, etc:</p> <pre><code>try:\n    storage.save_device_state(device.state)\nexcept Exception as e:\n    logger.error(\"Failed to save state: %s\", e)\n    # Continue without persistence\n</code></pre>"},{"location":"library/storage/#3-validate-restored-state","title":"3. Validate Restored State","text":"<p>Always validate restored state before using it:</p> <pre><code>state_dict = storage.load_device_state(serial)\nif state_dict:\n    # Validate product ID matches\n    if state_dict.get('product') != expected_product:\n        logger.warning(\"Product ID mismatch, ignoring saved state\")\n        state_dict = None\n</code></pre>"},{"location":"library/storage/#4-use-context-managers-for-cleanup","title":"4. Use Context Managers for Cleanup","text":"<p>Ensure state is saved on cleanup:</p> <pre><code>import asyncio\nfrom contextlib import asynccontextmanager\n\n@asynccontextmanager\nasync def managed_device(serial, storage):\n    device = create_color_light(serial=serial, storage=storage)\n    try:\n        yield device\n    finally:\n        # Ensure state is saved on exit\n        await storage.save_device_state(device.state)\n\nasync def main():\n    async with managed_device(\"d073d5000001\", storage) as device:\n        # Use device\n        device.state.power_level = 65535\n    # State automatically saved on exit\n\nasyncio.run(main())\n</code></pre>"},{"location":"library/storage/#5-regular-backups","title":"5. Regular Backups","text":"<p>For production use, create regular backups:</p> <pre><code>#!/bin/bash\n# Backup script\nBACKUP_DIR=\"/backup/lifx-emulator/$(date +%Y%m%d)\"\nmkdir -p \"$BACKUP_DIR\"\ncp -r ~/.lifx-emulator/* \"$BACKUP_DIR/\"\necho \"Backed up to $BACKUP_DIR\"\n</code></pre>"},{"location":"library/storage/#troubleshooting","title":"Troubleshooting","text":""},{"location":"library/storage/#state-not-persisting","title":"State Not Persisting","text":"<p>Problem: Changes aren't saved between restarts</p> <p>Solutions: 1. Verify <code>--persistent</code> flag is used 2. Check storage directory exists and is writable 3. Ensure consistent serial numbers 4. Check logs for save errors</p> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n# Will show \"Saved state for device...\" messages\n</code></pre>"},{"location":"library/storage/#permission-errors","title":"Permission Errors","text":"<p>Problem: Cannot write to storage directory</p> <p>Solutions: 1. Check directory permissions: <code>ls -la ~/.lifx-emulator</code> 2. Use custom directory with proper permissions 3. Run with appropriate user permissions</p>"},{"location":"library/storage/#corrupted-state-files","title":"Corrupted State Files","text":"<p>Problem: Invalid JSON or deserialization errors</p> <p>Solutions: <pre><code># Validate and repair\nimport json\nfrom pathlib import Path\n\nstorage_dir = Path.home() / \".lifx-emulator\"\nfor file_path in storage_dir.glob(\"*.json\"):\n    try:\n        with open(file_path) as f:\n            json.load(f)\n        print(f\"\u2713 {file_path.name}\")\n    except json.JSONDecodeError:\n        print(f\"\u2717 {file_path.name} - CORRUPTED\")\n        # Delete or repair\n        file_path.unlink()\n</code></pre></p>"},{"location":"library/storage/#references","title":"References","text":"<p>Source Files: - <code>src/lifx_emulator/storage.py</code> - Storage implementation - <code>src/lifx_emulator/state_serializer.py</code> - State serialization - <code>src/lifx_emulator/async_storage.py</code> - Async storage variant</p> <p>Related Documentation: - Device API - Device state structure - CLI Reference - Using <code>--persistent</code> flag - Getting Started - Quick start with persistence - Best Practices - Storage best practices</p> <p>See Also: - Persistent storage is optional and disabled by default - Storage uses standard JSON format for easy inspection and editing - State files can be manually edited (stop emulator first) - Storage directory can be version controlled for test fixtures</p>"},{"location":"reference/glossary/","title":"Glossary","text":"<p>Terminology and concepts used in the LIFX Emulator documentation.</p>"},{"location":"reference/glossary/#general-terms","title":"General Terms","text":""},{"location":"reference/glossary/#lifx","title":"LIFX","text":"<p>A brand of WiFi-enabled smart LED light bulbs and accessories that use the LIFX LAN Protocol for local network control.</p>"},{"location":"reference/glossary/#lifx-lan-protocol","title":"LIFX LAN Protocol","text":"<p>The binary UDP-based protocol used to communicate with LIFX devices over a local network. Documented at https://lan.developer.lifx.com</p>"},{"location":"reference/glossary/#emulator","title":"Emulator","text":"<p>A software implementation that mimics the behavior of physical LIFX devices for testing purposes without requiring actual hardware.</p>"},{"location":"reference/glossary/#device","title":"Device","text":"<p>A virtual or physical LIFX product (bulb, strip, tile, etc.) that responds to LIFX protocol commands.</p>"},{"location":"reference/glossary/#server","title":"Server","text":"<p>The <code>EmulatedLifxServer</code> instance that listens for UDP packets and routes them to emulated devices.</p>"},{"location":"reference/glossary/#device-types","title":"Device Types","text":""},{"location":"reference/glossary/#color-light","title":"Color Light","text":"<p>A LIFX device with full RGB color control, including hue, saturation, brightness, and color temperature. Examples: LIFX A19, BR30, GU10.</p>"},{"location":"reference/glossary/#color-temperature-light","title":"Color Temperature Light","text":"<p>A LIFX device that only supports variable white color (warm to cool) without RGB color capability. Also called \"white-to-warm\" lights. Examples: LIFX Mini White to Warm.</p>"},{"location":"reference/glossary/#infrared-light","title":"Infrared Light","text":"<p>A color light with additional infrared capability for night vision. The infrared LED is separate from the visible light. Examples: LIFX A19 Night Vision.</p>"},{"location":"reference/glossary/#hev-light","title":"HEV Light","text":"<p>A color light with High Energy Visible (HEV) light capability for anti-bacterial sanitization. Example: LIFX Clean.</p>"},{"location":"reference/glossary/#multizone-device","title":"Multizone Device","text":"<p>A LIFX device with multiple independently controllable zones arranged linearly (1D array). Examples: LIFX Z (strip), LIFX Beam, LIFX Neon.</p>"},{"location":"reference/glossary/#extended-multizone","title":"Extended Multizone","text":"<p>Multizone devices that support the extended multizone packets. These devices also support standard multizone packets for backward compatibility.</p>"},{"location":"reference/glossary/#matrix-device","title":"Matrix Device","text":"<p>A LIFX device with zones arranged in a 2D matrix (width \u00d7 height). Examples: LIFX Tile, LIFX Candle, LIFX Ceiling.</p>"},{"location":"reference/glossary/#tile-device","title":"Tile Device","text":"<p>Historical term for matrix devices. Originally referred to LIFX Tile, but now used more broadly for any matrix device.</p>"},{"location":"reference/glossary/#chain","title":"Chain","text":"<p>A set of tiles connected together on a single device. Most modern matrix devices have a single tile per chain. The original LIFX Tile supported up to 5 tiles per chain.</p>"},{"location":"reference/glossary/#device-identification","title":"Device Identification","text":""},{"location":"reference/glossary/#serial","title":"Serial","text":"<p>A 12-character hexadecimal string representing a unique device identifier. Examples: <code>d073d5000001</code>, <code>d073d8123456</code>.</p>"},{"location":"reference/glossary/#serial-bytes","title":"Serial Bytes","text":"<p>The 6-byte binary representation of a serial number. The LIFX protocol uses 6-byte MAC addresses as device identifiers.</p>"},{"location":"reference/glossary/#target","title":"Target","text":"<p>An 8-byte field in the LIFX packet header consisting of:</p> <ul> <li>6 bytes: Device MAC address (serial bytes)</li> <li>2 bytes: Reserved (always 0x00 0x00)</li> </ul> <p>When <code>target</code> is all zeros (<code>00:00:00:00:00:00:00:00</code>), the packet is a broadcast.</p>"},{"location":"reference/glossary/#mac-address","title":"MAC Address","text":"<p>Media Access Control address - a 6-byte unique identifier for network devices.</p>"},{"location":"reference/glossary/#product-information","title":"Product Information","text":""},{"location":"reference/glossary/#product-id","title":"Product ID","text":"<p>An integer identifying a specific LIFX product model. Examples:</p> <ul> <li>27: LIFX A19</li> <li>32: LIFX Z</li> <li>55: LIFX Tile</li> <li>90: LIFX Clean</li> </ul>"},{"location":"reference/glossary/#specification","title":"Specification","text":"<p>A device definition that matches a real-world product. The LIFX Emulator uses its specification library to emulate LIFX devices as accurately as possible. Specifications include product defaults like zone counts for multizone devices and tile dimensions for matrix devices.</p>"},{"location":"reference/glossary/#vendor-id","title":"Vendor ID","text":"<p>An integer identifying the manufacturer. For LIFX devices, this is always <code>1</code>.</p>"},{"location":"reference/glossary/#firmware-version","title":"Firmware Version","text":"<p>The software version running on a LIFX device, typically reported as major.minor (e.g., <code>3.70</code>).</p>"},{"location":"reference/glossary/#packet-structure","title":"Packet Structure","text":""},{"location":"reference/glossary/#packet","title":"Packet","text":"<p>A complete LIFX protocol message consisting of a header (36 bytes) and payload (0-1024 bytes).</p>"},{"location":"reference/glossary/#header","title":"Header","text":"<p>The first 36 bytes of every LIFX packet containing metadata:</p> <ul> <li>Protocol version</li> <li>Source (client identifier)</li> <li>Target (device serial)</li> <li>Flags (tagged, ack_required, res_required)</li> <li>Sequence number</li> <li>Packet type</li> </ul>"},{"location":"reference/glossary/#payload","title":"Payload","text":"<p>The data portion of a LIFX packet after the 36-byte header. Contains packet-specific fields.</p>"},{"location":"reference/glossary/#packet-type","title":"Packet Type","text":"<p>A 16-bit integer identifying the type of LIFX message. Examples:</p> <ul> <li>2: GetService (discovery)</li> <li>101: LightGetPower</li> <li>102: LightSetColor</li> <li>107: LightState (color)</li> </ul>"},{"location":"reference/glossary/#protocol-flags","title":"Protocol Flags","text":""},{"location":"reference/glossary/#tagged","title":"Tagged","text":"<p>A header flag indicating whether a packet is broadcast or unicast:</p> <ul> <li><code>tagged=True</code>: Broadcast packet (target is ignored)</li> <li><code>tagged=False</code>: Unicast packet (target specifies device serial)</li> </ul>"},{"location":"reference/glossary/#broadcast","title":"Broadcast","text":"<p>A packet sent to all devices on the network. Indicated by <code>tagged=True</code> in the header.</p>"},{"location":"reference/glossary/#unicast","title":"Unicast","text":"<p>A packet sent to a specific device. Indicated by <code>tagged=False</code> and a specific target serial in the header.</p>"},{"location":"reference/glossary/#ack-required","title":"Ack Required","text":"<p>A header flag (<code>ack_required</code>) indicating the sender wants an acknowledgment (packet type 45) when the packet is received.</p>"},{"location":"reference/glossary/#res-required","title":"Res Required","text":"<p>A header flag (<code>res_required</code>) indicating the sender wants a state response packet (not just an acknowledgment). Devices will send a state response back to all get packets, regardless of whether this flag is set or not. If this flag is set in the header of a set packet, and the set packet changed the visible state of the device, the response will contain the state prior to the change.</p>"},{"location":"reference/glossary/#acknowledgment","title":"Acknowledgment","text":"<p>A simple response packet (type 45) confirming receipt of a command. Sent when <code>ack_required=True</code> in the received packet's header.</p>"},{"location":"reference/glossary/#response","title":"Response","text":"<p>A state packet containing requested information (e.g., LightState, StatePower). Sent in reply to the corresponding get packet.</p>"},{"location":"reference/glossary/#zone-and-tile-concepts","title":"Zone and Tile Concepts","text":""},{"location":"reference/glossary/#zone","title":"Zone","text":"<p>A single independently controllable color segment on a multizone or matrix device.</p>"},{"location":"reference/glossary/#zone-index","title":"Zone Index","text":"<p>Zero-based position of a zone:</p> <ul> <li>Multizone: 0 to (zone_count - 1)</li> <li>Matrix: Varies by device (row-major order)</li> </ul>"},{"location":"reference/glossary/#zone-count","title":"Zone Count","text":"<p>Total number of zones on a multizone device. Examples:</p> <ul> <li>LIFX Z: 16 zones (2 meters, 8 zones per meter)</li> <li>LIFX Beam: 80 zones (10 zones per beam \u00d7 8 beams)</li> </ul>"},{"location":"reference/glossary/#tile","title":"Tile","text":"<p>One physical tile in a chain (matrix devices). Most modern devices have 1 tile per chain.</p>"},{"location":"reference/glossary/#tile-count","title":"Tile Count","text":"<p>Number of tiles in a chain. Default values:</p> <ul> <li>LIFX Tile: 5 tiles per chain</li> <li>LIFX Candle: 1 tile</li> <li>LIFX Ceiling: 1 tile</li> </ul>"},{"location":"reference/glossary/#tile-width","title":"Tile Width","text":"<p>Number of zones horizontally on a single tile. Examples:</p> <ul> <li>LIFX Tile: 8 (8\u00d78 grid)</li> <li>LIFX Candle: 5 (5\u00d76 grid)</li> <li>LIFX Ceiling 26\"\u00d713\": 16 (16\u00d78 grid)</li> </ul>"},{"location":"reference/glossary/#tile-height","title":"Tile Height","text":"<p>Number of zones vertically on a single tile. Examples:</p> <ul> <li>LIFX Tile: 8 (8\u00d78 grid)</li> <li>LIFX Candle: 6 (5\u00d76 grid)</li> <li>LIFX Ceiling 26\"\u00d713\": 8 (16\u00d78 grid)</li> </ul>"},{"location":"reference/glossary/#get64-set64","title":"Get64 / Set64","text":"<p>Protocol packets (types 707 and 715) for retrieving or setting up to 64 zones on a matrix device at once. Uses a rectangle specification (x, y, width) to select zones.</p>"},{"location":"reference/glossary/#device-chain","title":"Device Chain","text":"<p>Protocol packet (type 701/702) that describes the tile configuration: number of tiles, dimensions, and positions.</p>"},{"location":"reference/glossary/#color-and-light","title":"Color and Light","text":""},{"location":"reference/glossary/#hsbk","title":"HSBK","text":"<p>HSBK is an acronym that refers to Hue, Saturation, Brightness, and Kelvin: the color representation used by LIFX.</p>"},{"location":"reference/glossary/#hue","title":"Hue","text":"<p>The color on the color wheel, represented as 0-65535 (maps to 0\u00b0 to 360\u00b0).</p>"},{"location":"reference/glossary/#saturation","title":"Saturation","text":"<p>The intensity of color, from 0 (white/gray) to 65535 (fully saturated color).</p>"},{"location":"reference/glossary/#brightness","title":"Brightness","text":"<p>The light intensity, from 0 (off) to 65535 (maximum brightness).</p>"},{"location":"reference/glossary/#kelvin","title":"Kelvin","text":"<p>Color temperature measured in Kelvin. The LIFX smart phone app uses the following names for particular Kelvin values:</p> <ul> <li>1500K: Candlelight</li> <li>2000K: Sunset</li> <li>2200K: Amber</li> <li>2500K: Ultra Warm</li> <li>2700K: Incandescent</li> <li>3000K: Warm</li> <li>3200K: Neutral Warm</li> <li>3500K: Neutral</li> <li>4000K: Cool</li> <li>4500K: Cool Daylight</li> <li>5000K: Soft Daylight</li> <li>5600K: Daylight</li> <li>6000K: Noon Daylight</li> <li>6500K: Bright Daylight</li> <li>7000K: Cloudy Daylight</li> <li>7500K: Blue Daylight</li> <li>8000K: Blue Overcast</li> <li>9000K: Blue Ice</li> </ul>"},{"location":"reference/glossary/#power-level","title":"Power Level","text":"<p>Device power state:</p> <ul> <li>0: Off</li> <li>65535: On</li> </ul>"},{"location":"reference/glossary/#testing-concepts","title":"Testing Concepts","text":""},{"location":"reference/glossary/#test-scenario","title":"Test Scenario","text":"<p>Configuration that modifies emulator behavior for testing error conditions. Examples: packet dropping, response delays, malformed packets.</p>"},{"location":"reference/glossary/#mock","title":"Mock","text":"<p>A test double that simulates the behavior of real code. Different from an emulator - mocks are simpler and less accurate.</p>"},{"location":"reference/glossary/#integration-test","title":"Integration Test","text":"<p>A test that verifies multiple components working together. The emulator is ideal for integration tests of LIFX client libraries.</p>"},{"location":"reference/glossary/#unit-test","title":"Unit Test","text":"<p>A test of a single component in isolation. The emulator is typically overkill for unit tests - use mocks instead.</p>"},{"location":"reference/glossary/#packet-testing","title":"Packet Testing","text":""},{"location":"reference/glossary/#drop-packets","title":"Drop Packets","text":"<p>A test scenario where the emulator silently ignores specific packet types, simulating network packet loss or device unresponsiveness.</p>"},{"location":"reference/glossary/#response-delays","title":"Response Delays","text":"<p>A test scenario where the emulator waits a specified time before responding to packets, simulating slow devices or network latency.</p>"},{"location":"reference/glossary/#malformed-packets","title":"Malformed Packets","text":"<p>A test scenario where the emulator returns corrupted or truncated response packets to test client error handling.</p>"},{"location":"reference/glossary/#invalid-field-values","title":"Invalid Field Values","text":"<p>A test scenario where the emulator returns packets with all bytes set to 0xFF, testing client validation logic.</p>"},{"location":"reference/glossary/#partial-responses","title":"Partial Responses","text":"<p>A test scenario where the emulator returns incomplete state data (e.g., only half the zones), testing client robustness.</p>"},{"location":"reference/glossary/#network-concepts","title":"Network Concepts","text":""},{"location":"reference/glossary/#udp","title":"UDP","text":"<p>User Datagram Protocol - a connectionless network protocol. LIFX uses UDP for fast, low-latency communication.</p>"},{"location":"reference/glossary/#port","title":"Port","text":"<p>A network endpoint identifier. The default LIFX port is 56700 (UDP).</p>"},{"location":"reference/glossary/#bind-address","title":"Bind Address","text":"<p>The IP address a server listens on:</p> <ul> <li><code>127.0.0.1</code>: Localhost only (not discoverable on network)</li> <li><code>0.0.0.0</code>: All network interfaces (discoverable on network)</li> <li>Specific IP: Single interface only</li> </ul>"},{"location":"reference/glossary/#discovery","title":"Discovery","text":"<p>The process of finding LIFX devices on the network by sending GetService (type 2) broadcast packets.</p>"},{"location":"reference/glossary/#storage-and-persistence","title":"Storage and Persistence","text":""},{"location":"reference/glossary/#persistent-storage","title":"Persistent Storage","text":"<p>The emulator's optional feature to save device state to disk across restarts using JSON files.</p>"},{"location":"reference/glossary/#storage-directory","title":"Storage Directory","text":"<p>The directory where persistent state is saved. Default: <code>~/.lifx-emulator/</code></p>"},{"location":"reference/glossary/#device-state","title":"Device State","text":"<p>All the current settings of a device: color, power, label, location, group, zones, tiles, etc.</p>"},{"location":"reference/glossary/#state-file","title":"State File","text":"<p>A JSON file storing the persistent state of a single device, named by serial (e.g., <code>d073d5000001.json</code>).</p>"},{"location":"reference/glossary/#http-api","title":"HTTP API","text":""},{"location":"reference/glossary/#api-server","title":"API Server","text":"<p>The optional HTTP server (<code>--api</code>) for monitoring and managing the emulator at runtime.</p>"},{"location":"reference/glossary/#openapi","title":"OpenAPI","text":"<p>A standard specification for describing REST APIs. The emulator API provides an OpenAPI 3.1.0 schema.</p>"},{"location":"reference/glossary/#swagger-ui","title":"Swagger UI","text":"<p>An interactive web interface for testing REST APIs, available at <code>/docs</code> when the API server is running.</p>"},{"location":"reference/glossary/#redoc","title":"ReDoc","text":"<p>A documentation-focused web interface for REST APIs, available at <code>/redoc</code> when the API server is running.</p>"},{"location":"reference/glossary/#activity-log","title":"Activity Log","text":"<p>A record of recent packet transmissions (TX) and receptions (RX) shown in the API dashboard.</p>"},{"location":"reference/glossary/#capabilities","title":"Capabilities","text":""},{"location":"reference/glossary/#has_color","title":"has_color","text":"<p>A boolean indicating whether a device supports RGB color (not just white).</p>"},{"location":"reference/glossary/#has_multizone","title":"has_multizone","text":"<p>A boolean indicating whether a device has multiple independently controllable zones in a linear arrangement.</p>"},{"location":"reference/glossary/#has_matrix","title":"has_matrix","text":"<p>A boolean indicating whether a device has zones arranged in a 2D matrix.</p>"},{"location":"reference/glossary/#has_infrared","title":"has_infrared","text":"<p>A boolean indicating whether a device has infrared LED capability.</p>"},{"location":"reference/glossary/#has_hev","title":"has_hev","text":"<p>A boolean indicating whether a device has HEV (germicidal UV-C) capability.</p>"},{"location":"reference/glossary/#factory-functions","title":"Factory Functions","text":""},{"location":"reference/glossary/#create_color_light","title":"create_color_light()","text":"<p>Factory function that creates a full RGB color light (LIFX A19, product ID 27).</p>"},{"location":"reference/glossary/#create_multizone_light","title":"create_multizone_light()","text":"<p>Factory function that creates a multizone device (LIFX Z or Beam depending on <code>extended_multizone</code> parameter).</p>"},{"location":"reference/glossary/#create_tile_device","title":"create_tile_device()","text":"<p>Factory function that creates a matrix device (LIFX Tile by default, product ID 55).</p>"},{"location":"reference/glossary/#create_device","title":"create_device()","text":"<p>Universal factory function that creates any device by product ID from the registry.</p>"},{"location":"reference/glossary/#see-also","title":"See Also","text":"<ul> <li>FAQ - Common questions and answers</li> <li>Troubleshooting - Solutions to common problems</li> <li>Device Types - Detailed device type documentation</li> <li>Protocol Types - Protocol data structures</li> <li>LIFX LAN Protocol - Official protocol specification</li> </ul>"},{"location":"reference/troubleshooting/","title":"Troubleshooting Guide","text":"<p>Solutions to common problems when using the LIFX Emulator.</p>"},{"location":"reference/troubleshooting/#port-conflicts-and-resolution","title":"Port Conflicts and Resolution","text":""},{"location":"reference/troubleshooting/#port-already-in-use","title":"Port Already in Use","text":"<p>Problem: Server fails to start with \"Address already in use\"</p> <pre><code>OSError: [Errno 48] Address already in use\n</code></pre> <p>Causes:</p> <ul> <li>Another emulator instance is running</li> <li>Another application is using port 56700</li> <li>Previous test didn't clean up properly</li> </ul> <p>Solutions:</p> <ol> <li> <p>Find what's using the port: <pre><code># Linux/macOS\nlsof -i :56700\nnetstat -an | grep 56700\n\n# Windows\nnetstat -ano | findstr :56700\n</code></pre></p> </li> <li> <p>Kill the process: <pre><code># Linux/macOS\nkill &lt;PID&gt;\n\n# Windows\ntaskkill /PID &lt;PID&gt; /F\n</code></pre></p> </li> <li> <p>Use dynamic port allocation (best for tests): <pre><code># Let OS assign available port\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 0)\nawait server.start()\nprint(f\"Server running on port {server.port}\")\n</code></pre></p> </li> <li> <p>Use port offset in parallel tests: <pre><code>@pytest.fixture\nasync def emulator(worker_id):\n\n      port = 56700 + int(worker_num) + 1\n\n    device = create_color_light(f\"d073d5{worker_num:06d}\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n    async with server:\n        yield server\n</code></pre></p> </li> <li> <p>Wait between tests: <pre><code>import asyncio\n\nawait server.stop()\nawait asyncio.sleep(0.1)  # Let OS release the port\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#port-permission-denied","title":"Port Permission Denied","text":"<p>Problem: Cannot bind to port (Linux/macOS)</p> <pre><code>PermissionError: [Errno 13] Permission denied\n</code></pre> <p>Cause: Ports below 1024 require root privileges</p> <p>Solutions:</p> <ol> <li> <p>Use port &gt;= 1024 (recommended): <pre><code>server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n</code></pre></p> </li> <li> <p>Don't run as root (security risk)</p> </li> </ol>"},{"location":"reference/troubleshooting/#discovery-failures-and-debugging","title":"Discovery Failures and Debugging","text":""},{"location":"reference/troubleshooting/#client-cannot-find-emulated-devices","title":"Client Cannot Find Emulated Devices","text":"<p>Problem: LIFX client library discovers nothing</p> <p>Diagnostic checklist:</p> <ol> <li> <p>Check emulator is running: <pre><code>lifx-emulator --verbose\n</code></pre>    Should show: <code>Emulator listening on 127.0.0.1:56700</code></p> </li> <li> <p>Check bind address: <pre><code># only localhost\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n# all interfaces\nserver = EmulatedLifxServer([device], \"0.0.0.0\", 56700)\n</code></pre></p> </li> <li> <p>Check firewall:</p> </li> <li> <p>Windows: Allow Python through Windows Firewall</p> </li> <li>macOS: System Preferences \u2192 Security &amp; Privacy \u2192 Firewall \u2192 Allow Python</li> <li> <p>Linux: <pre><code>sudo ufw allow 56700/udp\n</code></pre></p> </li> <li> <p>Check client port:</p> </li> <li> <p>Ensure client is looking on the correct port</p> </li> <li>Default LIFX port is 56700</li> <li> <p>If using custom port, client must match</p> </li> <li> <p>Network isolation:</p> </li> <li> <p>Docker containers need <code>--network host</code> or proper port mapping</p> </li> <li>VMs need bridged networking</li> <li> <p>WSL2 may need port forwarding</p> </li> <li> <p>Enable verbose logging:</p> </li> </ol> <pre><code>import logging\nlogging.basicConfig(level=logging.DEBUG)\n</code></pre>"},{"location":"reference/troubleshooting/#discovery-works-but-device-not-responding","title":"Discovery Works, but Device Not Responding","text":"<p>Problem: Client sees device but times out on commands</p> <p>Solutions:</p> <ol> <li>Check target serial:</li> </ol> <pre><code>device = create_color_light(\"d073d5000001\")\nprint(f\"Device serial: {device.state.serial}\")\n# Client must target this exact serial\n</code></pre> <ol> <li> <p>Check tagged packets:</p> </li> <li> <p>Broadcast packets have <code>tagged=True</code> in header</p> </li> <li>Unicast packets have <code>tagged=False</code> and specific target</li> <li> <p>Emulator routes based on target field</p> </li> <li> <p>Check ack_required and res_required flags:</p> </li> </ol> <pre><code># Client should set these flags appropriately\n# ack_required=True \u2192 Device sends acknowledgment\n# res_required=True \u2192 Device sends state response\n</code></pre> <ol> <li>Enable packet logging:</li> </ol> <p><pre><code>lifx-emulator --verbose\n</code></pre>    This shows all packets sent/received:    <pre><code>RX: GetService (2) from ('127.0.0.1', 54321)\nTX: StateService (3) to ('127.0.0.1', 54321)\n</code></pre></p>"},{"location":"reference/troubleshooting/#devices-discovered-multiple-times","title":"Devices Discovered Multiple Times","text":"<p>Problem: Client sees duplicate devices</p> <p>Cause: Multiple emulator instances or broadcast responses</p> <p>Solutions:</p> <ol> <li> <p>Check for multiple instances: <pre><code>ps aux | grep lifx-emulator\n</code></pre></p> </li> <li> <p>Use unique serials: <pre><code># Wrong - duplicate serials\ndevice1 = create_color_light(\"d073d5000001\")\ndevice2 = create_color_light(\"d073d5000001\")  # Same serial!\n\n# Right - unique serials\ndevice1 = create_color_light(\"d073d5000001\")\ndevice2 = create_color_light(\"d073d5000002\")\n</code></pre></p> </li> <li> <p>Check network interfaces:</p> </li> <li>Multiple interfaces may cause duplicate broadcasts</li> <li>Bind to specific interface to avoid this</li> </ol>"},{"location":"reference/troubleshooting/#timeout-issues","title":"Timeout Issues","text":""},{"location":"reference/troubleshooting/#client-operations-timeout","title":"Client Operations Timeout","text":"<p>Problem: Client commands timeout waiting for response</p> <p>Diagnostic steps:</p> <ol> <li> <p>Increase client timeout:    Check your client library documentation for details.</p> </li> <li> <p>Check response scenarios: <pre><code># Are you testing timeouts intentionally?\ndevice.scenarios = {\n    'drop_packets': {102: 1.0},  # Will cause timeouts\n}\n</code></pre></p> </li> <li> <p>Check async context: <pre><code># Wrong - server has to be started manually\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n# ... try to communicate ...\n\n# Right - server starts automatically\nasync with EmulatedLifxServer([device], \"127.0.0.1\", 56700) as server:\n    # ... communicate here ...\n</code></pre></p> </li> <li> <p>Network latency: <pre><code># Check if delay scenarios are configured\ndevice.scenarios = {\n    'response_delays': {102: 10.0},  # 10 second delay!\n}\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#tests-timeout-in-cicd","title":"Tests Timeout in CI/CD","text":"<p>Problem: Tests pass locally but timeout in CI</p> <p>Solutions:</p> <ol> <li> <p>Use dynamic ports: <pre><code>def get_free_port() -&gt; int:\n \"\"\"Get a free UDP port.\"\"\"\n with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as s:\n     s.bind((\"127.0.0.1\", 0))\n     return s.getsockname()[1]\n\nport = get_free_port()\nserver = EmulatedLifxServer([device], \"127.0.0.1\", port)\n</code></pre></p> </li> <li> <p>Increase pytest timeout: <pre><code># pytest.ini or pyproject.toml\n[tool.pytest.ini_options]\ntimeout = 30\n</code></pre></p> </li> <li> <p>Reduce test fixture scope: <pre><code># Module scope for faster tests\n@pytest.fixture(scope=\"module\")\nasync def emulator():\n    ...\n</code></pre></p> </li> <li> <p>Check CI resource limits:</p> </li> <li> <p>CI runners may be slower than local machine</p> </li> <li>Increase timeouts for CI environment</li> <li>Use conditional timeouts:    <pre><code>import os\nTIMEOUT = 10 if os.getenv('CI') else 5\n</code></pre></li> </ol>"},{"location":"reference/troubleshooting/#protocol-errors-and-interpretation","title":"Protocol Errors and Interpretation","text":""},{"location":"reference/troubleshooting/#invalid-packet-type-errors","title":"Invalid Packet Type Errors","text":"<p>Problem: \"Unknown packet type\" errors</p> <p>Cause: Client sending unsupported packet type</p> <p>Solution:</p> <ol> <li> <p>Check protocol version:</p> </li> <li> <p>Emulator supports LIFX LAN Protocol (November 2025)</p> </li> <li> <p>See https://github.com/LIFX/public-protocol for specification</p> </li> <li> <p>Check packet type support: <pre><code>from lifx_emulator.protocol.packets import PACKET_REGISTRY\nprint(f\"Supported packet types: {list(PACKET_REGISTRY.keys())}\")\n</code></pre></p> </li> <li> <p>Enable verbose logging: <pre><code>lifx-emulator --verbose\n</code></pre>    Look for: <code>Unknown packet type: XXX</code></p> </li> </ol>"},{"location":"reference/troubleshooting/#malformed-packet-errors","title":"Malformed Packet Errors","text":"<p>Problem: \"Failed to unpack packet\" errors</p> <p>Causes:</p> <ul> <li>Incorrect header format</li> <li>Wrong packet structure</li> <li>Byte order issues</li> </ul> <p>Solutions:</p> <ol> <li> <p>Check header format:</p> </li> <li> <p>Header is exactly 36 bytes</p> </li> <li>Target field is 8 bytes (6-byte MAC + 2 null bytes)</li> <li> <p>Packet type in bytes 32-33 (little-endian)</p> </li> <li> <p>Verify packet structure: <pre><code>from lifx_emulator.protocol.packets import Light\n\n# Check expected structure\nprint(f\"GetColor packet type: {Light.GetColor.PKT_TYPE}\")\n\n# Check payload size\npacket = Light.GetColor()\ndata = packet.pack()\nprint(f\"Payload size: {len(data)} bytes\")\n</code></pre></p> </li> <li> <p>Enable debug logging: <pre><code>import logging\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#acknowledgment-not-received","title":"Acknowledgment Not Received","text":"<p>Problem: Client expects ack but doesn't receive it</p> <p>Causes:</p> <ul> <li><code>ack_required</code> flag not set in header</li> <li>Packet dropped by scenario configuration</li> <li>Network issues</li> </ul> <p>Solutions:</p> <ol> <li> <p>Check ack_required flag: <pre><code># Client must set ack_required=True in header\n# Emulator automatically sends Acknowledgment (type 45)\n</code></pre></p> </li> <li> <p>Check scenarios: <pre><code># Is ack being dropped?\ndevice.scenarios = {\n    'drop_packets': {45: 1.0},  # Drops acknowledgments!\n}\n</code></pre></p> </li> <li> <p>Enable verbose logging: <pre><code>lifx-emulator --verbose\n</code></pre>    Look for: <code>TX: Acknowledgment (45) to ...</code></p> </li> </ol>"},{"location":"reference/troubleshooting/#performance-problems","title":"Performance Problems","text":""},{"location":"reference/troubleshooting/#slow-test-execution","title":"Slow Test Execution","text":"<p>Problem: Tests take too long to run</p> <p>Solutions:</p> <ol> <li> <p>Use appropriate fixture scopes: <pre><code># Bad - function scope (starts server for each test)\n@pytest.fixture\nasync def emulator():\n    ...\n\n# Good - module scope (starts once per file)\n@pytest.fixture(scope=\"module\")\nasync def emulator():\n    ...\n</code></pre></p> </li> <li> <p>Run tests in parallel: <pre><code>pip install pytest-xdist\npytest -n auto\n</code></pre></p> </li> <li> <p>Reduce device count: <pre><code># Use only devices you need\n# Wrong - creating 100 devices for a simple test\ndevices = [create_color_light(f\"d073d5{i:06d}\") for i in range(100)]\n\n# Right - one device is enough\ndevice = create_color_light(\"d073d5000001\")\n</code></pre></p> </li> <li> <p>Remove unnecessary delays: <pre><code># Don't do this\nawait asyncio.sleep(1)  # Waiting \"just in case\"\n\n# The emulator responds instantly (no need to wait)\n</code></pre></p> </li> <li> <p>Profile your tests: <pre><code>pytest --durations=10\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#high-memory-usage","title":"High Memory Usage","text":"<p>Problem: Emulator consuming too much memory</p> <p>Causes:</p> <ul> <li>Too many devices</li> <li>Large tile/zone counts</li> <li>Memory leak in test code</li> </ul> <p>Solutions:</p> <ol> <li> <p>Limit device count: <pre><code># Each device uses ~1-5 MB\n# 1000 devices = ~5 GB\n\n# Use only what you need\ndevices = [create_color_light(f\"d073d5{i:06d}\") for i in range(10)]\n</code></pre></p> </li> <li> <p>Clean up properly: <pre><code># Ensure server stops and releases resources\nasync with server:\n    # ... tests ...\n# Cleanup happens automatically\n</code></pre></p> </li> <li> <p>Check for test isolation issues: <pre><code># Are you accumulating state?\n# Use fresh fixtures for each test\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#packet-loss-under-load","title":"Packet Loss Under Load","text":"<p>Problem: Packets dropped at high throughput</p> <p>Causes: - OS UDP buffer limits - CPU saturation - Network congestion</p> <p>Solutions:</p> <ol> <li> <p>Increase OS UDP buffer: <pre><code># Linux\nsudo sysctl -w net.core.rmem_max=26214400\nsudo sysctl -w net.core.rmem_default=26214400\n</code></pre></p> </li> <li> <p>Reduce packet rate: <pre><code># Add small delays between packets\nfor i in range(1000):\n    await send_packet()\n    await asyncio.sleep(0.001)  # 1ms delay\n</code></pre></p> </li> <li> <p>Check CPU usage: <pre><code># Monitor while running tests\nhtop  # or top on macOS/Linux\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#platform-specific-issues","title":"Platform-Specific Issues","text":""},{"location":"reference/troubleshooting/#windows-issues","title":"Windows Issues","text":"<p>Problem: Tests fail only on Windows</p> <p>Common issues:</p> <ol> <li> <p>Event loop policy: <pre><code># Add to conftest.py or test setup\nimport sys\nimport asyncio\n\nif sys.platform == 'win32':\n    asyncio.set_event_loop_policy(\n        asyncio.WindowsProactorEventLoopPolicy()\n    )\n</code></pre></p> </li> <li> <p>Firewall prompts:</p> </li> <li>Windows Defender may prompt to allow Python</li> <li>Allow for private networks</li> <li> <p>Or use 127.0.0.1 binding (no firewall prompt)</p> </li> <li> <p>Path separators: <pre><code># Use pathlib for cross-platform paths\nfrom pathlib import Path\n\nconfig_path = Path(__file__).parent / \"config.yaml\"\n</code></pre></p> </li> <li> <p>Line endings:</p> </li> <li>Git may convert line endings (CRLF vs LF)</li> <li>Configure <code>.gitattributes</code>:    <pre><code>*.py text eol=lf\n</code></pre></li> </ol>"},{"location":"reference/troubleshooting/#macos-issues","title":"macOS Issues","text":"<p>Problem: Tests fail only on macOS</p> <p>Common issues:</p> <ol> <li>Firewall blocks UDP:</li> <li>System Preferences \u2192 Security &amp; Privacy \u2192 Firewall</li> <li>Click \"Firewall Options\"</li> <li> <p>Add Python and allow incoming connections</p> </li> <li> <p>Too many open files: <pre><code># Check limit\nulimit -n\n\n# Increase limit\nulimit -n 4096\n</code></pre></p> </li> <li> <p>Gatekeeper blocking Python: <pre><code># If Python was downloaded (not from App Store)\nxattr -d com.apple.quarantine /path/to/python\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#linux-issues","title":"Linux Issues","text":"<p>Problem: Tests fail only on Linux</p> <p>Common issues:</p> <ol> <li> <p>Port binding requires root (ports &lt; 1024): <pre><code># Solution: Use ports &gt;= 1024\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n</code></pre></p> </li> <li> <p>Too many open files: <pre><code># Check limits\nulimit -n\ncat /proc/sys/fs/file-max\n\n# Increase limit temporarily\nulimit -n 4096\n\n# Increase permanently (add to /etc/security/limits.conf)\n* soft nofile 4096\n* hard nofile 8192\n</code></pre></p> </li> <li> <p>SELinux or AppArmor restrictions: <pre><code># Check SELinux\ngetenforce\n\n# Check AppArmor\nsudo aa-status\n\n# May need to configure policies for network access\n</code></pre></p> </li> </ol>"},{"location":"reference/troubleshooting/#wsl-windows-subsystem-for-linux-issues","title":"WSL (Windows Subsystem for Linux) Issues","text":"<p>Problem: Issues specific to WSL</p> <p>Common issues:</p> <ol> <li>Port forwarding:</li> <li>WSL2 uses virtual network</li> <li>Ports may not be accessible from Windows</li> <li> <p>Workaround: Use <code>0.0.0.0</code> binding and Windows firewall rules</p> </li> <li> <p>Network latency:</p> </li> <li>WSL2 has slight network overhead</li> <li> <p>May need longer timeouts</p> </li> <li> <p>File permissions:</p> </li> <li>Files on Windows filesystem (e.g., /mnt/c/) have weird permissions</li> <li>Use Linux filesystem (e.g., ~/projects/)</li> </ol>"},{"location":"reference/troubleshooting/#logging-and-debugging-techniques","title":"Logging and Debugging Techniques","text":""},{"location":"reference/troubleshooting/#enable-verbose-logging","title":"Enable Verbose Logging","text":"<p>Basic logging:</p> <pre><code>import logging\n\nlogging.basicConfig(\n    level=logging.DEBUG,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)\n</code></pre> <p>Emulator-specific logging:</p> <pre><code># Enable only emulator logs\nlogging.getLogger('lifx_emulator').setLevel(logging.DEBUG)\n</code></pre> <p>CLI verbose mode:</p> <pre><code>lifx-emulator --verbose\n</code></pre> <p>Output: <pre><code>RX: GetService (2) from ('127.0.0.1', 54321)\nTX: StateService (3) to ('127.0.0.1', 54321)\nRX: GetColor (101) from ('127.0.0.1', 54321) target=d073d5000001\nTX: StateColor (107) to ('127.0.0.1', 54321)\n</code></pre></p>"},{"location":"reference/troubleshooting/#inspect-device-state","title":"Inspect Device State","text":"<p>During tests:</p> <pre><code>@pytest.fixture\nasync def emulator():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n    async with server:\n        yield server, device  # Expose device for inspection\n\nasync def test_color_change(emulator):\n    server, device = emulator\n\n    # ... send SetColor command ...\n\n    # Inspect device state\n    print(f\"Device color: {device.state.color}\")\n    print(f\"Device power: {device.state.power_level}\")\n    assert device.state.color.hue == expected_hue\n</code></pre>"},{"location":"reference/troubleshooting/#packet-capture-with-wiresharktcpdump","title":"Packet Capture with Wireshark/tcpdump","text":"<p>Capture UDP packets:</p> <pre><code># Linux/macOS - tcpdump\nsudo tcpdump -i lo -n udp port 56700 -X\n\n# Wireshark\n# Filter: udp.port == 56700\n</code></pre> <p>Analyze LIFX packets: - First 36 bytes: LIFX header - Bytes 32-33: Packet type (little-endian) - Remaining bytes: Payload</p>"},{"location":"reference/troubleshooting/#use-pytest-debugging","title":"Use pytest Debugging","text":"<p>Drop into debugger on failure:</p> <pre><code>pytest --pdb\n</code></pre> <p>Drop into debugger on first failure:</p> <pre><code>pytest -x --pdb\n</code></pre> <p>Set breakpoint in test:</p> <pre><code>async def test_something(emulator):\n    device = ...\n    breakpoint()  # Python 3.7+\n    # or\n    import pdb; pdb.set_trace()\n</code></pre>"},{"location":"reference/troubleshooting/#enable-pytest-output","title":"Enable pytest output:**","text":"<pre><code># Show print() output\npytest -s\n\n# Show test names as they run\npytest -v\n\n# Both\npytest -sv\n</code></pre>"},{"location":"reference/troubleshooting/#common-error-messages","title":"Common Error Messages","text":""},{"location":"reference/troubleshooting/#runtimeerror-server-not-running","title":"\"RuntimeError: Server not running\"","text":"<p>Cause: Attempting to use server before starting</p> <p>Fix: <pre><code># Wrong\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\nawait send_command()  # Server not started!\n\n# Right\nserver = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\nasync with server:\n    await send_command()  # Server is running\n</code></pre></p>"},{"location":"reference/troubleshooting/#valueerror-invalid-serial-format","title":"\"ValueError: Invalid serial format\"","text":"<p>Cause: Serial number not 12 hex characters</p> <p>Fix: <pre><code># Wrong\ndevice = create_color_light(\"123\")\ndevice = create_color_light(\"d073d500001\")  # 11 chars\n\n# Right\ndevice = create_color_light(\"d073d5000001\")  # 12 chars\n</code></pre></p>"},{"location":"reference/troubleshooting/#typeerror-object-of-type-bytes-is-not-json-serializable","title":"\"TypeError: Object of type 'bytes' is not JSON serializable\"","text":"<p>Cause: Trying to serialize device state with bytes</p> <p>Context: Usually happens with custom serialization</p> <p>Fix: <pre><code>import base64\n\n# Convert bytes to base64 string\nserial_str = base64.b64encode(device.state.serial_bytes).decode('ascii')\n</code></pre></p>"},{"location":"reference/troubleshooting/#syntaxerror-await-outside-async-function","title":"\"SyntaxError: 'await' outside async function\"","text":"<p>Cause: Using async operations outside async context</p> <p>Fix: <pre><code># Wrong\ndef test_device():\n    await server.start()  # Can't await in sync function\n\n# Right\nasync def test_device():\n    await server.start()  # Now it works\n\n# Or use asyncio.run()\ndef test_device():\n    asyncio.run(async_main())\n</code></pre></p>"},{"location":"reference/troubleshooting/#deprecationwarning-there-is-no-current-event-loop","title":"\"DeprecationWarning: There is no current event loop\"","text":"<p>Cause: Python 3.10+ changed event loop behavior</p> <p>Fix: <pre><code># In conftest.py\nimport pytest\nimport asyncio\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    loop = asyncio.new_event_loop()\n    yield loop\n    loop.close()\n</code></pre></p>"},{"location":"reference/troubleshooting/#getting-help","title":"Getting Help","text":"<p>If you're still stuck after trying these solutions:</p> <ol> <li>Check existing issues: https://github.com/Djelibeybi/lifx-emulator/issues</li> <li>Search documentation: Use the search feature in the docs</li> <li>Ask in discussions: https://github.com/Djelibeybi/lifx-emulator/discussions</li> <li>File a bug report: https://github.com/Djelibeybi/lifx-emulator/issues/new</li> </ol> <p>When reporting issues, include: - Python version (<code>python --version</code>) - Operating system (Linux/macOS/Windows, version) - lifx-emulator version (<code>pip show lifx-emulator</code>) - Minimal reproduction code - Error messages and stack traces - What you've already tried</p>"},{"location":"reference/troubleshooting/#see-also","title":"See Also","text":"<ul> <li>FAQ - Common questions and answers</li> <li>Best Practices - Patterns and anti-patterns</li> <li>Integration Testing - pytest patterns</li> <li>Glossary - Terminology reference</li> </ul>"},{"location":"tutorials/","title":"Tutorials Overview","text":"<p>Step-by-step tutorials to master the LIFX Emulator, organized from beginner to advanced.</p>"},{"location":"tutorials/#learning-path","title":"Learning Path","text":"<p>Follow these tutorials in order for the best learning experience:</p> <ol> <li>\ud83d\udfe2 Beginner - First Device - Your first emulated LIFX device (\u23f1\ufe0f 10-15 minutes)</li> <li>\ud83d\udfe2 Beginner - Basic Usage - Multiple devices and basic operations (\u23f1\ufe0f 15-30 minutes)</li> <li>\ud83d\udfe1 Intermediate - Integration Testing - Using the emulator in test suites (\u23f1\ufe0f 30-45 minutes)</li> <li>\ud83d\udd34 Advanced - Advanced Scenarios - Error injection and complex testing (\u23f1\ufe0f 45-60 minutes)</li> <li>\ud83d\udd34 Advanced - CI/CD Integration - Automated testing pipelines (\u23f1\ufe0f 30-45 minutes)</li> </ol>"},{"location":"tutorials/#tutorial-categories","title":"Tutorial Categories","text":""},{"location":"tutorials/#getting-started","title":"Getting Started","text":"<p>Learn the basics:</p> <ul> <li>Creating a single device</li> <li>Starting the server</li> <li>Using the context manager</li> <li>Basic server configuration</li> </ul>"},{"location":"tutorials/#multiple-devices","title":"Multiple Devices","text":"<p>Work with multiple devices:</p> <ul> <li>Creating different device types</li> <li>Managing device collections</li> <li>Testing multi-device scenarios</li> </ul>"},{"location":"tutorials/#testing-integration","title":"Testing Integration","text":"<p>Integrate with test frameworks:</p> <ul> <li>pytest fixtures</li> <li>pytest-asyncio usage</li> <li>Module-scoped fixtures</li> <li>Test isolation strategies</li> </ul>"},{"location":"tutorials/#error-scenarios","title":"Error Scenarios","text":"<p>Test error handling:</p> <ul> <li>Packet dropping</li> <li>Response delays</li> <li>Malformed packets</li> <li>Invalid field values</li> <li>Partial responses</li> </ul>"},{"location":"tutorials/#complete-example","title":"Complete Example","text":"<p>Here's a complete example showing multiple features:</p> <pre><code>import asyncio\nimport pytest\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\n\n@pytest.fixture\nasync def lifx_devices():\n    \"\"\"Create a diverse set of emulated devices.\"\"\"\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n        create_multizone_light(\"d073d8000001\", zone_count=16),\n        create_multizone_light(\"d073d8000002\", zone_count=82, extended_multizone=True),\n        create_tile_device(\"d073d9000001\", tile_count=5),\n    ]\n\n    # Configure error scenarios for one device\n    devices[0].scenarios = {\n        'response_delays': {102: 0.1},  # Delay SetColor by 100ms\n    }\n\n    return devices\n\n@pytest.fixture\nasync def lifx_server(lifx_devices):\n    \"\"\"Start emulator server with devices.\"\"\"\n    server = EmulatedLifxServer(lifx_devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_discovery(lifx_server):\n    \"\"\"Test device discovery.\"\"\"\n    # Your test code here\n    pass\n\n@pytest.mark.asyncio\nasync def test_color_control(lifx_server):\n    \"\"\"Test color control commands.\"\"\"\n    # Your test code here\n    pass\n</code></pre>"},{"location":"tutorials/#next-steps","title":"Next Steps","text":"<p>Browse the specific tutorial pages for detailed code samples and explanations. Each tutorial builds on the concepts from the previous one.</p>"},{"location":"tutorials/01-first-device/","title":"Your First LIFX Device","text":"<p>Difficulty: \ud83d\udfe2 Beginner | Time: \u23f1\ufe0f 5 minutes | Prerequisites: Python 3.11+, LIFX Emulator installed</p> <p>This tutorial walks you through creating and running your first emulated LIFX device. By the end, you'll have a virtual LIFX light running on your machine that responds to LIFX protocol commands.</p>"},{"location":"tutorials/01-first-device/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>How to create a single emulated device</li> <li>How to start the emulator server</li> <li>How to verify the device is running</li> <li>How to test it with a LIFX client (optional)</li> </ul>"},{"location":"tutorials/01-first-device/#step-1-create-your-first-device","title":"Step 1: Create Your First Device","text":"CLI (Quick Start)Python Library <p>The fastest way to get started is with the CLI:</p> <pre><code># Install (if not already installed)\npip install lifx-emulator\n\n# Create a single color light with verbose output\nlifx-emulator --color 1 --verbose\n</code></pre> <p>You should see output like:</p> <pre><code>INFO - Starting LIFX Emulator on 127.0.0.1:56700\nINFO - Created 1 emulated device(s):\nINFO -   \u2022 A19 d073d5000001 (d073d5000001) - full color\nINFO - Server running with verbose packet logging... Press Ctrl+C to stop\n</code></pre> <p>That's it! You now have a virtual LIFX device running.</p> <p>Create a new Python file called <code>first_device.py</code>:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\nfrom lifx_emulator.repositories import DeviceRepository\nfrom lifx_emulator.devices import DeviceManager\n\nasync def main():\n    # Create a LIFX A19 color light\n    device = create_color_light(\"d073d5000001\")\n\n    # Create repository and manager (required)\n    device_manager = DeviceManager(DeviceRepository())\n\n    # Create server on standard LIFX port (56700)\n    server = EmulatedLifxServer(\n        [device], device_manager, \"127.0.0.1\", 56700\n    )\n\n    # Start the server\n    async with server:\n        print(f\"Emulator running!\")\n        print(f\"Device: {device.state.label}\")\n        print(f\"Serial: {device.state.serial}\")\n        print(f\"Listening on: 127.0.0.1:56700\")\n        print(\"\\nPress Ctrl+C to stop\")\n\n        # Keep server running\n        try:\n            await asyncio.sleep(3600)  # Run for 1 hour\n        except KeyboardInterrupt:\n            print(\"\\nShutting down...\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Run your script:</p> <pre><code>python first_device.py\n</code></pre> <p>You should see output like:</p> <pre><code>Emulator running!\nDevice: LIFX Light\nSerial: d073d5000001\nListening on: 127.0.0.1:56700\n\nPress Ctrl+C to stop\n</code></pre> <p>Congratulations! You now have a virtual LIFX device running on your machine.</p>"},{"location":"tutorials/01-first-device/#step-2-understanding-whats-happening","title":"Step 2: Understanding What's Happening","text":"CLIPython Library <p>The CLI command <code>lifx-emulator --color 1 --verbose</code> does the following:</p> <ul> <li><code>--color 1</code> - Creates 1 LIFX A19 color light (product ID 27)</li> <li><code>--verbose</code> - Enables detailed packet logging to see activity</li> </ul> <p>CLI Options Explained:</p> Option Description <code>--color N</code> Create N color lights <code>--verbose</code> Show packet-level details <code>--port PORT</code> Use custom UDP port (default: 56700) <code>--bind IP</code> Bind to specific IP (default: 127.0.0.1) <code>--api</code> Enable HTTP management API"},{"location":"tutorials/01-first-device/#creating-the-device","title":"Creating the Device","text":"<pre><code>device = create_color_light(\"d073d5000001\")\n</code></pre> <ul> <li><code>create_color_light()</code> - Creates a LIFX A19 bulb (product ID 27)</li> <li><code>\"d073d5000001\"</code> - The device's unique serial number (MAC address)</li> </ul>"},{"location":"tutorials/01-first-device/#creating-the-server","title":"Creating the Server","text":"<pre><code>device_manager = DeviceManager(DeviceRepository())\nserver = EmulatedLifxServer([device], device_manager, \"127.0.0.1\", 56700)\n</code></pre> <ul> <li><code>DeviceManager</code> and <code>DeviceRepository</code> - Required for device lifecycle management</li> <li><code>[device]</code> - List of devices to emulate (we have one)</li> <li><code>\"127.0.0.1\"</code> - IP address to bind to (localhost)</li> <li><code>56700</code> - Standard LIFX UDP port</li> </ul>"},{"location":"tutorials/01-first-device/#using-the-context-manager","title":"Using the Context Manager","text":"<pre><code>async with server:\n    # Server is running here\n    await asyncio.sleep(3600)\n</code></pre> <p>The <code>async with</code> statement:</p> <ol> <li>Starts the server automatically</li> <li>Runs your code inside the block</li> <li>Stops the server cleanly when done</li> </ol>"},{"location":"tutorials/01-first-device/#step-4-customizing-your-device-optional","title":"Step 4: Customizing Your Device (Optional)","text":"<p>You can customize the device before starting the server:</p> <pre><code>from lifx_emulator.protocol.protocol_types import LightHsbk\n\n# Create device\ndevice = create_color_light(\"d073d5000001\")\n\n# Customize it\ndevice.state.label = \"My First Light\"\ndevice.state.power = 65535  # On (max power)\ndevice.state.color = LightHsbk(\n    hue=21845,      # Green (120 degrees)\n    saturation=65535,  # Fully saturated\n    brightness=32768,  # 50% brightness\n    kelvin=3500\n)\n\n# Now start the server...\n</code></pre>"},{"location":"tutorials/01-first-device/#step-5-testing-with-a-lifx-client-optional","title":"Step 5: Testing with a LIFX Client (Optional)","text":"<p>If you have a LIFX client library installed, you can test your emulated device.</p>"},{"location":"tutorials/01-first-device/#using-the-lifx-async-library","title":"Using the lifx-async library","text":"<p>Install the library:</p> <pre><code>pip install lifx-async\n</code></pre> <p>In a separate terminal, create <code>test_client.py</code>:</p> <pre><code>import asyncio\nfrom lifx import discover\nfrom lifx.color import HSBK\n\nasync def main():\n    # Discover devices\n    async with discover() as group:\n        print(f\"Found {len(group.devices)} device(s)\")\n\n        if group.devices:\n            device = group.devices[0]\n            print(f\"Device: {device.label}\")\n            print(f\"Power: {device.power}\")\n\n            # Change color to red\n            print(\"Setting color to red...\")\n            await device.set_color(HSBK.from_rgb(255, 0, 0))\n            print(\"Done!\")\n\nasyncio.run(main())\n</code></pre> <p>Run it while your emulator is running:</p> <pre><code>python test_client.py\n</code></pre> <p>You should see:</p> <pre><code>Found 1 device(s)\nDevice: LIFX Light\nPower: 65535\nSetting color to red...\nDone!\n</code></pre>"},{"location":"tutorials/01-first-device/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/01-first-device/#port-already-in-use","title":"Port Already in Use","text":"<p>Error: <code>OSError: [Errno 48] Address already in use</code></p> <p>Solution: Change the port number:</p> <pre><code>server = EmulatedLifxServer([device], \"127.0.0.1\", 56701)  # Different port\n</code></pre>"},{"location":"tutorials/01-first-device/#device-not-discovered","title":"Device Not Discovered","text":"<p>Problem: Client can't find the device</p> <p>Solutions: 1. Make sure the emulator is running 2. Check that both emulator and client are on the same network interface 3. Try binding to <code>\"0.0.0.0\"</code> instead of <code>\"127.0.0.1\"</code>:</p> <pre><code>server = EmulatedLifxServer([device], \"0.0.0.0\", 56700)\n</code></pre>"},{"location":"tutorials/01-first-device/#python-version-error","title":"Python Version Error","text":"<p>Error: <code>SyntaxError</code> or import errors</p> <p>Solution: Ensure you're using Python 3.11 or newer:</p> <pre><code>python --version  # Should show 3.11 or higher\n</code></pre>"},{"location":"tutorials/01-first-device/#what-youve-learned","title":"What You've Learned","text":"<p>\u2713 How to create an emulated LIFX device \u2713 How to start the emulator server \u2713 How to use the context manager pattern \u2713 How to customize device properties \u2713 How to test with a LIFX client</p>"},{"location":"tutorials/01-first-device/#next-steps","title":"Next Steps","text":"<p>Now that you have a basic device running, you can:</p> <ol> <li>Basic Usage Tutorial - Learn more patterns (multiple devices, state queries, etc.)</li> <li>Integration Testing - Use the emulator in your pytest test suite</li> <li>Advanced Scenarios - Explore multizone devices, tiles, and error injection</li> </ol>"},{"location":"tutorials/01-first-device/#quick-wins","title":"Quick Wins","text":"<p>Try these modifications to your <code>first_device.py</code>:</p> <ul> <li> <p>Multiple devices: Add more devices to the list:   <pre><code>devices = [\n    create_color_light(\"d073d5000001\"),\n    create_color_light(\"d073d5000002\"),\n    create_color_light(\"d073d5000003\"),\n]\nserver = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n</code></pre></p> </li> <li> <p>Different device type: Try a multizone strip:   <pre><code>from lifx_emulator import create_multizone_light\ndevice = create_multizone_light(\"d073d8000001\", zone_count=16)\n</code></pre></p> </li> <li> <p>Custom labels: Give each device a unique name:   <pre><code>device.state.label = \"Living Room\"\n</code></pre></p> </li> </ul>"},{"location":"tutorials/01-first-device/#see-also","title":"See Also","text":"<ul> <li>CLI Usage - Quick command-line testing</li> <li>Device Types - Understanding different LIFX devices</li> <li>API Reference: Device - Complete device API documentation</li> </ul>"},{"location":"tutorials/02-basic/","title":"Basic Examples","text":"<p>This page demonstrates basic usage patterns for the LIFX Emulator. These examples cover the most common use cases for getting started.</p>"},{"location":"tutorials/02-basic/#single-device-creation","title":"Single Device Creation","text":"<p>The simplest way to start is with a single color light:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    # Create a single LIFX color light (A19)\n    device = create_color_light(\"d073d5000001\")\n\n    # Create and start the server\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Emulator running with device {device.state.serial}\")\n        print(f\"Label: {device.state.label}\")\n        print(f\"Product: {device.state.product_id}\")\n\n        # Keep server running\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Emulator running with device d073d5000001\nLabel: LIFX Light\nProduct: 27\n</code></pre></p>"},{"location":"tutorials/02-basic/#using-context-manager-recommended","title":"Using Context Manager (Recommended)","text":"<p>The context manager automatically handles server startup and shutdown:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    # Server starts automatically on entry, stops on exit\n    async with server:\n        print(\"Server is running\")\n        await asyncio.sleep(60)\n\n    print(\"Server has stopped cleanly\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/02-basic/#multiple-devices-on-same-server","title":"Multiple Devices on Same Server","text":"<p>Run multiple devices simultaneously:</p> <pre><code>import asyncio\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_color_temperature_light,\n    create_infrared_light,\n)\n\nasync def main():\n    # Create different device types\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n        create_color_temperature_light(\"d073d5000003\"),\n        create_infrared_light(\"d073d5000004\"),\n    ]\n\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Running {len(devices)} devices:\")\n        for device in devices:\n            print(f\"  - {device.state.serial}: {device.state.label} \"\n                  f\"(product {device.state.product_id})\")\n\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Running 4 devices:\n  - d073d5000001: LIFX Light (product 27)\n  - d073d5000002: LIFX Light (product 27)\n  - d073d5000003: LIFX Light (product 50)\n  - d073d5000004: LIFX+ A19 (product 29)\n</code></pre></p>"},{"location":"tutorials/02-basic/#query-device-state","title":"Query Device State","text":"<p>Access device state at any time:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Access current device state\n        state = device.state\n\n        print(f\"Serial: {state.serial}\")\n        print(f\"Label: {state.label}\")\n        print(f\"Power: {state.power}\")\n        print(f\"Color: H={state.color.hue}, S={state.color.saturation}, \"\n              f\"B={state.color.brightness}, K={state.color.kelvin}\")\n        print(f\"Capabilities:\")\n        print(f\"  - Color: {state.has_color}\")\n        print(f\"  - Infrared: {state.has_infrared}\")\n        print(f\"  - Multizone: {state.has_multizone}\")\n        print(f\"  - Matrix: {state.has_matrix}\")\n\n        await asyncio.sleep(1)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Serial: d073d5000001\nLabel: LIFX Light\nPower: 65535\nColor: H=0, S=0, B=65535, K=3500\nCapabilities:\n  - Color: True\n  - Infrared: False\n  - Multizone: False\n  - Matrix: False\n</code></pre></p>"},{"location":"tutorials/02-basic/#custom-port-and-bind-address","title":"Custom Port and Bind Address","text":"<p>Configure the server's network settings:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Bind to specific IP and port\n    # Use \"0.0.0.0\" to listen on all interfaces\n    server = EmulatedLifxServer(\n        devices=[device],\n        bind_address=\"127.0.0.1\",\n        port=56701  # Non-standard port\n    )\n\n    async with server:\n        print(f\"Server listening on 127.0.0.1:56701\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/02-basic/#setting-initial-device-state","title":"Setting Initial Device State","text":"<p>Customize device state before starting the server:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Configure device state before starting\n    device.state.label = \"Living Room Light\"\n    device.state.power = 65535  # On\n    device.state.color = LightHsbk(\n        hue=21845,      # 120\u00b0 (green)\n        saturation=65535,  # Fully saturated\n        brightness=32768,  # 50% brightness\n        kelvin=3500\n    )\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Device ready with custom state:\")\n        print(f\"  Label: {device.state.label}\")\n        print(f\"  Power: {'On' if device.state.power else 'Off'}\")\n        print(f\"  Color: Green at 50% brightness\")\n\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/02-basic/#creating-devices-by-product-id","title":"Creating Devices by Product ID","text":"<p>Use the universal factory to create any device type:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_device\n\nasync def main():\n    # Create devices using product IDs from the registry\n    devices = [\n        create_device(27, serial=\"d073d5000001\"),  # LIFX A19\n        create_device(32, serial=\"d073d5000002\"),  # LIFX Z (strip)\n        create_device(55, serial=\"d073d5000003\"),  # LIFX Tile\n        create_device(90, serial=\"d073d5000004\"),  # LIFX Clean (HEV)\n    ]\n\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Devices created by product ID:\")\n        for device in devices:\n            capabilities = []\n            if device.state.has_color:\n                capabilities.append(\"color\")\n            if device.state.has_multizone:\n                capabilities.append(\"multizone\")\n            if device.state.has_matrix:\n                capabilities.append(\"matrix\")\n            if device.state.has_hev:\n                capabilities.append(\"hev\")\n\n            print(f\"  - Product {device.state.product_id}: {', '.join(capabilities)}\")\n\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Devices created by product ID:\n  - Product 27: color\n  - Product 32: color, multizone\n  - Product 55: color, matrix\n  - Product 90: color, hev\n</code></pre></p>"},{"location":"tutorials/02-basic/#testing-with-a-lifx-client","title":"Testing with a LIFX Client","text":"<p>Here's how to test your emulated device with a real LIFX LAN client library:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n# Example using lifxlan library (install with: pip install lifxlan)\nfrom lifxlan import LifxLAN\n\nasync def run_emulator():\n    \"\"\"Run the emulator in the background.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Emulator running, press Ctrl+C to stop\")\n        await asyncio.sleep(3600)  # Run for 1 hour\n\ndef test_with_client():\n    \"\"\"Test the emulator using a LIFX client.\"\"\"\n    # Discover devices on the local network\n    lifx = LifxLAN()\n    devices = lifx.get_devices()\n\n    print(f\"Found {len(devices)} device(s)\")\n\n    for device in devices:\n        print(f\"\\nDevice: {device.get_label()}\")\n        print(f\"Power: {device.get_power()}\")\n\n        # Change color to red\n        device.set_color([65535, 65535, 32768, 3500])  # Red, full brightness\n        print(\"Changed color to red\")\n\n# Run the emulator (in production, use separate processes or async tasks)\nif __name__ == \"__main__\":\n    # In real usage, run emulator and client in separate processes/terminals\n    asyncio.run(run_emulator())\n</code></pre>"},{"location":"tutorials/02-basic/#simple-pytest-example","title":"Simple pytest Example","text":"<p>Basic pytest integration:</p> <pre><code>import pytest\nimport asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def emulator():\n    \"\"\"Pytest fixture for emulator.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_device_responds(emulator):\n    \"\"\"Test that device is accessible.\"\"\"\n    assert len(emulator.devices) == 1\n    device = emulator.devices[0]\n    assert device.state.serial == \"d073d5000001\"\n    assert device.state.has_color is True\n</code></pre>"},{"location":"tutorials/02-basic/#next-steps","title":"Next Steps","text":"<ul> <li>Integration Examples - Comprehensive pytest patterns and test fixtures</li> <li>Advanced Examples - Complex scenarios with multizone, tiles, and error injection</li> <li>API Reference: Device - Full EmulatedLifxDevice API documentation</li> <li>API Reference: Server - Full EmulatedLifxServer API documentation</li> </ul>"},{"location":"tutorials/02-basic/#see-also","title":"See Also","text":"<ul> <li>CLI Usage - Command-line interface for quick testing</li> <li>Product Registry - Available product IDs and capabilities</li> <li>Device Types Guide - Understanding different LIFX device types</li> </ul>"},{"location":"tutorials/03-integration/","title":"Integration Testing Examples","text":"<p>This page demonstrates how to integrate the LIFX Emulator into your test suites using pytest, pytest-asyncio, and other testing frameworks.</p>"},{"location":"tutorials/03-integration/#basic-pytest-fixture","title":"Basic pytest Fixture","text":"<p>The simplest pytest integration pattern:</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def lifx_server():\n    \"\"\"Basic emulator fixture.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_server_running(lifx_server):\n    \"\"\"Test that the server is running.\"\"\"\n    assert len(lifx_server.devices) == 1\n    assert lifx_server.devices[0].state.serial == \"d073d5000001\"\n</code></pre>"},{"location":"tutorials/03-integration/#function-scoped-fixtures","title":"Function-Scoped Fixtures","text":"<p>Create a fresh emulator for each test (default scope):</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture(scope=\"function\")\nasync def lifx_emulator():\n    \"\"\"Function-scoped fixture - new emulator per test.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_first(lifx_emulator):\n    \"\"\"First test gets a fresh emulator.\"\"\"\n    assert len(lifx_emulator.devices) == 1\n\n@pytest.mark.asyncio\nasync def test_second(lifx_emulator):\n    \"\"\"Second test gets a different fresh emulator.\"\"\"\n    assert len(lifx_emulator.devices) == 1\n</code></pre>"},{"location":"tutorials/03-integration/#module-scoped-fixtures","title":"Module-Scoped Fixtures","text":"<p>Share one emulator across all tests in a module:</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture(scope=\"module\")\nasync def shared_emulator():\n    \"\"\"Module-scoped fixture - shared across all tests in module.\"\"\"\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n    ]\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_first_device(shared_emulator):\n    \"\"\"Test using shared emulator.\"\"\"\n    assert shared_emulator.devices[0].state.serial == \"d073d5000001\"\n\n@pytest.mark.asyncio\nasync def test_second_device(shared_emulator):\n    \"\"\"Another test using the same emulator instance.\"\"\"\n    assert shared_emulator.devices[1].state.serial == \"d073d5000002\"\n</code></pre>"},{"location":"tutorials/03-integration/#fixture-with-custom-configuration","title":"Fixture with Custom Configuration","text":"<p>Create parameterized fixtures for different scenarios:</p> <pre><code>import pytest\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n)\n\n@pytest.fixture\nasync def basic_device():\n    \"\"\"Single color light fixture.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.fixture\nasync def multizone_device():\n    \"\"\"Multizone strip fixture.\"\"\"\n    device = create_multizone_light(\"d073d8000001\", zone_count=16)\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56701)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_color_light(basic_device):\n    \"\"\"Test with color light.\"\"\"\n    assert basic_device.devices[0].state.has_color\n\n@pytest.mark.asyncio\nasync def test_multizone_light(multizone_device):\n    \"\"\"Test with multizone light.\"\"\"\n    assert multizone_device.devices[0].state.has_multizone\n    assert len(multizone_device.devices[0].state.zone_colors) == 16\n</code></pre>"},{"location":"tutorials/03-integration/#parametrized-tests","title":"Parametrized Tests","text":"<p>Test against multiple device types:</p> <pre><code>import pytest\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\n\n@pytest.fixture(params=[\n    (\"color\", create_color_light, \"d073d5000001\"),\n    (\"multizone\", lambda s: create_multizone_light(s, zone_count=16), \"d073d8000001\"),\n    (\"tile\", lambda s: create_tile_device(s, tile_count=5), \"d073d9000001\"),\n])\nasync def any_device(request):\n    \"\"\"Parametrized fixture for different device types.\"\"\"\n    device_type, factory, serial = request.param\n    device = factory(serial)\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server, device_type\n\n@pytest.mark.asyncio\nasync def test_all_devices_respond(any_device):\n    \"\"\"Test runs 3 times, once for each device type.\"\"\"\n    server, device_type = any_device\n    print(f\"Testing {device_type} device\")\n    assert len(server.devices) == 1\n</code></pre>"},{"location":"tutorials/03-integration/#port-management","title":"Port Management","text":"<p>Avoid port conflicts when running tests in parallel:</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\ndef get_free_port():\n    \"\"\"Find an available port.\"\"\"\n    import socket\n    with socket.socket() as s:\n        s.bind(('', 0))\n        return s.getsockname()[1]\n\n@pytest.fixture\nasync def emulator_on_free_port():\n    \"\"\"Use dynamically allocated port.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    port = get_free_port()\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server, port\n\n@pytest.mark.asyncio\nasync def test_with_dynamic_port(emulator_on_free_port):\n    \"\"\"Test using dynamic port allocation.\"\"\"\n    server, port = emulator_on_free_port\n    print(f\"Emulator running on port {port}\")\n    assert len(server.devices) == 1\n</code></pre>"},{"location":"tutorials/03-integration/#test-isolation-with-fresh-devices","title":"Test Isolation with Fresh Devices","text":"<p>Ensure each test has clean state:</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\n@pytest.fixture\nasync def fresh_device():\n    \"\"\"Create a fresh device for each test.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_modify_color(fresh_device):\n    \"\"\"Test that modifies device state.\"\"\"\n    device = fresh_device.devices[0]\n\n    # Modify state\n    device.state.color = LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500)\n\n    # Verify modification\n    assert device.state.color.hue == 21845\n\n@pytest.mark.asyncio\nasync def test_default_color(fresh_device):\n    \"\"\"Test gets fresh device with default state.\"\"\"\n    device = fresh_device.devices[0]\n\n    # Fresh device should have default color (not modified by previous test)\n    assert device.state.color.hue == 0  # Default\n</code></pre>"},{"location":"tutorials/03-integration/#cleanup-and-resource-management","title":"Cleanup and Resource Management","text":"<p>Ensure proper cleanup even when tests fail:</p> <pre><code>import pytest\nimport asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def emulator_with_cleanup():\n    \"\"\"Fixture with explicit cleanup.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    # Start server\n    async with server:\n        try:\n            yield server\n        finally:\n            # Cleanup always runs, even if test fails\n            print(\"Cleaning up emulator resources\")\n            # Server stops automatically when exiting context manager\n\n@pytest.mark.asyncio\nasync def test_that_might_fail(emulator_with_cleanup):\n    \"\"\"Test with guaranteed cleanup.\"\"\"\n    # Even if this test raises an exception, cleanup runs\n    assert len(emulator_with_cleanup.devices) == 1\n</code></pre>"},{"location":"tutorials/03-integration/#testing-with-real-lifx-clients","title":"Testing with Real LIFX Clients","text":"<p>Integration test with an actual LIFX client library:</p> <pre><code>import pytest\nimport asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n# This example uses lifxlan library: pip install lifxlan\nfrom lifxlan import LifxLAN\n\n@pytest.fixture\nasync def emulator_for_client():\n    \"\"\"Emulator configured for client testing.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    device.state.label = \"Test Light\"\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        # Give server time to start\n        await asyncio.sleep(0.1)\n        yield server\n\n@pytest.mark.asyncio\nasync def test_client_discovery(emulator_for_client):\n    \"\"\"Test client can discover emulated device.\"\"\"\n    # Run client code in separate thread/task\n    lifx = LifxLAN()\n\n    # Small timeout for local network\n    devices = lifx.get_devices()\n\n    assert len(devices) == 1\n    assert devices[0].get_label() == \"Test Light\"\n\n@pytest.mark.asyncio\nasync def test_client_set_color(emulator_for_client):\n    \"\"\"Test client can control emulated device.\"\"\"\n    lifx = LifxLAN()\n    devices = lifx.get_devices()\n    device = devices[0]\n\n    # Change color to red\n    device.set_color([65535, 65535, 32768, 3500])\n\n    # Verify state change in emulator\n    emu_device = emulator_for_client.devices[0]\n    assert emu_device.state.color.hue == 65535  # Red\n</code></pre>"},{"location":"tutorials/03-integration/#parallel-test-execution","title":"Parallel Test Execution","text":"<p>Configure for pytest-xdist parallel execution:</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def isolated_emulator(worker_id):\n    \"\"\"Isolated emulator for parallel testing.\"\"\"\n    # Use worker_id to get unique port per worker\n    if worker_id == 'master':\n        port = 56700\n    else:\n        # Extract worker number and add to base port\n        worker_num = int(worker_id.replace('gw', ''))\n        port = 56700 + worker_num\n\n    device = create_color_light(f\"d073d500000{port % 100}\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_parallel_safe(isolated_emulator):\n    \"\"\"Test that can run in parallel with others.\"\"\"\n    assert len(isolated_emulator.devices) == 1\n</code></pre> <p>Run with: <code>pytest -n auto</code> (requires pytest-xdist)</p>"},{"location":"tutorials/03-integration/#conftestpy-organization","title":"conftest.py Organization","text":"<p>Organize fixtures in conftest.py for reuse:</p> <pre><code># conftest.py\nimport pytest\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n)\n\n@pytest.fixture(scope=\"session\")\ndef event_loop():\n    \"\"\"Create event loop for async tests.\"\"\"\n    import asyncio\n    loop = asyncio.get_event_loop_policy().new_event_loop()\n    yield loop\n    loop.close()\n\n@pytest.fixture\nasync def single_color_light():\n    \"\"\"Reusable single color light fixture.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.fixture\nasync def multiple_devices():\n    \"\"\"Reusable multi-device fixture.\"\"\"\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n        create_multizone_light(\"d073d8000001\", zone_count=16),\n    ]\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"tutorials/03-integration/#testing-error-scenarios","title":"Testing Error Scenarios","text":"<p>Test your client's error handling:</p> <pre><code>import pytest\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def unreliable_device():\n    \"\"\"Device configured to drop packets.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    device.scenarios = {\n        'drop_packets': [101],  # Drop GetColor\n        'response_delays': {102: 1.0},  # Delay SetColor\n    }\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_client_retry_logic(unreliable_device):\n    \"\"\"Test that client handles dropped packets.\"\"\"\n    # Your client should implement retry logic\n    # This test verifies it works correctly\n    pass\n\n@pytest.mark.asyncio\nasync def test_client_timeout_handling(unreliable_device):\n    \"\"\"Test that client handles slow responses.\"\"\"\n    # Your client should timeout appropriately\n    # This test verifies timeout behavior\n    pass\n</code></pre>"},{"location":"tutorials/03-integration/#mock-vs-emulator-decision","title":"Mock vs Emulator Decision","text":"<p>When to use emulator vs mocks:</p> <pre><code>import pytest\nfrom unittest.mock import Mock, AsyncMock\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n# Use emulator for integration tests\n@pytest.fixture\nasync def integration_emulator():\n    \"\"\"Full emulator for integration testing.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        yield server\n\n@pytest.mark.asyncio\nasync def test_integration_with_emulator(integration_emulator):\n    \"\"\"Integration test using real emulated device.\"\"\"\n    # Test full protocol interaction\n    assert len(integration_emulator.devices) == 1\n\n# Use mocks for unit tests\ndef test_unit_with_mock():\n    \"\"\"Unit test using mock.\"\"\"\n    # Mock is faster and more isolated for unit tests\n    mock_device = Mock()\n    mock_device.state.serial = \"d073d5000001\"\n    mock_device.state.has_color = True\n\n    # Test your code that uses the device\n    assert mock_device.state.has_color\n</code></pre> <p>When to use Emulator: - Integration tests with real protocol - Testing client library implementations - End-to-end workflow testing - Protocol compliance testing</p> <p>When to use Mocks: - Unit tests for business logic - Fast test suites - Testing error conditions that are hard to trigger - Isolating code under test</p>"},{"location":"tutorials/03-integration/#testing-with-docker","title":"Testing with Docker","text":"<p>Run emulator in Docker for CI/CD:</p> <pre><code># test_docker.py\nimport pytest\nimport asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture(scope=\"session\")\nasync def dockerized_emulator():\n    \"\"\"\n    In CI/CD, you can run emulator in a separate container.\n    This fixture connects to it.\n    \"\"\"\n    # In actual usage, emulator runs in separate container\n    # This is a simplified example for local testing\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"0.0.0.0\", 56700)\n\n    async with server:\n        await asyncio.sleep(0.1)  # Allow server to start\n        yield server\n\n@pytest.mark.asyncio\nasync def test_with_docker(dockerized_emulator):\n    \"\"\"Test against dockerized emulator.\"\"\"\n    # Connect to emulator (in real case, from different container)\n    assert len(dockerized_emulator.devices) == 1\n</code></pre> <p>Dockerfile example: <pre><code>FROM python:3.13-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install -e .\n\nEXPOSE 56700/udp\n\nCMD [\"lifx-emulator\", \"--color\", \"3\", \"--multizone\", \"2\"]\n</code></pre></p>"},{"location":"tutorials/03-integration/#background-server-pattern","title":"Background Server Pattern","text":"<p>Run emulator as background task during tests:</p> <pre><code>import pytest\nimport asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\n@pytest.fixture\nasync def background_emulator():\n    \"\"\"Emulator running as background task.\"\"\"\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    # Start server manually\n    await server.start()\n\n    # Start server task in background\n    task = asyncio.create_task(server.run())\n\n    try:\n        # Wait for server to be ready\n        await asyncio.sleep(0.1)\n        yield server\n    finally:\n        # Stop server\n        await server.stop()\n        task.cancel()\n        try:\n            await task\n        except asyncio.CancelledError:\n            pass\n\n@pytest.mark.asyncio\nasync def test_with_background_server(background_emulator):\n    \"\"\"Test with server running in background.\"\"\"\n    assert len(background_emulator.devices) == 1\n</code></pre>"},{"location":"tutorials/03-integration/#complete-test-suite-example","title":"Complete Test Suite Example","text":"<p>A comprehensive test module:</p> <pre><code># test_lifx_client.py\nimport pytest\nimport asyncio\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n)\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\n@pytest.fixture(scope=\"module\")\nasync def test_devices():\n    \"\"\"Module-level fixture with multiple devices.\"\"\"\n    devices = [\n        create_color_light(\"d073d5000001\"),\n        create_multizone_light(\"d073d8000001\", zone_count=16),\n    ]\n\n    devices[0].state.label = \"Color Light\"\n    devices[1].state.label = \"Strip Light\"\n\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        await asyncio.sleep(0.1)\n        yield server\n\n@pytest.mark.asyncio\nasync def test_device_count(test_devices):\n    \"\"\"Verify device count.\"\"\"\n    assert len(test_devices.devices) == 2\n\n@pytest.mark.asyncio\nasync def test_color_light_capabilities(test_devices):\n    \"\"\"Verify color light capabilities.\"\"\"\n    device = test_devices.devices[0]\n    assert device.state.has_color\n    assert not device.state.has_multizone\n\n@pytest.mark.asyncio\nasync def test_multizone_capabilities(test_devices):\n    \"\"\"Verify multizone capabilities.\"\"\"\n    device = test_devices.devices[1]\n    assert device.state.has_multizone\n    assert len(device.state.zone_colors) == 16\n\n@pytest.mark.asyncio\nasync def test_state_modification(test_devices):\n    \"\"\"Test state can be modified.\"\"\"\n    device = test_devices.devices[0]\n\n    # Modify color\n    new_color = LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500)\n    device.state.color = new_color\n\n    # Verify\n    assert device.state.color.hue == 21845\n</code></pre>"},{"location":"tutorials/03-integration/#next-steps","title":"Next Steps","text":"<ul> <li>Basic Examples - Review basic usage patterns</li> <li>Advanced Examples - Complex scenarios and error injection</li> <li>Best Practices Guide - Testing best practices</li> <li>pytest Documentation - Official pytest docs</li> </ul>"},{"location":"tutorials/03-integration/#see-also","title":"See Also","text":"<ul> <li>pytest-asyncio Documentation - Async test support</li> <li>pytest-xdist Documentation - Parallel test execution</li> <li>API Reference: Device - Device API documentation</li> <li>API Reference: Server - Server API documentation</li> </ul>"},{"location":"tutorials/04-advanced-scenarios/","title":"Advanced Examples","text":"<p>This page demonstrates advanced usage patterns including multizone devices, tiles, error injection, and complex testing scenarios.</p>"},{"location":"tutorials/04-advanced-scenarios/#multizone-light-standard","title":"Multizone Light (Standard)","text":"<p>Standard multizone devices like LIFX Z support up to 16 zones:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_multizone_light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\nasync def main():\n    # Create a LIFX Z strip with 16 zones\n    device = create_multizone_light(\"d073d8000001\", zone_count=16)\n\n    # Set different colors for each zone\n    for i in range(16):\n        # Create a rainbow effect\n        hue = int((65535 / 16) * i)\n        device.state.zone_colors[i] = LightHsbk(\n            hue=hue,\n            saturation=65535,\n            brightness=32768,\n            kelvin=3500\n        )\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Multizone device running with {len(device.state.zone_colors)} zones\")\n        print(\"Rainbow pattern configured\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#extended-multizone-beam","title":"Extended Multizone (Beam)","text":"<p>Extended multizone devices like LIFX Beam support up to 82 zones:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_multizone_light\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\nasync def main():\n    # Create a LIFX Beam with extended multizone support\n    device = create_multizone_light(\n        serial=\"d073d8000001\",\n        zone_count=80,\n        extended_multizone=True\n    )\n\n    # Extended multizone devices are backwards compatible\n    # They respond to both standard and extended multizone packets\n\n    print(f\"Extended multizone capabilities:\")\n    print(f\"  Zones: {len(device.state.zone_colors)}\")\n    print(f\"  Extended: {device.state.extended_multizone}\")\n    print(f\"  Product ID: {device.state.product_id}\")\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#tile-matrix-device","title":"Tile Matrix Device","text":"<p>Tile devices have a 2D matrix of zones arranged in a chain:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_tile_device\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\nasync def main():\n    # Create a LIFX Tile with 5 tiles in the chain\n    device = create_tile_device(\"d073d9000001\", tile_count=5)\n\n    # Each tile is 8x8 zones (64 zones)\n    print(f\"Tile device configuration:\")\n    print(f\"  Tiles: {len(device.state.tile_devices)}\")\n    for i, tile in enumerate(device.state.tile_devices):\n        print(f\"  Tile {i}: {tile.width}x{tile.height} = {len(tile.colors)} zones\")\n\n    # Set first tile to red\n    red = LightHsbk(hue=0, saturation=65535, brightness=32768, kelvin=3500)\n    for i in range(64):\n        device.state.tile_devices[0].colors[i] = red\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Tile device running\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#error-injection-packet-dropping","title":"Error Injection: Packet Dropping","text":"<p>Test client retry logic by dropping specific packets:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Configure device to drop GetColor requests (packet type 101)\n    device.scenarios = {\n        'drop_packets': [101]  # Drop all GetColor requests\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will silently drop GetColor packets\")\n        print(\"Clients should timeout and retry\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#error-injection-response-delays","title":"Error Injection: Response Delays","text":"<p>Simulate slow network or device processing:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Add delays to specific packet types\n    device.scenarios = {\n        'response_delays': {\n            101: 0.5,  # GetColor: 500ms delay\n            102: 1.0,  # SetColor: 1 second delay\n            20: 0.1,   # GetLabel: 100ms delay\n        }\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device configured with response delays:\")\n        print(\"  GetColor: 500ms\")\n        print(\"  SetColor: 1000ms\")\n        print(\"  GetLabel: 100ms\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#error-injection-malformed-packets","title":"Error Injection: Malformed Packets","text":"<p>Test client error handling with corrupted responses:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Send truncated/corrupted responses\n    device.scenarios = {\n        'malformed_packets': [107]  # Corrupt StateColor responses\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will send malformed StateColor packets\")\n        print(\"Test your client's error handling!\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#error-injection-invalid-field-values","title":"Error Injection: Invalid Field Values","text":"<p>Send responses with invalid data:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Send packets with all fields set to 0xFF\n    device.scenarios = {\n        'invalid_field_values': [107]  # Invalid StateColor data\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will send StateColor with invalid field values\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#error-injection-partial-responses","title":"Error Injection: Partial Responses","text":"<p>Send incomplete data to test client parsing:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Send truncated packet payloads\n    device.scenarios = {\n        'partial_responses': [107]  # Truncate StateColor\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device will send partial StateColor responses\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#combined-error-scenarios","title":"Combined Error Scenarios","text":"<p>Test multiple error conditions simultaneously:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Combine multiple error scenarios\n    device.scenarios = {\n        'drop_packets': [101],  # Drop GetColor\n        'response_delays': {\n            102: 0.5,  # Delay SetColor\n            20: 0.2,   # Delay GetLabel\n        },\n        'malformed_packets': [107],  # Corrupt StateColor\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device configured with multiple error scenarios:\")\n        print(\"  - Dropping GetColor packets\")\n        print(\"  - Delaying SetColor and GetLabel\")\n        print(\"  - Corrupting StateColor responses\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#multi-device-orchestration","title":"Multi-Device Orchestration","text":"<p>Coordinate multiple devices with different configurations:</p> <pre><code>import asyncio\nfrom lifx_emulator import (\n    EmulatedLifxServer,\n    create_color_light,\n    create_multizone_light,\n    create_tile_device,\n)\n\nasync def main():\n    # Create a diverse fleet of devices\n    devices = [\n        # Standard lights\n        create_color_light(\"d073d5000001\"),\n        create_color_light(\"d073d5000002\"),\n\n        # Multizone devices\n        create_multizone_light(\"d073d8000001\", zone_count=16),\n        create_multizone_light(\"d073d8000002\", zone_count=80, extended_multizone=True),\n\n        # Matrix device\n        create_tile_device(\"d073d9000001\", tile_count=5),\n    ]\n\n    # Configure different scenarios for different devices\n    devices[0].scenarios = {'response_delays': {102: 0.1}}\n    devices[1].scenarios = {'drop_packets': [101]}\n\n    # Customize device labels\n    devices[0].state.label = \"Living Room\"\n    devices[1].state.label = \"Bedroom\"\n    devices[2].state.label = \"Kitchen Strip\"\n    devices[3].state.label = \"Hallway Beam\"\n    devices[4].state.label = \"Office Tiles\"\n\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Running {len(devices)} devices:\")\n        for device in devices:\n            capabilities = []\n            if device.state.has_multizone:\n                capabilities.append(f\"multizone ({len(device.state.zone_colors)} zones)\")\n            if device.state.has_matrix:\n                capabilities.append(f\"matrix ({len(device.state.tile_devices)} tiles)\")\n            if device.state.has_color:\n                capabilities.append(\"color\")\n\n            print(f\"  {device.state.label}: {', '.join(capabilities)}\")\n\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Running 5 devices:\n  Living Room: color\n  Bedroom: color\n  Kitchen Strip: multizone (16 zones), color\n  Hallway Beam: multizone (80 zones), color\n  Office Tiles: matrix (5 tiles), color\n</code></pre></p>"},{"location":"tutorials/04-advanced-scenarios/#persistent-storage","title":"Persistent Storage","text":"<p>Enable state persistence across emulator restarts:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\nfrom lifx_emulator.async_storage import AsyncDeviceStorage\nfrom lifx_emulator.protocol.protocol_types import LightHsbk\n\nasync def main():\n    # Create async storage manager (uses ~/.lifx-emulator by default)\n    storage = AsyncDeviceStorage()\n\n    # Create device with storage enabled\n    device = create_color_light(\"d073d5000001\", storage=storage)\n\n    # Modify device state\n    device.state.label = \"Persistent Light\"\n    device.state.color = LightHsbk(\n        hue=21845,  # Green\n        saturation=65535,\n        brightness=32768,\n        kelvin=3500\n    )\n\n    # State changes are automatically queued for async save with debouncing\n    await storage.save_device_state(device.state)\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Device state will persist across restarts\")\n        print(f\"Storage location: {storage.storage_dir}\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#custom-firmware-version","title":"Custom Firmware Version","text":"<p>Emulate specific firmware versions:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n\n    # Override firmware version\n    device.scenarios = {\n        'firmware_version': (3, 70)  # Version 3.70\n    }\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"Device reporting firmware version: {device.scenarios['firmware_version']}\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#concurrent-client-testing","title":"Concurrent Client Testing","text":"<p>Test emulator with multiple concurrent clients:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\n\nasync def simulate_client(client_id, port):\n    \"\"\"Simulate a client sending packets.\"\"\"\n    await asyncio.sleep(client_id * 0.1)  # Stagger start times\n\n    reader, writer = await asyncio.open_connection(\"127.0.0.1\", port)\n\n    # Send some test packets here\n    # (This is a simplified example - actual implementation would\n    # construct proper LIFX protocol packets)\n\n    print(f\"Client {client_id} connected\")\n    await asyncio.sleep(5)\n\n    writer.close()\n    await writer.wait_closed()\n    print(f\"Client {client_id} disconnected\")\n\nasync def main():\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"Server running, simulating concurrent clients...\")\n\n        # Launch multiple concurrent clients\n        clients = [simulate_client(i, 56700) for i in range(10)]\n        await asyncio.gather(*clients)\n\n        print(\"All clients finished\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#hev-clean-light","title":"HEV (Clean) Light","text":"<p>Emulate LIFX Clean devices with HEV capability:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_hev_light\n\nasync def main():\n    device = create_hev_light(\"d073d5000001\")\n\n    # Configure HEV state\n    device.state.hev_cycle_config_duration = 7200  # 2 hours\n    device.state.hev_cycle_config_indication = True\n    device.state.last_hev_cycle_result = 0  # Success\n\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    async with server:\n        print(\"HEV light capabilities:\")\n        print(f\"  Has HEV: {device.state.has_hev}\")\n        print(f\"  Cycle duration: {device.state.hev_cycle_config_duration}s\")\n        print(f\"  Indication: {device.state.hev_cycle_config_indication}\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#creating-devices-from-product-ids","title":"Creating Devices from Product IDs","text":"<p>Use any product from the registry:</p> <pre><code>import asyncio\nfrom lifx_emulator import EmulatedLifxServer, create_device\nfrom lifx_emulator.products import get_product_by_id\n\nasync def main():\n    # List some interesting products\n    product_ids = [27, 32, 38, 55, 57, 90]\n\n    devices = []\n    for i, pid in enumerate(product_ids):\n        serial = f\"d073d500000{i+1}\"\n        device = create_device(pid, serial=serial)\n\n        # Get product info\n        product = get_product_by_id(pid)\n        print(f\"Created: {product.name} (product {pid})\")\n        print(f\"  Capabilities: {', '.join(product.capabilities)}\")\n\n        devices.append(device)\n\n    server = EmulatedLifxServer(devices, \"127.0.0.1\", 56700)\n\n    async with server:\n        print(f\"\\nRunning {len(devices)} different product types\")\n        await asyncio.sleep(60)\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#runtime-device-management-with-http-api","title":"Runtime Device Management with HTTP API","text":"<p>Add and remove devices dynamically using the HTTP API:</p> <pre><code>import asyncio\nimport aiohttp\nfrom lifx_emulator import EmulatedLifxServer, create_color_light\nfrom lifx_emulator.api import run_api_server\n\nasync def main():\n    # Start with one device\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", 56700)\n\n    # Run both emulator and API server\n    async with server:\n        # Start API server in background\n        api_task = asyncio.create_task(\n            run_api_server(server, host=\"127.0.0.1\", port=8080)\n        )\n\n        # Wait for API to start\n        await asyncio.sleep(1)\n\n        # Use API to add a new device\n        async with aiohttp.ClientSession() as session:\n            # Add a LIFX Z strip\n            async with session.post(\n                \"http://127.0.0.1:8080/api/devices\",\n                json={\"product_id\": 32, \"zone_count\": 16}\n            ) as resp:\n                result = await resp.json()\n                print(f\"Added device: {result}\")\n\n            # List all devices\n            async with session.get(\"http://127.0.0.1:8080/api/devices\") as resp:\n                devices = await resp.json()\n                print(f\"\\nTotal devices: {len(devices)}\")\n\n        await asyncio.sleep(60)\n\n        api_task.cancel()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre>"},{"location":"tutorials/04-advanced-scenarios/#next-steps","title":"Next Steps","text":"<ul> <li>Integration Examples - Comprehensive pytest patterns and test fixtures</li> <li>Basic Examples - Review basic usage patterns</li> <li>Testing Scenarios Guide - Detailed testing scenarios documentation</li> <li>API Reference: Device - Full device API reference</li> </ul>"},{"location":"tutorials/04-advanced-scenarios/#see-also","title":"See Also","text":"<ul> <li>Product Registry - All available product IDs and capabilities</li> <li>Storage API - Persistent storage documentation</li> <li>Scenario Management API Guide - Runtime device management and scenario testing</li> <li>Device Types - Understanding LIFX device capabilities</li> </ul>"},{"location":"tutorials/05-cicd/","title":"CI/CD Integration","text":"<p>Difficulty: \ud83d\udd34 Advanced | Time: \u23f1\ufe0f 30 minutes | Prerequisites: Integration Testing Tutorial</p> <p>This tutorial shows how to integrate the LIFX Emulator into your CI/CD pipelines using GitHub Actions, GitLab CI, and Docker.</p>"},{"location":"tutorials/05-cicd/#what-youll-learn","title":"What You'll Learn","text":"<ul> <li>Running the emulator in GitHub Actions</li> <li>GitLab CI configuration</li> <li>Docker containerization</li> <li>Port conflict management in CI</li> <li>Background process handling</li> <li>Test parallelization in CI</li> </ul>"},{"location":"tutorials/05-cicd/#github-actions-integration","title":"GitHub Actions Integration","text":""},{"location":"tutorials/05-cicd/#basic-workflow","title":"Basic Workflow","text":"<p>Create <code>.github/workflows/test.yml</code>:</p> <pre><code>name: Tests\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python\n      uses: actions/setup-python@v5\n      with:\n        python-version: '3.13'\n\n    - name: Install dependencies\n      run: |\n        pip install uv\n        uv sync\n\n    - name: Run tests with emulator\n      run: |\n        pytest tests/ -v\n</code></pre>"},{"location":"tutorials/05-cicd/#with-explicit-emulator-installation","title":"With Explicit Emulator Installation","text":"<p>If the emulator is a separate dependency:</p> <pre><code>    - name: Install LIFX Emulator\n      run: |\n        pip install lifx-emulator\n\n    - name: Run integration tests\n      run: |\n        pytest tests/integration/ -v --tb=short\n</code></pre>"},{"location":"tutorials/05-cicd/#matrix-testing-across-python-versions","title":"Matrix Testing Across Python Versions","text":"<pre><code>jobs:\n  test:\n    runs-on: ubuntu-latest\n    strategy:\n      matrix:\n        python-version: ['3.13', '3.14']\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v5\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Install dependencies\n      run: |\n        pip install -e .\n        pip install pytest pytest-asyncio\n\n    - name: Run tests\n      run: pytest tests/ -v\n</code></pre>"},{"location":"tutorials/05-cicd/#parallel-test-execution","title":"Parallel Test Execution","text":"<p>Using pytest-xdist for faster tests:</p> <pre><code>    - name: Install test dependencies\n      run: |\n        pip install pytest pytest-asyncio pytest-xdist\n\n    - name: Run tests in parallel\n      run: |\n        # -n auto: Use all available CPU cores\n        pytest tests/ -v -n auto\n</code></pre> <p>Note: Ensure your tests use dynamic port allocation to avoid conflicts:</p> <pre><code>def get_free_port():\n    \"\"\"Find an available port.\"\"\"\n    import socket\n    with socket.socket() as s:\n        s.bind(('', 0))\n        return s.getsockname()[1]\n\n@pytest.fixture\nasync def emulator():\n    port = get_free_port()\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n    async with server:\n        yield server\n</code></pre>"},{"location":"tutorials/05-cicd/#gitlab-ci-integration","title":"GitLab CI Integration","text":""},{"location":"tutorials/05-cicd/#basic-configuration","title":"Basic Configuration","text":"<p>Create <code>.gitlab-ci.yml</code>:</p> <pre><code>image: python:3.13\n\nstages:\n  - test\n\nvariables:\n  PIP_CACHE_DIR: \"$CI_PROJECT_DIR/.cache/pip\"\n\ncache:\n  paths:\n    - .cache/pip\n\nbefore_script:\n  - pip install uv\n  - uv sync\n\ntest:\n  stage: test\n  script:\n    - pytest tests/ -v --junitxml=report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n</code></pre>"},{"location":"tutorials/05-cicd/#with-coverage-reporting","title":"With Coverage Reporting","text":"<pre><code>test:\n  stage: test\n  script:\n    - pip install pytest-cov\n    - pytest tests/ -v --cov=src --cov-report=xml --cov-report=term\n  coverage: '/TOTAL.*\\s+(\\d+%)$/'\n  artifacts:\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage.xml\n</code></pre>"},{"location":"tutorials/05-cicd/#multiple-python-versions","title":"Multiple Python Versions","text":"<pre><code>.test_template:\n  stage: test\n  script:\n    - pip install -e .\n    - pytest tests/ -v\n\ntest:python3.13:\n  extends: .test_template\n  image: python:3.13\n\ntest:python3.14:\n  extends: .test_template\n  image: python:3.14\n</code></pre>"},{"location":"tutorials/05-cicd/#docker-integration","title":"Docker Integration","text":""},{"location":"tutorials/05-cicd/#dockerfile-for-testing","title":"Dockerfile for Testing","text":"<p>Create a <code>Dockerfile.test</code>:</p> <pre><code>FROM python:3.13-slim\n\n# Set working directory\nWORKDIR /app\n\n# Copy project files\nCOPY . /app\n\n# Install dependencies\nRUN pip install --no-cache-dir uv &amp;&amp; \\\n    uv sync\n\n# Run tests by default\nCMD [\"pytest\", \"tests/\", \"-v\"]\n</code></pre>"},{"location":"tutorials/05-cicd/#docker-compose-for-multi-container-testing","title":"Docker Compose for Multi-Container Testing","text":"<p>Create <code>docker-compose.test.yml</code>:</p> <pre><code>version: '3.8'\n\nservices:\n  emulator:\n    build:\n      context: .\n      dockerfile: Dockerfile.test\n    command: python -m lifx_emulator --color 3 --multizone 2\n    ports:\n      - \"56700:56700/udp\"\n    networks:\n      - test-network\n\n  tests:\n    build:\n      context: .\n      dockerfile: Dockerfile.test\n    command: pytest tests/integration/ -v\n    depends_on:\n      - emulator\n    networks:\n      - test-network\n    environment:\n      - LIFX_EMULATOR_HOST=emulator\n      - LIFX_EMULATOR_PORT=56700\n\nnetworks:\n  test-network:\n    driver: bridge\n</code></pre> <p>Run with:</p> <pre><code>docker-compose -f docker-compose.test.yml up --abort-on-container-exit\n</code></pre>"},{"location":"tutorials/05-cicd/#standalone-emulator-container","title":"Standalone Emulator Container","text":"<p>Build and run emulator in a container:</p> <pre><code># Dockerfile\nFROM python:3.13-slim\n\nWORKDIR /app\nCOPY . /app\n\nRUN pip install -e .\n\n# Expose UDP port\nEXPOSE 56700/udp\n\n# Run emulator with default configuration\nCMD [\"lifx-emulator\", \"--color\", \"3\", \"--multizone\", \"2\", \"--bind\", \"0.0.0.0\"]\n</code></pre> <p>Build and run:</p> <pre><code>docker build -t lifx-emulator .\ndocker run -p 56700:56700/udp lifx-emulator\n</code></pre>"},{"location":"tutorials/05-cicd/#background-process-management","title":"Background Process Management","text":""},{"location":"tutorials/05-cicd/#github-actions-background-service","title":"GitHub Actions Background Service","text":"<p>Run emulator as a background service:</p> <pre><code>    - name: Start LIFX Emulator\n      run: |\n        lifx-emulator --color 2 &amp;\n        echo $! &gt; emulator.pid\n        sleep 2  # Wait for startup\n\n    - name: Run tests\n      run: |\n        pytest tests/integration/ -v\n\n    - name: Stop LIFX Emulator\n      if: always()\n      run: |\n        if [ -f emulator.pid ]; then\n          kill $(cat emulator.pid) || true\n        fi\n</code></pre>"},{"location":"tutorials/05-cicd/#using-pytest-fixtures","title":"Using pytest Fixtures","text":"<p>Better approach - let pytest manage the process:</p> <pre><code># conftest.py\nimport pytest\nimport subprocess\nimport time\nimport signal\n\n@pytest.fixture(scope=\"session\")\ndef emulator_process():\n    \"\"\"Start emulator as subprocess for entire test session.\"\"\"\n    # Start emulator\n    proc = subprocess.Popen(\n        [\"lifx-emulator\", \"--color\", \"3\"],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE\n    )\n\n    # Wait for startup\n    time.sleep(2)\n\n    yield proc\n\n    # Cleanup\n    proc.send_signal(signal.SIGTERM)\n    proc.wait(timeout=5)\n</code></pre> <p>No CI configuration changes needed - tests manage the emulator themselves!</p>"},{"location":"tutorials/05-cicd/#port-conflict-handling","title":"Port Conflict Handling","text":""},{"location":"tutorials/05-cicd/#strategy-1-dynamic-port-allocation","title":"Strategy 1: Dynamic Port Allocation","text":"<pre><code>import socket\n\ndef get_free_port():\n    \"\"\"Get a free port from the OS.\"\"\"\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.bind(('', 0))\n        s.listen(1)\n        port = s.getsockname()[1]\n    return port\n\n@pytest.fixture\nasync def emulator_with_dynamic_port():\n    port = get_free_port()\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server, port\n</code></pre>"},{"location":"tutorials/05-cicd/#strategy-2-port-ranges-per-worker","title":"Strategy 2: Port Ranges per Worker","text":"<p>When using pytest-xdist:</p> <pre><code>@pytest.fixture\nasync def emulator(worker_id):\n    \"\"\"Each worker gets unique port.\"\"\"\n    if worker_id == 'master':\n        port = 56700\n    else:\n        # Extract worker number (gw0, gw1, etc.)\n        worker_num = int(worker_id.replace('gw', ''))\n        port = 56700 + worker_num + 1\n\n    device = create_color_light(f\"d073d500{worker_num:04d}\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n</code></pre>"},{"location":"tutorials/05-cicd/#strategy-3-environment-variables","title":"Strategy 3: Environment Variables","text":"<pre><code>import os\n\n@pytest.fixture\nasync def emulator():\n    # Allow port override via env var\n    port = int(os.getenv('LIFX_EMULATOR_PORT', '56700'))\n\n    device = create_color_light(\"d073d5000001\")\n    server = EmulatedLifxServer([device], \"127.0.0.1\", port)\n\n    async with server:\n        yield server\n</code></pre> <p>In CI:</p> <pre><code>    - name: Run tests on custom port\n      env:\n        LIFX_EMULATOR_PORT: 56800\n      run: pytest tests/ -v\n</code></pre>"},{"location":"tutorials/05-cicd/#complete-github-actions-example","title":"Complete GitHub Actions Example","text":"<p>Here's a production-ready workflow:</p> <pre><code>name: Integration Tests\n\non:\n  push:\n    branches: [ main, develop ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ${{ matrix.os }}\n    strategy:\n      matrix:\n        os: [ubuntu-latest, macos-latest, windows-latest]\n        python-version: ['3.13', '3.14']\n\n    steps:\n    - uses: actions/checkout@v4\n\n    - name: Set up Python ${{ matrix.python-version }}\n      uses: actions/setup-python@v5\n      with:\n        python-version: ${{ matrix.python-version }}\n\n    - name: Cache pip dependencies\n      uses: actions/cache@v3\n      with:\n        path: ~/.cache/pip\n        key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n        restore-keys: |\n          ${{ runner.os }}-pip-\n\n    - name: Install dependencies\n      run: |\n        pip install uv\n        uv sync\n        pip install pytest pytest-asyncio pytest-cov pytest-xdist\n\n    - name: Run tests with coverage\n      run: |\n        pytest tests/ -v -n auto \\\n          --cov=src \\\n          --cov-report=xml \\\n          --cov-report=term-missing\n\n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      if: matrix.os == 'ubuntu-latest' &amp;&amp; matrix.python-version == '3.13'\n      with:\n        file: ./coverage.xml\n        fail_ci_if_error: true\n</code></pre>"},{"location":"tutorials/05-cicd/#complete-gitlab-ci-example","title":"Complete GitLab CI Example","text":"<pre><code>image: python:3.13\n\nstages:\n  - test\n  - deploy\n\nvariables:\n  PIP_CACHE_DIR: \"$CI_PROJECT_DIR/.cache/pip\"\n\ncache:\n  paths:\n    - .cache/pip\n    - .venv/\n\nbefore_script:\n  - pip install uv\n  - uv sync\n\ntest:unit:\n  stage: test\n  script:\n    - pytest tests/unit/ -v --junitxml=report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: report.xml\n\ntest:integration:\n  stage: test\n  script:\n    - pytest tests/integration/ -v -n auto --junitxml=integration-report.xml\n  artifacts:\n    when: always\n    reports:\n      junit: integration-report.xml\n\ntest:coverage:\n  stage: test\n  script:\n    - pip install pytest-cov\n    - pytest tests/ -v --cov=src --cov-report=xml --cov-report=html\n  coverage: '/TOTAL.*\\s+(\\d+%)$/'\n  artifacts:\n    paths:\n      - htmlcov/\n    reports:\n      coverage_report:\n        coverage_format: cobertura\n        path: coverage.xml\n</code></pre>"},{"location":"tutorials/05-cicd/#testing-the-ci-configuration-locally","title":"Testing the CI Configuration Locally","text":""},{"location":"tutorials/05-cicd/#github-actions-with-act","title":"GitHub Actions with act","text":"<p>Install act:</p> <pre><code># macOS\nbrew install act\n\n# Linux\ncurl https://raw.githubusercontent.com/nektos/act/master/install.sh | sudo bash\n</code></pre> <p>Run workflows locally:</p> <pre><code># Run all jobs\nact\n\n# Run specific job\nact -j test\n\n# Run on specific event\nact pull_request\n</code></pre>"},{"location":"tutorials/05-cicd/#gitlab-ci-with-gitlab-runner","title":"GitLab CI with gitlab-runner","text":"<p>Install GitLab Runner:</p> <pre><code># macOS\nbrew install gitlab-runner\n\n# Linux\ncurl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash\nsudo apt-get install gitlab-runner\n</code></pre> <p>Test locally:</p> <pre><code>gitlab-runner exec docker test\n</code></pre>"},{"location":"tutorials/05-cicd/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/05-cicd/#1-use-fixture-scopes-appropriately","title":"1. Use Fixture Scopes Appropriately","text":"<pre><code># Session scope - shared across all tests (fastest)\n@pytest.fixture(scope=\"session\")\nasync def shared_emulator():\n    ...\n\n# Module scope - shared within a test file\n@pytest.fixture(scope=\"module\")\nasync def module_emulator():\n    ...\n\n# Function scope - fresh per test (slowest, most isolated)\n@pytest.fixture(scope=\"function\")\nasync def fresh_emulator():\n    ...\n</code></pre>"},{"location":"tutorials/05-cicd/#2-cache-dependencies","title":"2. Cache Dependencies","text":"<p>Always cache pip/uv dependencies in CI to speed up builds:</p> <pre><code># GitHub Actions\n\n- uses: actions/cache@v3\n  with:\n    path: ~/.cache/pip\n    key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}\n</code></pre>"},{"location":"tutorials/05-cicd/#3-use-timeouts","title":"3. Use Timeouts","text":"<p>Prevent hanging tests:</p> <pre><code>@pytest.mark.asyncio\n@pytest.mark.timeout(30)  # Fail after 30 seconds\nasync def test_with_timeout(emulator):\n    ...\n</code></pre> <p>In GitHub Actions:</p> <pre><code>jobs:\n  test:\n    timeout-minutes: 10  # Fail entire job after 10 minutes\n</code></pre>"},{"location":"tutorials/05-cicd/#4-collect-logs-on-failure","title":"4. Collect Logs on Failure","text":"<pre><code>    - name: Upload logs on failure\n      if: failure()\n      uses: actions/upload-artifact@v3\n      with:\n        name: test-logs\n        path: |\n          *.log\n          test-results/\n</code></pre>"},{"location":"tutorials/05-cicd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"tutorials/05-cicd/#tests-pass-locally-but-fail-in-ci","title":"Tests Pass Locally But Fail in CI","text":"<p>Common causes: - Port conflicts in CI environment - Timing issues (CI is slower) - Different Python versions - Missing dependencies</p> <p>Solutions: - Use dynamic port allocation - Add startup delays: <code>await asyncio.sleep(0.5)</code> - Pin Python version in CI config - Install all dependencies explicitly</p>"},{"location":"tutorials/05-cicd/#timeout-issues-in-ci","title":"Timeout Issues in CI","text":"<p>Problem: Tests timeout in CI but work locally</p> <p>Solutions: - Increase test timeouts - Use faster fixture scopes - Enable parallel testing with pytest-xdist - Check for deadlocks in async code</p>"},{"location":"tutorials/05-cicd/#windows-specific-issues","title":"Windows-Specific Issues","text":"<p>Problem: Tests fail on Windows runners</p> <p>Solution: Ensure proper async event loop handling:</p> <pre><code># conftest.py\nimport sys\nimport pytest\n\nif sys.platform == 'win32':\n    import asyncio\n    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())\n</code></pre>"},{"location":"tutorials/05-cicd/#next-steps","title":"Next Steps","text":"<ul> <li>Integration Testing - Review pytest patterns</li> <li>Advanced Examples - Learn error injection for CI tests</li> <li>Best Practices - Testing best practices</li> </ul>"},{"location":"tutorials/05-cicd/#see-also","title":"See Also","text":"<ul> <li>GitHub Actions Documentation</li> <li>GitLab CI Documentation</li> <li>pytest-xdist Documentation</li> <li>Docker Documentation</li> </ul>"}]}