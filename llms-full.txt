# LIFX Emulator

> A comprehensive LIFX device emulator for testing LIFX LAN protocol libraries

A comprehensive LIFX device emulator for testing LIFX LAN protocol libraries.

This emulator implements the binary UDP protocol from https://lan.developer.lifx.com
and emulates various LIFX device types including color lights, multizone strips,
tiles, infrared, and HEV devices. It provides a complete testing environment with
persistent storage, HTTP management API, and advanced scenario testing capabilities
for simulating protocol edge cases, packet loss, delays, and malformed responses.


# Getting Started

# Getting Started

Welcome to LIFX Emulator! This section will help you get up and running quickly.

## Learning Path

Follow these steps in order:

1. **[Installation](installation/)** - Install the emulator (5 minutes)
1. **[Quick Start](quickstart/)** - Create your first device (10 minutes)
1. **[CLI Usage](cli/)** - Learn command-line options (reference)

## What You'll Learn

By the end of this section, you'll be able to:

- Install LIFX Emulator using uv or pip
- Start the emulator with default settings
- Create emulated devices using Python or CLI
- Understand basic device discovery
- Use verbose mode for debugging

## Prerequisites

- **Python 3.11+** (or let uv manage it for you)
- Basic understanding of Python or command-line tools
- (Optional) Familiarity with LIFX devices or protocol

## Quick Preview

Here's what you'll be able to do after completing this section:

```bash
# Install (recommended: using uv)
uv tool install lifx-emulator

# Or using pip
pip install lifx-emulator

# Run with one color light
lifx-emulator

# Create multiple devices
lifx-emulator --color 2 --multizone 1 --tile 1 --verbose
```

Or in Python:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    await server.start()
    await asyncio.Event().wait()

asyncio.run(main())
```

## Why uv?

We recommend [uv](https://astral.sh/uv) because it:

- Automatically manages Python versions for you
- Is significantly faster than pip
- Handles virtual environments seamlessly
- Works consistently across platforms

## Next Steps

Once you've completed the getting started guide, explore:

- **[User Guides](../guide/)** - Deeper understanding of features
- **[Tutorials](../tutorials/)** - Hands-on learning with examples
- **[API Reference](../api/)** - Complete API documentation

## Need Help?

- [Troubleshooting Guide](../reference/troubleshooting/)
- [FAQ](../faq/)
- [GitHub Issues](https://github.com/Djelibeybi/lifx-emulator/issues)

# Installation

## Requirements

- Python 3.11 or higher
- pip or uv package manager

## Installation Methods

We support both `uv` (recommended) and `pip` for installation.

### As a CLI Tool

**Recommended: Using uv** (automatically manages Python environment):

```bash
uv tool install lifx-emulator
```

**Alternative: Using pip** (requires Python 3.11+ already installed):

```bash
pip install lifx-emulator
```

### As a Library in Your Project

**Recommended: Using uv**:

```bash
uv add lifx-emulator
```

**Alternative: Using pip** (requires Python 3.11+ already installed):

```bash
pip install lifx-emulator
```

Then in your code:

```python
from lifx_emulator import create_color_light, EmulatedLifxServer
```

### Development Installation

For development or to get the latest features:

```bash
# Install uv if you don't have it
curl -LsSf https://astral.sh/uv/install.sh | sh

# Clone the repository
git clone https://github.com/Djelibeybi/lifx-emulator.git
cd lifx-emulator

# Install dependencies and create virtual environment
uv sync

# Activate the virtual environment
source .venv/bin/activate
```

## Verify Installation

Test that the installation worked:

```bash
# Check CLI is available
lifx-emulator --help

# Run the emulator with verbose output
lifx-emulator --verbose
```

You should see output like:

```text
INFO - Starting LIFX Emulator on 127.0.0.1:56700
INFO - Created 1 emulated device(s):
INFO -   ‚Ä¢ A19 d073d5000001 (d073d5000001) - full color
INFO - Server running with verbose packet logging... Press Ctrl+C to stop
```

## Python API Verification

Test the Python API:

```python
from lifx_emulator import create_color_light

device = create_color_light("d073d5000001")
print(f"Device: {device.state.label}")
print(f"Product: {device.state.product}")
print(f"Has color: {device.state.has_color}")
```

## Dependencies

The emulator has minimal dependencies:

- **pyyaml**: For product registry and configuration
- **asyncio**: For asynchronous networking (built-in)

### Development Dependencies

For development, additional dependencies are installed:

- **pytest**: Testing framework
- **pytest-asyncio**: Async test support
- **ruff**: Fast Python linter
- **pyright**: Type checker
- **hatchling**: Build backend

## Troubleshooting

### Port Already in Use

If you see an error about port 56700 being in use:

```bash
# Use a different port
lifx-emulator --port 56701
```

### Python Version

Ensure you're using Python 3.11+:

```bash
python --version
```

If you need to manage Python versions, we recommend using uv, which automatically handles Python version management for tools and projects:

```bash
# Install uv
curl -LsSf https://astral.sh/uv/install.sh | sh

# uv will automatically manage Python for you
uv tool install lifx-emulator  # For CLI tool
# or
uv add lifx-emulator  # As a dependency of your project
```

### Import Errors

If you see import errors, ensure the package is installed:

```bash
pip show lifx-emulator
```

If not found, reinstall:

```bash
pip install --force-reinstall lifx-emulator
```

## Next Steps

- [Quick Start Guide](../quickstart/) - Create your first emulated device
- [CLI Usage](../cli/) - Learn all CLI commands
- [Device Types](../../guide/device-types/) - Explore supported devices

# Quick Start

Get started with LIFX Emulator in just a few minutes.

## Start the Emulator

The simplest way to start the emulator is with the default configuration:

```bash
lifx-emulator
```

This creates a single color light device listening on port 56700.

## Using Verbose Mode

To see all packet traffic (helpful for debugging):

```bash
lifx-emulator --verbose
```

You'll see output like:

```text
INFO - Starting LIFX Emulator on 127.0.0.1:56700
INFO - Created 1 emulated device(s):
INFO -   ‚Ä¢ A19 d073d5 (d073d5000001) - full color
INFO - Server running with verbose packet logging... Press Ctrl+C to stop
DEBUG - Received 36 bytes from ('192.168.1.100', 54321)
DEBUG - Header: GetService (type=2) target=000000000000 source=12345678
DEBUG - Sending StateService to ('192.168.1.100', 54321)
```

## Create Multiple Devices

Create different device types:

```bash
# Create 2 color lights, 1 multizone strip, and 1 tile
lifx-emulator --color 2 --multizone 1 --tile 1
```

## Use Specific Products

Create devices by product ID from the LIFX registry:

```bash
# Create LIFX A19 (27), LIFX Z (32), and LIFX Tile (55)
lifx-emulator --product 27 --product 32 --product 55
```

See all available products:

```bash
lifx-emulator list-products
```

## Python API

Use the emulator in your Python tests:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    # Create a color light
    device = create_color_light("d073d5000001")

    # Start server
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    await server.start()

    print(f"Server running with device: {device.state.label}")

    # Keep running
    try:
        await asyncio.Event().wait()
    except KeyboardInterrupt:
        await server.stop()

if __name__ == "__main__":
    asyncio.run(main())
```

```python
import asyncio
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

async def main():
    # Create different device types
    devices = [
        create_color_light("d073d5000001"),
        create_multizone_light("d073d8000001", zone_count=16),
        create_tile_device("d073d9000001", tile_count=5),
    ]

    # Start server
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
    await server.start()

    print(f"Server running with {len(devices)} devices")

    try:
        await asyncio.Event().wait()
    except KeyboardInterrupt:
        await server.stop()

if __name__ == "__main__":
    asyncio.run(main())
```

```python
import asyncio
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light
from your_lifx_library import LifxClient

@pytest.mark.asyncio
async def test_discover_devices():
    # Create emulated devices
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Use your LIFX library
        client = LifxClient()
        await client.discover(port=56700)

        # Verify discovery
        assert len(client.devices) == 1
        assert client.devices[0].serial == "d073d5000001"

@pytest.mark.asyncio
async def test_set_color():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        client = LifxClient()
        await client.discover(port=56700)

        # Set color
        await client.devices[0].set_color(hue=120, saturation=1.0, brightness=0.5)

        # Verify state changed
        assert device.state.color.hue == 21845  # 120 degrees in LIFX format
        assert device.state.color.saturation == 65535
        assert device.state.color.brightness == 32768
```

## Device Discovery

The emulator responds to discovery broadcasts on port 56700 (or your chosen port). Your LIFX library should be able to discover emulated devices just like real ones.

Example with a typical discovery flow:

1. Your library broadcasts `GetService` (packet type 2)
1. Emulator responds with `StateService` listing UDP service on port 56700
1. Your library sends `GetVersion` to get product info
1. Emulator responds with vendor=1, product=27 (or configured product)
1. Your library can now send commands to control the device

## Next Steps

- [CLI Usage Guide](../cli/) - Learn all CLI options
- [Device Types](../../guide/device-types/) - Explore supported devices
- [Testing Scenarios](../../guide/testing-scenarios/) - Configure error scenarios
- [API Reference](../../api/) - Complete API documentation
- [Tutorials](../../tutorials/) - More code examples

# CLI Usage

Complete guide to the `lifx-emulator` command-line interface.

## Basic Usage

```bash
lifx-emulator [OPTIONS] [COMMAND]
```

## Commands

### `lifx-emulator` (default)

Start the emulator server with configurable devices.

**Example:**

```bash
lifx-emulator --color 2 --multizone 1 --verbose
```

### `lifx-emulator list-products`

List all available LIFX products from the registry.

**Example:**

```bash
lifx-emulator list-products
```

**With filter:**

```bash
# List only multizone products
lifx-emulator list-products --filter-type multizone

# List only matrix products (tiles)
lifx-emulator list-products --filter-type matrix
```

## Server Options

### `--bind <IP>`

IP address to bind to.

- **Default:** `127.0.0.1` (localhost only)
- **Example:** `--bind 0.0.0.0` (all IP addresses)

### `--port <PORT>`

UDP port to listen on.

- **Default:** `56700` (standard LIFX port)
- **Example:** `--port 56701`

### `--verbose`

Enable verbose logging showing all packet traffic.

- **Default:** `False`
- **Example:** `--verbose`

### `--persistent`

Enable persistent storage of device state across sessions. Device state (label, power, color, location, group, etc.) is saved to `~/.lifx-emulator/` and automatically restored on restart.

- **Default:** `False`
- **Example:** `--persistent`

### `--persistent-scenarios`

Enable persistent storage of scenario configurations across sessions. Scenarios are saved to `~/.lifx-emulator/scenarios.json`. Requires `--persistent` to be enabled.

- **Default:** `False`
- **Example:** `--persistent --persistent-scenarios`

## API Server Options

### `--api`

Enable HTTP API server for monitoring and device management. Provides a web dashboard and REST API for runtime control.

- **Default:** `False`
- **Example:** `--api`

### `--api-host <IP>`

IP address for the API server to bind to.

- **Default:** `127.0.0.1` (localhost only)
- **Example:** `--api-host 0.0.0.0`

### `--api-port <PORT>`

Port for the API server.

- **Default:** `8080`
- **Example:** `--api-port 9090`

### `--api-activity <BOOL>`

Enable activity logging in the API (last 100 packets). Disable to reduce traffic and save UI space.

- **Default:** `True`
- **Example:** `--api-activity=false`

## Product Selection

### `--product <product ID>`

Create devices by product ID from the registry. Can be specified multiple times.

**Example:**

```bash
# Create LIFX A19 (27) and LIFX Z (32)
lifx-emulator --product 27 --product 32

# Create multiple of same product
lifx-emulator --product 55 --product 55 --product 55
```

When using `--product`, the default `--color 1` is suppressed unless explicitly set.

## Device Type Options

### `--color <COUNT>`

Number of color lights to emulate (LIFX A19).

- **Default:** `1`
- **Product:** 27 (LIFX A19)
- **Example:** `--color 3`

### `--color-temperature <COUNT>`

Number of color temperature lights to emulate (LIFX Mini White to Warm).

- **Default:** `0`
- **Product:** 50 (LIFX Mini White to Warm)
- **Example:** `--color-temperature 2`

### `--infrared <COUNT>`

Number of infrared lights to emulate (LIFX A19 Night Vision).

- **Default:** `0`
- **Product:** 29 (LIFX A19 Night Vision)
- **Example:** `--infrared 1`

### `--HEV <COUNT>`

Number of HEV/Clean lights to emulate (LIFX Clean).

- **Default:** `0`
- **Product:** 90 (LIFX Clean)
- **Example:** `--HEV 2`

### `--multizone <COUNT>`

Number of multizone devices to emulate (strips/beams).

- **Default:** `0`
- **Product:** 32 (LIFX Z) or 38 (LIFX Beam with extended)
- **Example:** `--multizone 2`

### `--multizone-zones <COUNT>`

Number of zones per multizone device. If not specified, uses product defaults:

- LIFX Z: 16 zones
- LIFX Beam: 80 zones
- **Default:** `None` (uses product defaults)
- **Example:** `--multizone-zones 24`

### `--multizone-extended` / `--no-multizone-extended`

Enable or disable extended multizone support for multizone devices.

- **Default:** `True` (creates LIFX Beam with firmware 3.70)
- **Enabled:** `--multizone-extended` (default, firmware 3.70)
- **Disabled:** `--no-multizone-extended` (creates LIFX Z, firmware 2.60)
- **Example:** `--no-multizone-extended --multizone-zones 16`

### `--tile <COUNT>`

Number of tile devices to emulate (LIFX Tile).

- **Default:** `0`
- **Product:** 55 (LIFX Tile)
- **Example:** `--tile 1`

### `--tile-count <COUNT>`

Number of tiles per tile device. If not specified, uses product default (5 for LIFX Tile).

- **Default:** `None` (uses product defaults)
- **Example:** `--tile-count 10`

### `--tile-width <PIXELS>`

Width of each tile in pixels. If not specified, uses product default (typically 8).

- **Default:** `None` (uses product defaults)
- **Example:** `--tile-width 16`

### `--tile-height <PIXELS>`

Height of each tile in pixels. If not specified, uses product default (typically 8).

- **Default:** `None` (uses product defaults)
- **Example:** `--tile-height 8`

## serial Options

### `--serial-prefix <PREFIX>`

serial prefix (6 hex characters).

- **Default:** `d073d5`
- **Example:** `--serial-prefix cafe00`

serials are formatted as `<prefix><suffix>` where suffix is auto-incremented starting from `serial-start`.

### `--serial-start <NUMBER>`

Starting serial suffix.

- **Default:** `1`
- **Example:** `--serial-start 100`

## Complete Examples

### Default Configuration

```bash
# Single color light on port 56700
lifx-emulator
```

### Verbose Mode

```bash
# Show all packet traffic
lifx-emulator --verbose
```

### Custom Port

```bash
# Use port 56701
lifx-emulator --port 56701
```

### Multiple Device Types

```bash
# 2 color lights, 1 multizone, 1 tile
lifx-emulator --color 2 --multizone 1 --tile 1
```

### Extended Multizone

```bash
# LIFX Beam with 60 zones
lifx-emulator --multizone 1 --multizone-extended --multizone-zones 60
```

### Specific Products

```bash
# LIFX A19, LIFX Z, and LIFX Tile
lifx-emulator --product 27 --product 32 --product 55
```

### Mix Products and Types

```bash
# Specific product + additional generic devices
lifx-emulator --product 27 --color 2 --multizone 1
```

### Custom serials

```bash
# Custom prefix and starting number
lifx-emulator --serial-prefix cafe00 --serial-start 100 --color 3
# Creates: cafe00000064, cafe00000065, cafe00000066
```

### Only Specific Types

```bash
# No default devices, only infrared and HEV
lifx-emulator --color 0 --infrared 3 --HEV 2
```

### Discovery Testing

```bash
# Create many devices for load testing
lifx-emulator --color 10 --multizone 5 --tile 3
```

### Localhost Only

```bash
# Bind to localhost for security
lifx-emulator --bind 127.0.0.1 --verbose
```

### With HTTP API

```bash
# Enable web dashboard and REST API
lifx-emulator --api --color 2 --multizone 1

# Custom API port
lifx-emulator --api --api-port 9090

# API without activity logging (reduces traffic)
lifx-emulator --api --api-activity=false
```

### Persistent Storage

```bash
# Enable state persistence
lifx-emulator --persistent --color 2

# Enable both state and scenario persistence
lifx-emulator --persistent --persistent-scenarios --api
```

### Non-Extended Multizone

```bash
# Create LIFX Z (non-extended, 16 zones max)
lifx-emulator --multizone 2 --no-multizone-extended --multizone-zones 16
```

## List Products Command

### Basic List

```bash
lifx-emulator list-products
```

Output:

```text
LIFX Product Registry (137 products)

 product ID ‚îÇ Product Name                              ‚îÇ Capabilities
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  27 ‚îÇ LIFX A19                                  ‚îÇ full color
  29 ‚îÇ LIFX A19 Night Vision                     ‚îÇ full color, infrared
  32 ‚îÇ LIFX Z                                    ‚îÇ full color, multizone
  38 ‚îÇ LIFX Beam                                 ‚îÇ full color, extended-multizone
  55 ‚îÇ LIFX Tile                                 ‚îÇ full color, matrix
  90 ‚îÇ LIFX Clean                                ‚îÇ full color, HEV
 ...
```

### Filter by Type

```bash
# Only multizone products
lifx-emulator list-products --filter-type multizone

# Only matrix products
lifx-emulator list-products --filter-type matrix

# Only HEV products
lifx-emulator list-products --filter-type HEV

# Only infrared products
lifx-emulator list-products --filter-type infrared

# Only full color products
lifx-emulator list-products --filter-type color
```

## Tips

### Quick Testing

For quick testing, use verbose mode to see all traffic:

```bash
lifx-emulator --verbose
```

### Visual Monitoring

Use the HTTP API for visual monitoring during development:

```bash
lifx-emulator --api --verbose
# Open http://localhost:8080 in your browser
```

The web dashboard shows:

- Real-time server statistics
- List of all devices
- Recent packet activity (last 100 packets)
- REST API for runtime device management

### CI/CD Integration

Use specific ports and localhost binding in CI:

```bash
lifx-emulator --bind 127.0.0.1 --port 56701 &
EMULATOR_PID=$!
# Run your tests
kill $EMULATOR_PID
```

### Product Discovery

List products to find the right product ID for your tests:

```bash
lifx-emulator list-products --filter-type multizone
```

### State Preservation

Enable persistence to maintain device state across test runs:

```bash
lifx-emulator --persistent
# Device labels, colors, power states persist across restarts
```

### Realistic Configurations

Use product defaults for realistic device configurations:

```bash
# LIFX Beam with default 80 zones (extended by default)
lifx-emulator --multizone 1

# LIFX Tile with default 5 tiles
lifx-emulator --tile 1
```

### Development Mode

For development with full observability:

```bash
# Verbose logging, API dashboard, persistent state
lifx-emulator --verbose --api --persistent --color 2 --multizone 1
```

### Testing Mode

For testing network issues and edge cases:

```bash
# API enabled for runtime scenario configuration
lifx-emulator --api --color 3
# Then use the REST API to configure packet loss, delays, etc.
```

## Next Steps

- [Device Types Guide](../../guide/device-types/) - Learn about each device type
- [Testing Scenarios](../../guide/testing-scenarios/) - Configure error scenarios
- [API Reference](../../api/) - Python API documentation
- [Tutorials](../../tutorials/) - More usage examples
# Tutorials

# Tutorials Overview

Step-by-step tutorials to master the LIFX Emulator, organized from beginner to advanced.

## Learning Path

Follow these tutorials in order for the best learning experience:

1. **üü¢ Beginner** - [First Device](01-first-device/) - Your first emulated LIFX device (‚è±Ô∏è 10-15 minutes)
1. **üü¢ Beginner** - [Basic Usage](02-basic/) - Multiple devices and basic operations (‚è±Ô∏è 15-30 minutes)
1. **üü° Intermediate** - [Integration Testing](03-integration/) - Using the emulator in test suites (‚è±Ô∏è 30-45 minutes)
1. **üî¥ Advanced** - [Advanced Scenarios](04-advanced-scenarios/) - Error injection and complex testing (‚è±Ô∏è 45-60 minutes)
1. **üî¥ Advanced** - [CI/CD Integration](05-cicd/) - Automated testing pipelines (‚è±Ô∏è 30-45 minutes)

## Tutorial Categories

### Getting Started

Learn the basics:

- Creating a single device
- Starting the server
- Using the context manager
- Basic server configuration

### Multiple Devices

Work with multiple devices:

- Creating different device types
- Managing device collections
- Testing multi-device scenarios

### Testing Integration

Integrate with test frameworks:

- pytest fixtures
- pytest-asyncio usage
- Module-scoped fixtures
- Test isolation strategies

### Error Scenarios

Test error handling:

- Packet dropping
- Response delays
- Malformed packets
- Invalid field values
- Partial responses

## Complete Example

Here's a complete example showing multiple features:

```python
import asyncio
import pytest
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

@pytest.fixture
async def lifx_devices():
    """Create a diverse set of emulated devices."""
    devices = [
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),
        create_multizone_light("d073d8000001", zone_count=16),
        create_multizone_light("d073d8000002", zone_count=82, extended_multizone=True),
        create_tile_device("d073d9000001", tile_count=5),
    ]

    # Configure error scenarios for one device
    devices[0].scenarios = {
        'response_delays': {102: 0.1},  # Delay SetColor by 100ms
    }

    return devices

@pytest.fixture
async def lifx_server(lifx_devices):
    """Start emulator server with devices."""
    server = EmulatedLifxServer(lifx_devices, "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_discovery(lifx_server):
    """Test device discovery."""
    # Your test code here
    pass

@pytest.mark.asyncio
async def test_color_control(lifx_server):
    """Test color control commands."""
    # Your test code here
    pass
```

## Next Steps

Browse the specific tutorial pages for detailed code samples and explanations. Each tutorial builds on the concepts from the previous one.

# Your First LIFX Device

**Difficulty:** üü¢ Beginner | **Time:** ‚è±Ô∏è 5 minutes | **Prerequisites:** Python 3.11+, LIFX Emulator installed

This tutorial walks you through creating and running your first emulated LIFX device. By the end, you'll have a virtual LIFX light running on your machine that responds to LIFX protocol commands.

## What You'll Learn

- How to create a single emulated device
- How to start the emulator server
- How to verify the device is running
- How to test it with a LIFX client (optional)

## Step 1: Create Your First Device

Create a new Python file called `first_device.py`:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    # Create a LIFX A19 color light
    device = create_color_light("d073d5000001")

    # Create server on standard LIFX port (56700)
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    # Start the server
    async with server:
        print(f"‚úì Emulator running!")
        print(f"‚úì Device: {device.state.label}")
        print(f"‚úì Serial: {device.state.serial}")
        print(f"‚úì Listening on: 127.0.0.1:56700")
        print("\nPress Ctrl+C to stop")

        # Keep server running
        try:
            await asyncio.sleep(3600)  # Run for 1 hour
        except KeyboardInterrupt:
            print("\n‚úì Shutting down...")

if __name__ == "__main__":
    asyncio.run(main())
```

## Step 2: Run the Emulator

Run your script:

```bash
python first_device.py
```

You should see output like:

```text
‚úì Emulator running!
‚úì Device: LIFX Light
‚úì Serial: d073d5000001
‚úì Listening on: 127.0.0.1:56700

Press Ctrl+C to stop
```

**Congratulations!** You now have a virtual LIFX device running on your machine.

## Step 3: Understanding What's Happening

Let's break down what each part does:

### Creating the Device

```python
device = create_color_light("d073d5000001")
```

- `create_color_light()` - Creates a LIFX A19 bulb (product ID 27)
- `"d073d5000001"` - The device's unique serial number (MAC address)

### Creating the Server

```python
server = EmulatedLifxServer([device], "127.0.0.1", 56700)
```

- `[device]` - List of devices to emulate (we have one)
- `"127.0.0.1"` - IP address to bind to (localhost)
- `56700` - Standard LIFX UDP port

### Using the Context Manager

```python
async with server:
    # Server is running here
    await asyncio.sleep(3600)
```

The `async with` statement:

1. Starts the server automatically
1. Runs your code inside the block
1. Stops the server cleanly when done

## Step 4: Customizing Your Device (Optional)

You can customize the device before starting the server:

```python
from lifx_emulator.protocol.protocol_types import LightHsbk

# Create device
device = create_color_light("d073d5000001")

# Customize it
device.state.label = "My First Light"
device.state.power = 65535  # On (max power)
device.state.color = LightHsbk(
    hue=21845,      # Green (120 degrees)
    saturation=65535,  # Fully saturated
    brightness=32768,  # 50% brightness
    kelvin=3500
)

# Now start the server...
```

## Step 5: Testing with a LIFX Client (Optional)

If you have a LIFX client library installed, you can test your emulated device.

### Using the lifx-async library

Install the library:

```bash
pip install lifx-async
```

In a **separate terminal**, create `test_client.py`:

```python
import asyncio
from lifx import discover
from lifx.color import HSBK

async def main():
    # Discover devices
    async with discover() as group:
        print(f"Found {len(group.devices)} device(s)")

        if group.devices:
            device = group.devices[0]
            print(f"Device: {device.label}")
            print(f"Power: {device.power}")

            # Change color to red
            print("Setting color to red...")
            await device.set_color(HSBK.from_rgb(255, 0, 0))
            print("Done!")

asyncio.run(main())
```

Run it while your emulator is running:

```bash
python test_client.py
```

You should see:

```text
Found 1 device(s)
Device: LIFX Light
Power: 65535
Setting color to red...
Done!
```

## Troubleshooting

### Port Already in Use

**Error:** `OSError: [Errno 48] Address already in use`

**Solution:** Change the port number:

```python
server = EmulatedLifxServer([device], "127.0.0.1", 56701)  # Different port
```

### Device Not Discovered

**Problem:** Client can't find the device

**Solutions:**

1. Make sure the emulator is running
1. Check that both emulator and client are on the same network interface
1. Try binding to `"0.0.0.0"` instead of `"127.0.0.1"`:

```python
server = EmulatedLifxServer([device], "0.0.0.0", 56700)
```

### Python Version Error

**Error:** `SyntaxError` or import errors

**Solution:** Ensure you're using Python 3.11 or newer:

```bash
python --version  # Should show 3.11 or higher
```

## What You've Learned

‚úì How to create an emulated LIFX device ‚úì How to start the emulator server ‚úì How to use the context manager pattern ‚úì How to customize device properties ‚úì How to test with a LIFX client

## Next Steps

Now that you have a basic device running, you can:

1. **[Basic Usage Tutorial](../02-basic/)** - Learn more patterns (multiple devices, state queries, etc.)
1. **[Integration Testing](../03-integration/)** - Use the emulator in your pytest test suite
1. **[Advanced Scenarios](../04-advanced-scenarios/)** - Explore multizone devices, tiles, and error injection

### Quick Wins

Try these modifications to your `first_device.py`:

- **Multiple devices:** Add more devices to the list:

  ```python
  devices = [
      create_color_light("d073d5000001"),
      create_color_light("d073d5000002"),
      create_color_light("d073d5000003"),
  ]
  server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
  ```

- **Different device type:** Try a multizone strip:

  ```python
  from lifx_emulator import create_multizone_light
  device = create_multizone_light("d073d8000001", zone_count=16)
  ```

- **Custom labels:** Give each device a unique name:

  ```python
  device.state.label = "Living Room"
  ```

## See Also

- [CLI Usage](../../getting-started/cli/) - Quick command-line testing
- [Device Types](../../guide/device-types/) - Understanding different LIFX devices
- [API Reference: Device](../../api/device/) - Complete device API documentation

# Basic Examples

This page demonstrates basic usage patterns for the LIFX Emulator. These examples cover the most common use cases for getting started.

## Single Device Creation

The simplest way to start is with a single color light:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    # Create a single LIFX color light (A19)
    device = create_color_light("d073d5000001")

    # Create and start the server
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print(f"Emulator running with device {device.state.serial}")
        print(f"Label: {device.state.label}")
        print(f"Product: {device.state.product_id}")

        # Keep server running
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Output:**

```text
Emulator running with device d073d5000001
Label: LIFX Light
Product: 27
```

## Using Context Manager (Recommended)

The context manager automatically handles server startup and shutdown:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    # Server starts automatically on entry, stops on exit
    async with server:
        print("Server is running")
        await asyncio.sleep(60)

    print("Server has stopped cleanly")

if __name__ == "__main__":
    asyncio.run(main())
```

## Multiple Devices on Same Server

Run multiple devices simultaneously:

```python
import asyncio
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_color_temperature_light,
    create_infrared_light,
)

async def main():
    # Create different device types
    devices = [
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),
        create_color_temperature_light("d073d5000003"),
        create_infrared_light("d073d5000004"),
    ]

    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        print(f"Running {len(devices)} devices:")
        for device in devices:
            print(f"  - {device.state.serial}: {device.state.label} "
                  f"(product {device.state.product_id})")

        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Output:**

```text
Running 4 devices:
  - d073d5000001: LIFX Light (product 27)
  - d073d5000002: LIFX Light (product 27)
  - d073d5000003: LIFX Light (product 50)
  - d073d5000004: LIFX+ A19 (product 29)
```

## Query Device State

Access device state at any time:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Access current device state
        state = device.state

        print(f"Serial: {state.serial}")
        print(f"Label: {state.label}")
        print(f"Power: {state.power}")
        print(f"Color: H={state.color.hue}, S={state.color.saturation}, "
              f"B={state.color.brightness}, K={state.color.kelvin}")
        print(f"Capabilities:")
        print(f"  - Color: {state.has_color}")
        print(f"  - Infrared: {state.has_infrared}")
        print(f"  - Multizone: {state.has_multizone}")
        print(f"  - Matrix: {state.has_matrix}")

        await asyncio.sleep(1)

if __name__ == "__main__":
    asyncio.run(main())
```

**Output:**

```text
Serial: d073d5000001
Label: LIFX Light
Power: 65535
Color: H=0, S=0, B=65535, K=3500
Capabilities:
  - Color: True
  - Infrared: False
  - Multizone: False
  - Matrix: False
```

## Custom Port and Bind Address

Configure the server's network settings:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Bind to specific IP and port
    # Use "0.0.0.0" to listen on all interfaces
    server = EmulatedLifxServer(
        devices=[device],
        bind_address="127.0.0.1",
        port=56701  # Non-standard port
    )

    async with server:
        print(f"Server listening on 127.0.0.1:56701")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Setting Initial Device State

Customize device state before starting the server:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light
from lifx_emulator.protocol.protocol_types import LightHsbk

async def main():
    device = create_color_light("d073d5000001")

    # Configure device state before starting
    device.state.label = "Living Room Light"
    device.state.power = 65535  # On
    device.state.color = LightHsbk(
        hue=21845,      # 120¬∞ (green)
        saturation=65535,  # Fully saturated
        brightness=32768,  # 50% brightness
        kelvin=3500
    )

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print(f"Device ready with custom state:")
        print(f"  Label: {device.state.label}")
        print(f"  Power: {'On' if device.state.power else 'Off'}")
        print(f"  Color: Green at 50% brightness")

        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Creating Devices by Product ID

Use the universal factory to create any device type:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_device

async def main():
    # Create devices using product IDs from the registry
    devices = [
        create_device(27, serial="d073d5000001"),  # LIFX A19
        create_device(32, serial="d073d5000002"),  # LIFX Z (strip)
        create_device(55, serial="d073d5000003"),  # LIFX Tile
        create_device(90, serial="d073d5000004"),  # LIFX Clean (HEV)
    ]

    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        print("Devices created by product ID:")
        for device in devices:
            capabilities = []
            if device.state.has_color:
                capabilities.append("color")
            if device.state.has_multizone:
                capabilities.append("multizone")
            if device.state.has_matrix:
                capabilities.append("matrix")
            if device.state.has_hev:
                capabilities.append("hev")

            print(f"  - Product {device.state.product_id}: {', '.join(capabilities)}")

        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Output:**

```text
Devices created by product ID:
  - Product 27: color
  - Product 32: color, multizone
  - Product 55: color, matrix
  - Product 90: color, hev
```

## Testing with a LIFX Client

Here's how to test your emulated device with a real LIFX LAN client library:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

# Example using lifxlan library (install with: pip install lifxlan)
from lifxlan import LifxLAN

async def run_emulator():
    """Run the emulator in the background."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Emulator running, press Ctrl+C to stop")
        await asyncio.sleep(3600)  # Run for 1 hour

def test_with_client():
    """Test the emulator using a LIFX client."""
    # Discover devices on the local network
    lifx = LifxLAN()
    devices = lifx.get_devices()

    print(f"Found {len(devices)} device(s)")

    for device in devices:
        print(f"\nDevice: {device.get_label()}")
        print(f"Power: {device.get_power()}")

        # Change color to red
        device.set_color([65535, 65535, 32768, 3500])  # Red, full brightness
        print("Changed color to red")

# Run the emulator (in production, use separate processes or async tasks)
if __name__ == "__main__":
    # In real usage, run emulator and client in separate processes/terminals
    asyncio.run(run_emulator())
```

## Simple pytest Example

Basic pytest integration:

```python
import pytest
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def emulator():
    """Pytest fixture for emulator."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_device_responds(emulator):
    """Test that device is accessible."""
    assert len(emulator.devices) == 1
    device = emulator.devices[0]
    assert device.state.serial == "d073d5000001"
    assert device.state.has_color is True
```

## Next Steps

- **[Integration Examples](../03-integration/)** - Comprehensive pytest patterns and test fixtures
- **[Advanced Examples](../04-advanced-scenarios/)** - Complex scenarios with multizone, tiles, and error injection
- **[API Reference: Device](../../api/device/)** - Full EmulatedLifxDevice API documentation
- **[API Reference: Server](../../api/server/)** - Full EmulatedLifxServer API documentation

## See Also

- [CLI Usage](../../getting-started/cli/) - Command-line interface for quick testing
- [Product Registry](../../api/products/) - Available product IDs and capabilities
- [Device Types Guide](../../guide/device-types/) - Understanding different LIFX device types

# Integration Testing Examples

This page demonstrates how to integrate the LIFX Emulator into your test suites using pytest, pytest-asyncio, and other testing frameworks.

## Basic pytest Fixture

The simplest pytest integration pattern:

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def lifx_server():
    """Basic emulator fixture."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_server_running(lifx_server):
    """Test that the server is running."""
    assert len(lifx_server.devices) == 1
    assert lifx_server.devices[0].state.serial == "d073d5000001"
```

## Function-Scoped Fixtures

Create a fresh emulator for each test (default scope):

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture(scope="function")
async def lifx_emulator():
    """Function-scoped fixture - new emulator per test."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_first(lifx_emulator):
    """First test gets a fresh emulator."""
    assert len(lifx_emulator.devices) == 1

@pytest.mark.asyncio
async def test_second(lifx_emulator):
    """Second test gets a different fresh emulator."""
    assert len(lifx_emulator.devices) == 1
```

## Module-Scoped Fixtures

Share one emulator across all tests in a module:

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture(scope="module")
async def shared_emulator():
    """Module-scoped fixture - shared across all tests in module."""
    devices = [
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),
    ]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_first_device(shared_emulator):
    """Test using shared emulator."""
    assert shared_emulator.devices[0].state.serial == "d073d5000001"

@pytest.mark.asyncio
async def test_second_device(shared_emulator):
    """Another test using the same emulator instance."""
    assert shared_emulator.devices[1].state.serial == "d073d5000002"
```

## Fixture with Custom Configuration

Create parameterized fixtures for different scenarios:

```python
import pytest
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
)

@pytest.fixture
async def basic_device():
    """Single color light fixture."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.fixture
async def multizone_device():
    """Multizone strip fixture."""
    device = create_multizone_light("d073d8000001", zone_count=16)
    server = EmulatedLifxServer([device], "127.0.0.1", 56701)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_color_light(basic_device):
    """Test with color light."""
    assert basic_device.devices[0].state.has_color

@pytest.mark.asyncio
async def test_multizone_light(multizone_device):
    """Test with multizone light."""
    assert multizone_device.devices[0].state.has_multizone
    assert len(multizone_device.devices[0].state.zone_colors) == 16
```

## Parametrized Tests

Test against multiple device types:

```python
import pytest
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

@pytest.fixture(params=[
    ("color", create_color_light, "d073d5000001"),
    ("multizone", lambda s: create_multizone_light(s, zone_count=16), "d073d8000001"),
    ("tile", lambda s: create_tile_device(s, tile_count=5), "d073d9000001"),
])
async def any_device(request):
    """Parametrized fixture for different device types."""
    device_type, factory, serial = request.param
    device = factory(serial)
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server, device_type

@pytest.mark.asyncio
async def test_all_devices_respond(any_device):
    """Test runs 3 times, once for each device type."""
    server, device_type = any_device
    print(f"Testing {device_type} device")
    assert len(server.devices) == 1
```

## Port Management

Avoid port conflicts when running tests in parallel:

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

def get_free_port():
    """Find an available port."""
    import socket
    with socket.socket() as s:
        s.bind(('', 0))
        return s.getsockname()[1]

@pytest.fixture
async def emulator_on_free_port():
    """Use dynamically allocated port."""
    device = create_color_light("d073d5000001")
    port = get_free_port()
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server, port

@pytest.mark.asyncio
async def test_with_dynamic_port(emulator_on_free_port):
    """Test using dynamic port allocation."""
    server, port = emulator_on_free_port
    print(f"Emulator running on port {port}")
    assert len(server.devices) == 1
```

## Test Isolation with Fresh Devices

Ensure each test has clean state:

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light
from lifx_emulator.protocol.protocol_types import LightHsbk

@pytest.fixture
async def fresh_device():
    """Create a fresh device for each test."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_modify_color(fresh_device):
    """Test that modifies device state."""
    device = fresh_device.devices[0]

    # Modify state
    device.state.color = LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500)

    # Verify modification
    assert device.state.color.hue == 21845

@pytest.mark.asyncio
async def test_default_color(fresh_device):
    """Test gets fresh device with default state."""
    device = fresh_device.devices[0]

    # Fresh device should have default color (not modified by previous test)
    assert device.state.color.hue == 0  # Default
```

## Cleanup and Resource Management

Ensure proper cleanup even when tests fail:

```python
import pytest
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def emulator_with_cleanup():
    """Fixture with explicit cleanup."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    # Start server
    async with server:
        try:
            yield server
        finally:
            # Cleanup always runs, even if test fails
            print("Cleaning up emulator resources")
            # Server stops automatically when exiting context manager

@pytest.mark.asyncio
async def test_that_might_fail(emulator_with_cleanup):
    """Test with guaranteed cleanup."""
    # Even if this test raises an exception, cleanup runs
    assert len(emulator_with_cleanup.devices) == 1
```

## Testing with Real LIFX Clients

Integration test with an actual LIFX client library:

```python
import pytest
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

# This example uses lifxlan library: pip install lifxlan
from lifxlan import LifxLAN

@pytest.fixture
async def emulator_for_client():
    """Emulator configured for client testing."""
    device = create_color_light("d073d5000001")
    device.state.label = "Test Light"
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Give server time to start
        await asyncio.sleep(0.1)
        yield server

@pytest.mark.asyncio
async def test_client_discovery(emulator_for_client):
    """Test client can discover emulated device."""
    # Run client code in separate thread/task
    lifx = LifxLAN()

    # Small timeout for local network
    devices = lifx.get_devices()

    assert len(devices) == 1
    assert devices[0].get_label() == "Test Light"

@pytest.mark.asyncio
async def test_client_set_color(emulator_for_client):
    """Test client can control emulated device."""
    lifx = LifxLAN()
    devices = lifx.get_devices()
    device = devices[0]

    # Change color to red
    device.set_color([65535, 65535, 32768, 3500])

    # Verify state change in emulator
    emu_device = emulator_for_client.devices[0]
    assert emu_device.state.color.hue == 65535  # Red
```

## Parallel Test Execution

Configure for pytest-xdist parallel execution:

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def isolated_emulator(worker_id):
    """Isolated emulator for parallel testing."""
    # Use worker_id to get unique port per worker
    if worker_id == 'master':
        port = 56700
    else:
        # Extract worker number and add to base port
        worker_num = int(worker_id.replace('gw', ''))
        port = 56700 + worker_num

    device = create_color_light(f"d073d500000{port % 100}")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_parallel_safe(isolated_emulator):
    """Test that can run in parallel with others."""
    assert len(isolated_emulator.devices) == 1
```

Run with: `pytest -n auto` (requires pytest-xdist)

## conftest.py Organization

Organize fixtures in conftest.py for reuse:

```python
# conftest.py
import pytest
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
)

@pytest.fixture(scope="session")
def event_loop():
    """Create event loop for async tests."""
    import asyncio
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
async def single_color_light():
    """Reusable single color light fixture."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.fixture
async def multiple_devices():
    """Reusable multi-device fixture."""
    devices = [
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),
        create_multizone_light("d073d8000001", zone_count=16),
    ]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        yield server
```

## Testing Error Scenarios

Test your client's error handling:

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def unreliable_device():
    """Device configured to drop packets."""
    device = create_color_light("d073d5000001")
    device.scenarios = {
        'drop_packets': [101],  # Drop GetColor
        'response_delays': {102: 1.0},  # Delay SetColor
    }
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_client_retry_logic(unreliable_device):
    """Test that client handles dropped packets."""
    # Your client should implement retry logic
    # This test verifies it works correctly
    pass

@pytest.mark.asyncio
async def test_client_timeout_handling(unreliable_device):
    """Test that client handles slow responses."""
    # Your client should timeout appropriately
    # This test verifies timeout behavior
    pass
```

## Mock vs Emulator Decision

When to use emulator vs mocks:

```python
import pytest
from unittest.mock import Mock, AsyncMock
from lifx_emulator import EmulatedLifxServer, create_color_light

# Use emulator for integration tests
@pytest.fixture
async def integration_emulator():
    """Full emulator for integration testing."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_integration_with_emulator(integration_emulator):
    """Integration test using real emulated device."""
    # Test full protocol interaction
    assert len(integration_emulator.devices) == 1

# Use mocks for unit tests
def test_unit_with_mock():
    """Unit test using mock."""
    # Mock is faster and more isolated for unit tests
    mock_device = Mock()
    mock_device.state.serial = "d073d5000001"
    mock_device.state.has_color = True

    # Test your code that uses the device
    assert mock_device.state.has_color
```

**When to use Emulator:**

- Integration tests with real protocol
- Testing client library implementations
- End-to-end workflow testing
- Protocol compliance testing

**When to use Mocks:**

- Unit tests for business logic
- Fast test suites
- Testing error conditions that are hard to trigger
- Isolating code under test

## Testing with Docker

Run emulator in Docker for CI/CD:

```python
# test_docker.py
import pytest
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture(scope="session")
async def dockerized_emulator():
    """
    In CI/CD, you can run emulator in a separate container.
    This fixture connects to it.
    """
    # In actual usage, emulator runs in separate container
    # This is a simplified example for local testing
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "0.0.0.0", 56700)

    async with server:
        await asyncio.sleep(0.1)  # Allow server to start
        yield server

@pytest.mark.asyncio
async def test_with_docker(dockerized_emulator):
    """Test against dockerized emulator."""
    # Connect to emulator (in real case, from different container)
    assert len(dockerized_emulator.devices) == 1
```

**Dockerfile example:**

```dockerfile
FROM python:3.13-slim

WORKDIR /app
COPY . /app

RUN pip install -e .

EXPOSE 56700/udp

CMD ["lifx-emulator", "--color", "3", "--multizone", "2"]
```

## Background Server Pattern

Run emulator as background task during tests:

```python
import pytest
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def background_emulator():
    """Emulator running as background task."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    # Start server manually
    await server.start()

    # Start server task in background
    task = asyncio.create_task(server.run())

    try:
        # Wait for server to be ready
        await asyncio.sleep(0.1)
        yield server
    finally:
        # Stop server
        await server.stop()
        task.cancel()
        try:
            await task
        except asyncio.CancelledError:
            pass

@pytest.mark.asyncio
async def test_with_background_server(background_emulator):
    """Test with server running in background."""
    assert len(background_emulator.devices) == 1
```

## Complete Test Suite Example

A comprehensive test module:

```python
# test_lifx_client.py
import pytest
import asyncio
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
)
from lifx_emulator.protocol.protocol_types import LightHsbk

@pytest.fixture(scope="module")
async def test_devices():
    """Module-level fixture with multiple devices."""
    devices = [
        create_color_light("d073d5000001"),
        create_multizone_light("d073d8000001", zone_count=16),
    ]

    devices[0].state.label = "Color Light"
    devices[1].state.label = "Strip Light"

    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        await asyncio.sleep(0.1)
        yield server

@pytest.mark.asyncio
async def test_device_count(test_devices):
    """Verify device count."""
    assert len(test_devices.devices) == 2

@pytest.mark.asyncio
async def test_color_light_capabilities(test_devices):
    """Verify color light capabilities."""
    device = test_devices.devices[0]
    assert device.state.has_color
    assert not device.state.has_multizone

@pytest.mark.asyncio
async def test_multizone_capabilities(test_devices):
    """Verify multizone capabilities."""
    device = test_devices.devices[1]
    assert device.state.has_multizone
    assert len(device.state.zone_colors) == 16

@pytest.mark.asyncio
async def test_state_modification(test_devices):
    """Test state can be modified."""
    device = test_devices.devices[0]

    # Modify color
    new_color = LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500)
    device.state.color = new_color

    # Verify
    assert device.state.color.hue == 21845
```

## Next Steps

- **[Basic Examples](../02-basic/)** - Review basic usage patterns
- **[Advanced Examples](../04-advanced-scenarios/)** - Complex scenarios and error injection
- **[Best Practices Guide](../../guide/best-practices/)** - Testing best practices
- **[pytest Documentation](https://docs.pytest.org/)** - Official pytest docs

## See Also

- [pytest-asyncio Documentation](https://pytest-asyncio.readthedocs.io/) - Async test support
- [pytest-xdist Documentation](https://pytest-xdist.readthedocs.io/) - Parallel test execution
- [API Reference: Device](../../api/device/) - Device API documentation
- [API Reference: Server](../../api/server/) - Server API documentation

# Advanced Examples

This page demonstrates advanced usage patterns including multizone devices, tiles, error injection, and complex testing scenarios.

## Multizone Light (Standard)

Standard multizone devices like LIFX Z support up to 16 zones:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_multizone_light
from lifx_emulator.protocol.protocol_types import LightHsbk

async def main():
    # Create a LIFX Z strip with 16 zones
    device = create_multizone_light("d073d8000001", zone_count=16)

    # Set different colors for each zone
    for i in range(16):
        # Create a rainbow effect
        hue = int((65535 / 16) * i)
        device.state.zone_colors[i] = LightHsbk(
            hue=hue,
            saturation=65535,
            brightness=32768,
            kelvin=3500
        )

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print(f"Multizone device running with {len(device.state.zone_colors)} zones")
        print("Rainbow pattern configured")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Extended Multizone (Beam)

Extended multizone devices like LIFX Beam support up to 82 zones:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_multizone_light
from lifx_emulator.protocol.protocol_types import LightHsbk

async def main():
    # Create a LIFX Beam with extended multizone support
    device = create_multizone_light(
        serial="d073d8000001",
        zone_count=80,
        extended_multizone=True
    )

    # Extended multizone devices are backwards compatible
    # They respond to both standard and extended multizone packets

    print(f"Extended multizone capabilities:")
    print(f"  Zones: {len(device.state.zone_colors)}")
    print(f"  Extended: {device.state.extended_multizone}")
    print(f"  Product ID: {device.state.product_id}")

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Tile Matrix Device

Tile devices have a 2D matrix of zones arranged in a chain:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_tile_device
from lifx_emulator.protocol.protocol_types import LightHsbk

async def main():
    # Create a LIFX Tile with 5 tiles in the chain
    device = create_tile_device("d073d9000001", tile_count=5)

    # Each tile is 8x8 pixels (64 zones)
    print(f"Tile device configuration:")
    print(f"  Tiles: {len(device.state.tile_devices)}")
    for i, tile in enumerate(device.state.tile_devices):
        print(f"  Tile {i}: {tile.width}x{tile.height} = {len(tile.colors)} zones")

    # Set first tile to red
    red = LightHsbk(hue=0, saturation=65535, brightness=32768, kelvin=3500)
    for i in range(64):
        device.state.tile_devices[0].colors[i] = red

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Tile device running")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Error Injection: Packet Dropping

Test client retry logic by dropping specific packets:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Configure device to drop GetColor requests (packet type 101)
    device.scenarios = {
        'drop_packets': [101]  # Drop all GetColor requests
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will silently drop GetColor packets")
        print("Clients should timeout and retry")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Error Injection: Response Delays

Simulate slow network or device processing:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Add delays to specific packet types
    device.scenarios = {
        'response_delays': {
            101: 0.5,  # GetColor: 500ms delay
            102: 1.0,  # SetColor: 1 second delay
            20: 0.1,   # GetLabel: 100ms delay
        }
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device configured with response delays:")
        print("  GetColor: 500ms")
        print("  SetColor: 1000ms")
        print("  GetLabel: 100ms")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Error Injection: Malformed Packets

Test client error handling with corrupted responses:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Send truncated/corrupted responses
    device.scenarios = {
        'malformed_packets': [107]  # Corrupt StateColor responses
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will send malformed StateColor packets")
        print("Test your client's error handling!")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Error Injection: Invalid Field Values

Send responses with invalid data:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Send packets with all fields set to 0xFF
    device.scenarios = {
        'invalid_field_values': [107]  # Invalid StateColor data
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will send StateColor with invalid field values")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Error Injection: Partial Responses

Send incomplete data to test client parsing:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Send truncated packet payloads
    device.scenarios = {
        'partial_responses': [107]  # Truncate StateColor
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will send partial StateColor responses")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Combined Error Scenarios

Test multiple error conditions simultaneously:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Combine multiple error scenarios
    device.scenarios = {
        'drop_packets': [101],  # Drop GetColor
        'response_delays': {
            102: 0.5,  # Delay SetColor
            20: 0.2,   # Delay GetLabel
        },
        'malformed_packets': [107],  # Corrupt StateColor
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device configured with multiple error scenarios:")
        print("  - Dropping GetColor packets")
        print("  - Delaying SetColor and GetLabel")
        print("  - Corrupting StateColor responses")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Multi-Device Orchestration

Coordinate multiple devices with different configurations:

```python
import asyncio
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

async def main():
    # Create a diverse fleet of devices
    devices = [
        # Standard lights
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),

        # Multizone devices
        create_multizone_light("d073d8000001", zone_count=16),
        create_multizone_light("d073d8000002", zone_count=80, extended_multizone=True),

        # Matrix device
        create_tile_device("d073d9000001", tile_count=5),
    ]

    # Configure different scenarios for different devices
    devices[0].scenarios = {'response_delays': {102: 0.1}}
    devices[1].scenarios = {'drop_packets': [101]}

    # Customize device labels
    devices[0].state.label = "Living Room"
    devices[1].state.label = "Bedroom"
    devices[2].state.label = "Kitchen Strip"
    devices[3].state.label = "Hallway Beam"
    devices[4].state.label = "Office Tiles"

    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        print(f"Running {len(devices)} devices:")
        for device in devices:
            capabilities = []
            if device.state.has_multizone:
                capabilities.append(f"multizone ({len(device.state.zone_colors)} zones)")
            if device.state.has_matrix:
                capabilities.append(f"matrix ({len(device.state.tile_devices)} tiles)")
            if device.state.has_color:
                capabilities.append("color")

            print(f"  {device.state.label}: {', '.join(capabilities)}")

        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Output:**

```text
Running 5 devices:
  Living Room: color
  Bedroom: color
  Kitchen Strip: multizone (16 zones), color
  Hallway Beam: multizone (80 zones), color
  Office Tiles: matrix (5 tiles), color
```

## Persistent Storage

Enable state persistence across emulator restarts:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light
from lifx_emulator.async_storage import AsyncDeviceStorage
from lifx_emulator.protocol.protocol_types import LightHsbk

async def main():
    # Create async storage manager (uses ~/.lifx-emulator by default)
    storage = AsyncDeviceStorage()

    # Create device with storage enabled
    device = create_color_light("d073d5000001", storage=storage)

    # Modify device state
    device.state.label = "Persistent Light"
    device.state.color = LightHsbk(
        hue=21845,  # Green
        saturation=65535,
        brightness=32768,
        kelvin=3500
    )

    # State changes are automatically queued for async save with debouncing
    await storage.save_device_state(device.state)

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device state will persist across restarts")
        print(f"Storage location: {storage.storage_dir}")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Custom Firmware Version

Emulate specific firmware versions:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Override firmware version
    device.scenarios = {
        'firmware_version': (3, 70)  # Version 3.70
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print(f"Device reporting firmware version: {device.scenarios['firmware_version']}")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Concurrent Client Testing

Test emulator with multiple concurrent clients:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def simulate_client(client_id, port):
    """Simulate a client sending packets."""
    await asyncio.sleep(client_id * 0.1)  # Stagger start times

    reader, writer = await asyncio.open_connection("127.0.0.1", port)

    # Send some test packets here
    # (This is a simplified example - actual implementation would
    # construct proper LIFX protocol packets)

    print(f"Client {client_id} connected")
    await asyncio.sleep(5)

    writer.close()
    await writer.wait_closed()
    print(f"Client {client_id} disconnected")

async def main():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Server running, simulating concurrent clients...")

        # Launch multiple concurrent clients
        clients = [simulate_client(i, 56700) for i in range(10)]
        await asyncio.gather(*clients)

        print("All clients finished")

if __name__ == "__main__":
    asyncio.run(main())
```

## HEV (Clean) Light

Emulate LIFX Clean devices with HEV capability:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_hev_light

async def main():
    device = create_hev_light("d073d5000001")

    # Configure HEV state
    device.state.hev_cycle_config_duration = 7200  # 2 hours
    device.state.hev_cycle_config_indication = True
    device.state.last_hev_cycle_result = 0  # Success

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("HEV light capabilities:")
        print(f"  Has HEV: {device.state.has_hev}")
        print(f"  Cycle duration: {device.state.hev_cycle_config_duration}s")
        print(f"  Indication: {device.state.hev_cycle_config_indication}")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Creating Devices from Product IDs

Use any product from the registry:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_device
from lifx_emulator.products import get_product_by_id

async def main():
    # List some interesting products
    product_ids = [27, 32, 38, 55, 57, 90]

    devices = []
    for i, pid in enumerate(product_ids):
        serial = f"d073d500000{i+1}"
        device = create_device(pid, serial=serial)

        # Get product info
        product = get_product_by_id(pid)
        print(f"Created: {product.name} (product {pid})")
        print(f"  Capabilities: {', '.join(product.capabilities)}")

        devices.append(device)

    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        print(f"\nRunning {len(devices)} different product types")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Runtime Device Management with HTTP API

Add and remove devices dynamically using the HTTP API:

```python
import asyncio
import aiohttp
from lifx_emulator import EmulatedLifxServer, create_color_light
from lifx_emulator.api import run_api_server

async def main():
    # Start with one device
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    # Run both emulator and API server
    async with server:
        # Start API server in background
        api_task = asyncio.create_task(
            run_api_server(server, host="127.0.0.1", port=8080)
        )

        # Wait for API to start
        await asyncio.sleep(1)

        # Use API to add a new device
        async with aiohttp.ClientSession() as session:
            # Add a LIFX Z strip
            async with session.post(
                "http://127.0.0.1:8080/api/devices",
                json={"product_id": 32, "zone_count": 16}
            ) as resp:
                result = await resp.json()
                print(f"Added device: {result}")

            # List all devices
            async with session.get("http://127.0.0.1:8080/api/devices") as resp:
                devices = await resp.json()
                print(f"\nTotal devices: {len(devices)}")

        await asyncio.sleep(60)

        api_task.cancel()

if __name__ == "__main__":
    asyncio.run(main())
```

## Next Steps

- **[Integration Examples](../03-integration/)** - Comprehensive pytest patterns and test fixtures
- **[Basic Examples](../02-basic/)** - Review basic usage patterns
- **[Testing Scenarios Guide](../../guide/testing-scenarios/)** - Detailed testing scenarios documentation
- **[API Reference: Device](../../api/device/)** - Full device API reference

## See Also

- [Product Registry](../../api/products/) - All available product IDs and capabilities
- [Storage API](../../api/storage/) - Persistent storage documentation
- [Scenario Management API Guide](../../advanced/scenario-api/) - Runtime device management and scenario testing
- [Device Types](../../guide/device-types/) - Understanding LIFX device capabilities

# CI/CD Integration

**Difficulty:** üî¥ Advanced | **Time:** ‚è±Ô∏è 30 minutes | **Prerequisites:** [Integration Testing Tutorial](../03-integration/)

This tutorial shows how to integrate the LIFX Emulator into your CI/CD pipelines using GitHub Actions, GitLab CI, and Docker.

## What You'll Learn

- Running the emulator in GitHub Actions
- GitLab CI configuration
- Docker containerization
- Port conflict management in CI
- Background process handling
- Test parallelization in CI

## GitHub Actions Integration

### Basic Workflow

Create `.github/workflows/test.yml`:

```yaml
name: Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.13'

    - name: Install dependencies
      run: |
        pip install uv
        uv sync

    - name: Run tests with emulator
      run: |
        pytest tests/ -v
```

### With Explicit Emulator Installation

If the emulator is a separate dependency:

```yaml
    - name: Install LIFX Emulator
      run: |
        pip install lifx-emulator

    - name: Run integration tests
      run: |
        pytest tests/integration/ -v --tb=short
```

### Matrix Testing Across Python Versions

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.13', '3.14']

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        pip install -e .
        pip install pytest pytest-asyncio

    - name: Run tests
      run: pytest tests/ -v
```

### Parallel Test Execution

Using pytest-xdist for faster tests:

```yaml
    - name: Install test dependencies
      run: |
        pip install pytest pytest-asyncio pytest-xdist

    - name: Run tests in parallel
      run: |
        # -n auto: Use all available CPU cores
        pytest tests/ -v -n auto
```

**Note:** Ensure your tests use dynamic port allocation to avoid conflicts:

```python
def get_free_port():
    """Find an available port."""
    import socket
    with socket.socket() as s:
        s.bind(('', 0))
        return s.getsockname()[1]

@pytest.fixture
async def emulator():
    port = get_free_port()
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", port)
    async with server:
        yield server
```

## GitLab CI Integration

### Basic Configuration

Create `.gitlab-ci.yml`:

```yaml
image: python:3.13

stages:
  - test

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

cache:
  paths:
    - .cache/pip

before_script:
  - pip install uv
  - uv sync

test:
  stage: test
  script:
    - pytest tests/ -v --junitxml=report.xml
  artifacts:
    when: always
    reports:
      junit: report.xml
```

### With Coverage Reporting

```yaml
test:
  stage: test
  script:
    - pip install pytest-cov
    - pytest tests/ -v --cov=src --cov-report=xml --cov-report=term
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
```

### Multiple Python Versions

```yaml
.test_template:
  stage: test
  script:
    - pip install -e .
    - pytest tests/ -v

test:python3.13:
  extends: .test_template
  image: python:3.13

test:python3.14:
  extends: .test_template
  image: python:3.14
```

## Docker Integration

### Dockerfile for Testing

Create a `Dockerfile.test`:

```dockerfile
FROM python:3.13-slim

# Set working directory
WORKDIR /app

# Copy project files
COPY . /app

# Install dependencies
RUN pip install --no-cache-dir uv && \
    uv sync

# Run tests by default
CMD ["pytest", "tests/", "-v"]
```

### Docker Compose for Multi-Container Testing

Create `docker-compose.test.yml`:

```yaml
version: '3.8'

services:
  emulator:
    build:
      context: .
      dockerfile: Dockerfile.test
    command: python -m lifx_emulator --color 3 --multizone 2
    ports:
      - "56700:56700/udp"
    networks:
      - test-network

  tests:
    build:
      context: .
      dockerfile: Dockerfile.test
    command: pytest tests/integration/ -v
    depends_on:
      - emulator
    networks:
      - test-network
    environment:
      - LIFX_EMULATOR_HOST=emulator
      - LIFX_EMULATOR_PORT=56700

networks:
  test-network:
    driver: bridge
```

Run with:

```bash
docker-compose -f docker-compose.test.yml up --abort-on-container-exit
```

### Standalone Emulator Container

Build and run emulator in a container:

```dockerfile
# Dockerfile
FROM python:3.13-slim

WORKDIR /app
COPY . /app

RUN pip install -e .

# Expose UDP port
EXPOSE 56700/udp

# Run emulator with default configuration
CMD ["lifx-emulator", "--color", "3", "--multizone", "2", "--bind", "0.0.0.0"]
```

Build and run:

```bash
docker build -t lifx-emulator .
docker run -p 56700:56700/udp lifx-emulator
```

## Background Process Management

### GitHub Actions Background Service

Run emulator as a background service:

```yaml
    - name: Start LIFX Emulator
      run: |
        lifx-emulator --color 2 &
        echo $! > emulator.pid
        sleep 2  # Wait for startup

    - name: Run tests
      run: |
        pytest tests/integration/ -v

    - name: Stop LIFX Emulator
      if: always()
      run: |
        if [ -f emulator.pid ]; then
          kill $(cat emulator.pid) || true
        fi
```

### Using pytest Fixtures

Better approach - let pytest manage the process:

```python
# conftest.py
import pytest
import subprocess
import time
import signal

@pytest.fixture(scope="session")
def emulator_process():
    """Start emulator as subprocess for entire test session."""
    # Start emulator
    proc = subprocess.Popen(
        ["lifx-emulator", "--color", "3"],
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE
    )

    # Wait for startup
    time.sleep(2)

    yield proc

    # Cleanup
    proc.send_signal(signal.SIGTERM)
    proc.wait(timeout=5)
```

No CI configuration changes needed - tests manage the emulator themselves!

## Port Conflict Handling

### Strategy 1: Dynamic Port Allocation

```python
import socket

def get_free_port():
    """Get a free port from the OS."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0))
        s.listen(1)
        port = s.getsockname()[1]
    return port

@pytest.fixture
async def emulator_with_dynamic_port():
    port = get_free_port()
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server, port
```

### Strategy 2: Port Ranges per Worker

When using pytest-xdist:

```python
@pytest.fixture
async def emulator(worker_id):
    """Each worker gets unique port."""
    if worker_id == 'master':
        port = 56700
    else:
        # Extract worker number (gw0, gw1, etc.)
        worker_num = int(worker_id.replace('gw', ''))
        port = 56700 + worker_num + 1

    device = create_color_light(f"d073d500{worker_num:04d}")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server
```

### Strategy 3: Environment Variables

```python
import os

@pytest.fixture
async def emulator():
    # Allow port override via env var
    port = int(os.getenv('LIFX_EMULATOR_PORT', '56700'))

    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server
```

In CI:

```yaml
    - name: Run tests on custom port
      env:
        LIFX_EMULATOR_PORT: 56800
      run: pytest tests/ -v
```

## Complete GitHub Actions Example

Here's a production-ready workflow:

```yaml
name: Integration Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        python-version: ['3.13', '3.14']

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Cache pip dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: Install dependencies
      run: |
        pip install uv
        uv sync
        pip install pytest pytest-asyncio pytest-cov pytest-xdist

    - name: Run tests with coverage
      run: |
        pytest tests/ -v -n auto \
          --cov=src \
          --cov-report=xml \
          --cov-report=term-missing

    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      if: matrix.os == 'ubuntu-latest' && matrix.python-version == '3.13'
      with:
        file: ./coverage.xml
        fail_ci_if_error: true
```

## Complete GitLab CI Example

```yaml
image: python:3.13

stages:
  - test
  - deploy

variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"

cache:
  paths:
    - .cache/pip
    - .venv/

before_script:
  - pip install uv
  - uv sync

test:unit:
  stage: test
  script:
    - pytest tests/unit/ -v --junitxml=report.xml
  artifacts:
    when: always
    reports:
      junit: report.xml

test:integration:
  stage: test
  script:
    - pytest tests/integration/ -v -n auto --junitxml=integration-report.xml
  artifacts:
    when: always
    reports:
      junit: integration-report.xml

test:coverage:
  stage: test
  script:
    - pip install pytest-cov
    - pytest tests/ -v --cov=src --cov-report=xml --cov-report=html
  coverage: '/TOTAL.*\s+(\d+%)$/'
  artifacts:
    paths:
      - htmlcov/
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
```

## Testing the CI Configuration Locally

### GitHub Actions with act

Install [act](https://github.com/nektos/act):

```bash
# macOS
brew install act

# Linux
curl https://raw.githubusercontent.com/nektos/act/master/install.sh | sudo bash
```

Run workflows locally:

```bash
# Run all jobs
act

# Run specific job
act -j test

# Run on specific event
act pull_request
```

### GitLab CI with gitlab-runner

Install GitLab Runner:

```bash
# macOS
brew install gitlab-runner

# Linux
curl -L https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.deb.sh | sudo bash
sudo apt-get install gitlab-runner
```

Test locally:

```bash
gitlab-runner exec docker test
```

## Best Practices

### 1. Use Fixture Scopes Appropriately

```python
# Session scope - shared across all tests (fastest)
@pytest.fixture(scope="session")
async def shared_emulator():
    ...

# Module scope - shared within a test file
@pytest.fixture(scope="module")
async def module_emulator():
    ...

# Function scope - fresh per test (slowest, most isolated)
@pytest.fixture(scope="function")
async def fresh_emulator():
    ...
```

### 2. Cache Dependencies

Always cache pip/uv dependencies in CI to speed up builds:

```yaml
# GitHub Actions

- uses: actions/cache@v3
  with:
    path: ~/.cache/pip
    key: ${{ runner.os }}-pip-${{ hashFiles('**/pyproject.toml') }}
```

### 3. Use Timeouts

Prevent hanging tests:

```python
@pytest.mark.asyncio
@pytest.mark.timeout(30)  # Fail after 30 seconds
async def test_with_timeout(emulator):
    ...
```

In GitHub Actions:

```yaml
jobs:
  test:
    timeout-minutes: 10  # Fail entire job after 10 minutes
```

### 4. Collect Logs on Failure

```yaml
    - name: Upload logs on failure
      if: failure()
      uses: actions/upload-artifact@v3
      with:
        name: test-logs
        path: |
          *.log
          test-results/
```

## Troubleshooting

### Tests Pass Locally But Fail in CI

**Common causes:**

- Port conflicts in CI environment
- Timing issues (CI is slower)
- Different Python versions
- Missing dependencies

**Solutions:**

- Use dynamic port allocation
- Add startup delays: `await asyncio.sleep(0.5)`
- Pin Python version in CI config
- Install all dependencies explicitly

### Timeout Issues in CI

**Problem:** Tests timeout in CI but work locally

**Solutions:**

- Increase test timeouts
- Use faster fixture scopes
- Enable parallel testing with pytest-xdist
- Check for deadlocks in async code

### Windows-Specific Issues

**Problem:** Tests fail on Windows runners

**Solution:** Ensure proper async event loop handling:

```python
# conftest.py
import sys
import pytest

if sys.platform == 'win32':
    import asyncio
    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())
```

## Next Steps

- **[Integration Testing](../03-integration/)** - Review pytest patterns
- **[Advanced Examples](../04-advanced-scenarios/)** - Learn error injection for CI tests
- **[Best Practices](../../guide/best-practices/)** - Testing best practices

## See Also

- [GitHub Actions Documentation](https://docs.github.com/actions)
- [GitLab CI Documentation](https://docs.gitlab.com/ee/ci/)
- [pytest-xdist Documentation](https://pytest-xdist.readthedocs.io/)
- [Docker Documentation](https://docs.docker.com/)
# User Guide

# User Guide Overview

Welcome to the LIFX Emulator User Guide. This guide helps you understand the emulator's features and use them effectively.

## Prerequisites

Before reading this guide, you should have:

- Completed the [Getting Started](../getting-started/) section
- Successfully run the emulator at least once
- Basic understanding of LIFX devices (optional but helpful)

## Learning Path

Read these guides in order for the best learning experience:

1. **[Overview](#what-is-lifx-emulator)** (below) - High-level concepts
1. **[Device Types](device-types/)** - What devices you can emulate
1. **[Products and Specs](products-and-specs/)** - Product registry system
1. **[Web Interface](web-interface/)** - Visual monitoring and management
1. **[Integration Testing](integration-testing/)** - Using in test suites
1. **[Testing Scenarios](testing-scenarios/)** - Simulating errors and edge cases
1. **[Best Practices](best-practices/)** - Tips for effective testing

## What is LIFX Emulator?

LIFX Emulator creates virtual LIFX devices that behave like real hardware. It implements the complete LIFX LAN protocol, allowing you to:

### Test Without Hardware

No need to purchase physical devices. Create as many virtual devices as you need for testing.

### Simulate Real-World Conditions

- Normal operations (power, color, brightness)
- Network issues (packet loss, delays)
- Edge cases (malformed packets, invalid data)
- Error conditions (timeouts, unhandled packets)

### Integrate with CI/CD

Run automated tests in continuous integration pipelines without physical device dependencies.

## Common Use Cases

### Testing Your LIFX Library

The emulator allows you to test your LIFX library without physical devices:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def test_my_library():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Test your library here
        pass
```

### CI/CD Integration

Run tests in continuous integration pipelines:

```bash
# Start emulator in background
lifx-emulator --bind 127.0.0.1 --port 56701 &
EMULATOR_PID=$!

# Run tests
pytest tests/

# Clean up
kill $EMULATOR_PID
```

### Protocol Development

Experiment with LIFX protocol features:

```bash
# Start with verbose logging to see all packets
lifx-emulator --verbose
```

## Next Steps

Choose a topic from the list above to dive deeper into specific features.

# Device Types

Complete guide to all supported LIFX device types and their capabilities.

## Overview

The LIFX Emulator supports all major LIFX device types, each with specific capabilities and features.

## Color Lights

Full RGB color lights with complete color control.

### Example Products

- **LIFX A19** (product ID 27) - Standard color bulb
- **LIFX BR30** (product ID 43) - BR30 flood light
- **LIFX Downlight** (product ID 36) - Recessed downlight
- **LIFX GU10** (product ID 66) - GU10 spot light
- **And many more...**

### Capabilities

- Full RGBW color (360¬∞ hue, 0-100% saturation)
- Brightness control (0-100%)
- Color temperature (1500K-9000K)
- Power on/off

### Factory Function

```python
from lifx_emulator import create_color_light

device = create_color_light("d073d5000001")
```

### Example Usage

```python
# Create and start server
device = create_color_light("d073d5000001")
server = EmulatedLifxServer([device], "127.0.0.1", 56700)
await server.start()

# Check state
print(f"Has color: {device.state.has_color}")  # True
print(f"Color: {device.state.color}")
```

## Color Temperature Lights

White lights with variable color temperature (warm to cool white).

### Example Products

- **LIFX Mini White to Warm** (product ID 50)
- **LIFX Downlight White to Warm** (product ID 48)

### Capabilities

- Color temperature adjustment (1500K-9000K)
- Brightness control (0-100%)
- Power on/off
- **No RGB color** (saturation locked to 0)

### Factory Function

```python
from lifx_emulator import create_color_temperature_light

device = create_color_temperature_light("d073d5000007")
```

### Behavior

These devices:

- Always report `has_color=False`
- Reject color commands (SetColor with saturation > 0)
- Accept color temperature changes via kelvin value
- Only vary brightness and temperature

## Infrared Lights

Color lights with additional infrared capability for night vision.

### Example Products

- **LIFX A19 Night Vision** (product ID 29)
- **LIFX BR30 Night Vision** (product ID 44)

### Capabilities

- Full RGBW color
- Brightness control
- Color temperature
- **Infrared brightness** (0-100%)
- Power on/off

### Factory Function

```python
from lifx_emulator import create_infrared_light

device = create_infrared_light("d073d5000002")
```

### Infrared Control

```python
device = create_infrared_light("d073d5000002")

# Check infrared support
print(f"Has IR: {device.state.has_infrared}")  # True

# Default IR brightness (set to 25%)
print(f"IR brightness: {device.state.infrared_brightness}")  # 16384

# After receiving LightSetInfrared command
# device.state.infrared_brightness will be updated
```

### Packet Types

- `LightGetInfrared` (120)
- `LightStateInfrared` (121)
- `LightSetInfrared` (122)

## HEV Lights

Lights with HEV (High Energy Visible) anti-bacterial cleaning capability.

### Example Products

- **LIFX Clean** (product ID 90)

### Capabilities

- Full RGBW color
- Brightness control
- Color temperature
- **HEV cleaning cycle** (anti-bacterial sanitization)
- Cycle duration configuration
- Cycle progress tracking
- Power on/off

### Factory Function

```python
from lifx_emulator import create_hev_light

device = create_hev_light("d073d5000003")
```

### HEV State

```python
device = create_hev_light("d073d5000003")

# HEV defaults
print(f"Has HEV: {device.state.has_hev}")  # True
print(f"Cycle duration: {device.state.hev_cycle_duration_s}")  # 7200 (2 hours)
print(f"Remaining: {device.state.hev_cycle_remaining_s}")  # 0 (not running)
print(f"Indication: {device.state.hev_indication}")  # True
```

### HEV Packet Types

- `HevGet` (143)
- `HevStateResult` (144)
- `HevGetResult` (145)
- `HevStateResult` (146)
- `HevSetConfig` (147)
- `HevGetConfig` (148)
- `HevStateConfig` (149)

## Multizone Devices

Linear light strips with independently controllable zones.

### Example Products

- **LIFX Z** (product ID 32) - Default 16 zones (8 zones/strip)
- **LIFX Beam** (product ID 38) - Default 80 zones (10 zones/beam)
- **LIFX Neon** (product ID 141) - Default 24 zones (24 zones/segment)
- **LIFX String** (product ID 143) - Default 36 zones (36 zones/string)
- **LIFX Permanent Outdoor** (product ID 213) - Default 30 zones (15 zones/segment)

### Capabilities

- Full RGBW color per zone
- Per-zone brightness and color
- Multizone effect (MOVE)
- Power on/off

### Factory Function

```python
from lifx_emulator import create_multizone_light

# Standard LIFX Z with default 16 zones
strip = create_multizone_light("d073d8000001")

# Custom zone count
strip = create_multizone_light("d073d8000002", zone_count=24)

# Extended multizone (LIFX Beam) with default 80 zones
beam = create_multizone_light("d073d8000003", extended_multizone=True)

# Extended with custom zone count
beam = create_multizone_light("d073d8000004", zone_count=60, extended_multizone=True)
```

### Zone Management

```python
strip = create_multizone_light("d073d8000001", zone_count=16)

# Check configuration
print(f"Has multizone: {device.state.has_multizone}")  # True
print(f"Zone count: {device.state.zone_count}")  # 16
print(f"Product: {device.state.product}")  # 32 (LIFX Z)

# Access zone colors
for i, color in enumerate(device.state.zone_colors):
    print(f"Zone {i}: {color}")
```

### Multizone Packet Types

**Standard (all multizone devices):**

- `SetColorZones` (501)
- `GetColorZones` (502)
- `StateZone` (503)
- `StateMultiZone` (506)

**Extended (extended multizone only):**

- `SetExtendedColorZones` (510)
- `GetExtendedColorZones` (511)
- `StateExtendedColorZones` (512)

**Effects:**

- `SetMultiZoneEffect` (509)
- `GetMultiZoneEffect` (507)
- `StateMultiZoneEffect` (508)

## Matrix Devices

Devices with a 2D matrix of individually controlled zones.

### Example Products

- **LIFX Tile** (product ID 55) - 8x8 tile with up to 5 tiles per chain (discontinued)
- **LIFX Candle** (product ID 57, 68, 137, 138, 185, 186, 215, 216) - 6x5 tile
- **LIFX Ceiling** (product ID 176) - 8x8 with uplight/downlight zones
- **LIFX Ceiling 13x26"** (product ID 201, 202) - 16x8 with uplight/downlight zones
- **LIFX Tube** (product ID 177, 217, 218) - 5x11
- **LIFX Luna** (product ID 219, 220) - 7x5
- **LIFX Round Spot** (product ID 171, 221) - 3x1
- **LIFX Round/Square Path** (product ID 173, 174, 222) - 3x2

### Capabilities

- 2D matrix of individually controlled full color zones
- Multiple tiles in a chain (original Tile only)
- Tile positioning in 2D space (original Tile only)
- Matrix effects (Morph, Flame, Sky)
- Power on/off

### Factory Functions

```python
from lifx_emulator import create_tile_device

# Standard LIFX Tile (8x8) with default 5 tiles
tiles = create_tile_device("d073d9000001")

# Custom tile count
tiles = create_tile_device("d073d9000002", tile_count=10)

# Custom tile dimensions (e.g., 16x8 with >64 zones)
large_tile = create_tile_device("d073dc000001", tile_count=1, tile_width=16, tile_height=8)

# Any custom size
custom = create_tile_device("d073dc000002", tile_count=3, tile_width=12, tile_height=12)
```

### Matrix Configuration

```python
tiles = create_tile_device("d073d9000001", tile_count=5)

# Check configuration
print(f"Has matrix: {device.state.has_matrix}")  # True
print(f"Tile count: {device.state.tile_count}")  # 5
print(f"Tile width: {device.state.tile_width}")  # 8
print(f"Tile height: {device.state.tile_height}")  # 8

# Access tile devices
for i, tile in enumerate(device.state.tile_devices):
    print(f"Tile {i}: {tile.width}x{tile.height} pixels")
```

### Matrix Packet Types

- `GetDeviceChain` (701)
- `StateDeviceChain` (702)
- `SetUserPosition` (703)
- `GetTileState64` (707)
- `StateTileState64` (711)
- `SetTileState64` (715)
- `GetTileEffect` (718)
- `StateTileEffect` (719)

### Zone Access

Matrix devices usually have up to 64 zones per tile with a single tile per chain.

Exceptions include the LIFX Tile that supports up to 5 tiles per chain and the new LIFX Ceiling 26"x13" which has 128 zones on a single tile.

```python
# Get64 requests specify a rectangle of zones
# x, y, width specify which zones to retrieve
# State64 responses contain up to 64 zones

# Large tiles (16x8) require multiple Get64 requests
# split either by row or column.
```

## Using Generic create_device()

All factory functions use `create_device()` internally. You can use it directly:

```python
from lifx_emulator.factories import create_device

# Create by product ID
a19 = create_device(27, serial="d073d5000001")
z_strip = create_device(32, serial="d073d8000001", zone_count=16)
tiles = create_device(55, serial="d073d9000001", tile_count=5)
candle = create_device(57, serial="d073d9000002")

# Product defaults are automatically loaded
print(f"Candle size: {candle.state.tile_width}x{candle.state.tile_height}")  # 5x6
```

## Next Steps

- [Testing Scenarios](../testing-scenarios/) - Configure error scenarios
- [Integration Testing](../integration-testing/) - Use in tests
- [Factory Functions API](../../api/factories/) - Detailed API docs
- [Product Registry](../../api/products/) - All products

# LIFX Product Registry and Specifications

This directory contains the product registry and specification library for the LIFX emulator.

## Files

### `registry.py` (Auto-generated)

**DO NOT EDIT MANUALLY**

Generated from the official LIFX products.json catalog. Contains:

- Product IDs and names
- Vendor IDs
- Capabilities (color, multizone, matrix, infrared, HEV, etc.)
- Temperature ranges
- Extended multizone firmware versions

To regenerate:

```bash
python -m lifx_emulator.products.generator
```

### `specs.yml` (Manual configuration)

**EDIT THIS FILE**

Contains product-specific details not available in the upstream catalog:

- Default zone counts for multizone devices
- Min/max zone counts
- Default tile counts for matrix devices
- Min/max tile counts
- Tile dimensions (width x height in pixels)
- Product-specific notes

### `specs.py`

Python module for loading and accessing specification data.

### `generator.py`

Script to download and generate `registry.py` from the official LIFX products.json.

## Customizing Specifications

When the product generator creates specifications, you can edit them in `specs.yml` to customize defaults or add product-specific notes.

#### For Multizone Devices (Strips, Beams, Neon)

```yaml
products:
  <product_id>:
    default_zone_count: <number>    # Typical zone count
    min_zone_count: <number>        # Minimum zones supported
    max_zone_count: <number>        # Maximum zones supported
    notes: "<description>"
```

**Example - LIFX Z Strip:**

```yaml
products:
  32:
    default_zone_count: 16
    min_zone_count: 1
    max_zone_count: 16
    notes: "LIFX Z with extended multizone firmware support"
```

**Example - LIFX Beam:**

```yaml
products:
  38:
    default_zone_count: 80
    min_zone_count: 10
    max_zone_count: 82
    notes: "LIFX Beam, 8 individual beams, each with 10 zones and up to 2 corners"
```

#### For Matrix Devices (Tiles, Candles, Ceiling)

```yaml
products:
  <product_id>:
    default_tile_count: <number>    # Typical number of tiles in chain
    min_tile_count: <number>        # Minimum tiles supported
    max_tile_count: <number>        # Maximum tiles supported
    tile_width: <pixels>            # Width of each tile
    tile_height: <pixels>           # Height of each tile
    notes: "<description>"
```

**Example - LIFX Tile:**

```yaml
products:
  55:
    default_tile_count: 5
    min_tile_count: 1
    max_tile_count: 5
    tile_width: 8
    tile_height: 8
    notes: "LIFX Tile, 8x8 pixel matrix, chainable up to 5"
```

**Example - LIFX Candle:**

```yaml
products:
  57:
    default_tile_count: 1
    min_tile_count: 1
    max_tile_count: 1
    tile_width: 5
    tile_height: 6
    notes: "LIFX Candle, 5x6 pixel matrix, single unit"
```

**Example - LIFX Ceiling:**

```yaml
products:
  176:
    default_tile_count: 1
    min_tile_count: 1
    max_tile_count: 1
    tile_width: 22
    tile_height: 22
    notes: "LIFX Ceiling, 22x22 pixel matrix"
```

## How Specifications Are Used

### Multizone Devices

When creating a multizone device without specifying `zone_count`:

1. Check `specs.yml` for `default_zone_count`
1. If not found, use registry capability defaults:
1. Extended multizone: 82 zones
1. Standard multizone: 16 zones

```python
# Uses specification default (80 zones for Beam)
device = create_device(38)

# Override with custom count
device = create_device(38, zone_count=40)
```

### Matrix Devices

When creating a matrix device:

1. **Tile dimensions**: Always from `specs.yml` (required for accuracy)
1. **Tile count**: From `specs.yml` if not specified by user

```python
# Uses specification: 5 tiles of 8x8 pixels
device = create_device(55)

# Custom tile count, specification dimensions
device = create_device(55, tile_count=3)  # 3 tiles of 8x8 pixels

# Candle: 1 tile of 5x5 pixels (from specification)
device = create_device(57)

# Ceiling: 1 tile of 22x22 pixels (from specification)
device = create_device(176)
```

## Current Specification Coverage

All multizone and matrix devices currently available have specifications defined:

- **Multizone**: 19 products (Z, Beam, Neon, String, Outdoor Neon, Indoor Neon, Permanent Outdoor - with US and international variants)
- **Matrix**: 22 products (Tile, Candle, Ceiling, Round Spot, Round Path, Square Path, Tube, Luna - with US and international variants)
- **Total**: 41 products with specifications defined

See `specs.yml` for the complete list.

## Maintenance

### When to Update Specifications

1. **New LIFX products released**: The generator automatically creates a specification - edit `specs.yml` to customize defaults or add product-specific notes
1. **Product specifications change**: Update specification values in `specs.yml`
1. **Better information available**: Refine default values
1. **User reports incorrect defaults**: Verify and update in `specs.yml`

### Regenerating Registry

When LIFX releases new products or updates the catalog:

```bash
# Download latest products.json and regenerate registry.py
python -m lifx_emulator.products.generator

# Specifications are auto-generated; edit specs.yml to customize if needed
# Test with: lifx-emulator --product <new_pid>
```

## API Reference

### Python API

```python
from lifx_emulator.products.specs import (
    get_specs,
    get_default_zone_count,
    get_default_tile_count,
    get_tile_dimensions,
)

# Get all specification for a product
specification = get_specs(55)  # LIFX Tile
if specification:
    print(f"Default tiles: {specification.default_tile_count}")
    print(f"Tile size: {specification.tile_width}x{specification.tile_height}")

# Get specific values
zones = get_default_zone_count(32)  # 16 for LIFX Z
tiles = get_default_tile_count(55)  # 5 for LIFX Tile
width, height = get_tile_dimensions(176)  # (22, 22) for LIFX Ceiling
```

## Contributing

When you discover more accurate specification information:

1. Edit or refine the specification in `specs.yml`
1. Test with `python -m lifx_emulator --product <product ID>`
1. Include source/reference in the `notes` field
1. Submit your refinement either as pull request or open an issue.

For questions or help, check the main project README.

# Web Interface Guide

## Overview

The LIFX Emulator includes a built-in web interface for real-time monitoring and device management. The dashboard provides a browser-based alternative to the REST API, with live updates of server statistics, device status, and packet activity.

**Access**: Open `http://localhost:8080` in your web browser (after starting the emulator with `--api`)

## Getting Started

### Enable the Web Interface

```bash
# Start emulator with API (enables web interface)
lifx-emulator --api

# Custom host and port
lifx-emulator --api --api-host 127.0.0.1 --api-port 9090

# Then open in browser:
# http://localhost:8080
# or http://127.0.0.1:9090
```

## Interface Layout

The web interface is organized into three main sections:

### 1. Server Statistics Card (Top Left)

Displays real-time emulator health metrics:

```text
Server Statistics
‚îú‚îÄ Uptime: 123s
‚îú‚îÄ Devices: 3
‚îú‚îÄ Packets RX: 1250
‚îú‚îÄ Packets TX: 2100
‚îî‚îÄ Errors: 0
```

**Metrics:**

- **Uptime**: Time since server started (auto-updating)
- **Devices**: Number of currently emulated devices
- **Packets RX**: Total packets received from LIFX clients
- **Packets TX**: Total packets sent to LIFX clients
- **Errors**: Total packet processing errors

**Use Cases:**

- Verify API server is running
- Monitor packet flow during testing
- Check for errors during protocol testing

______________________________________________________________________

### 2. Add Device Card (Top Right)

Creates new devices on the fly:

```text
Add Device
‚îú‚îÄ Product ID: [dropdown menu]
‚îî‚îÄ [Add Device button]
```

**Features:**

- Dropdown list of common products:
- 27 - LIFX A19 (color light)
- 29 - LIFX A19 Night Vision
- 32 - LIFX Z (multizone strip)
- 38 - LIFX Beam (extended multizone)
- 50 - LIFX Mini White to Warm
- 55 - LIFX Tile (matrix device)
- 90 - LIFX Clean (HEV)
- Serial numbers are auto-generated

**Use Cases:**

- Quick device creation for testing
- Create multiple device types without CLI
- Test with different device configurations

______________________________________________________________________

### 3. Devices Section

Displays all emulated devices with detailed status:

```text
Devices (3)                    [Remove All]  [Clear Storage]

‚îå‚îÄ Device Card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ d073d5000001                                    [Del]  ‚îÇ
‚îÇ Living Room Light                                      ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ [ON]  [P27]  [color]  [multizone√ó16]  [HEV]         ‚îÇ
‚îÇ                                                        ‚îÇ
‚îÇ ‚ñ∏ Show metadata  (click to expand)                    ‚îÇ
‚îÇ ‚ñ∏ Show zones (16)  (click to expand)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

#### Device Card Components

**Header:**

- Device serial number (clickable, displays copy tooltip)
- Device label (e.g., "Living Room Light")
- Delete button (red, with confirmation)

**Status Badges:**

- Power status: `[ON]` (green) or `[OFF]` (gray)
- Product ID: `[P27]` (light blue)
- Capabilities: `[color]`, `[multizone√ó16]`, `[HEV]`, etc.
- Extended multizone: `[extended-mz√ó80]` (green)

**Expandable Metadata** (click "‚ñ∏ Show metadata"):

```text
Firmware: 3.70
Vendor: 1
Product: 27
Capabilities: Color, Multizone (16 zones)
Group: (empty)
Location: (empty)
Uptime: 123s
WiFi Signal: -45.5 dBm
```

**Color/Zone Display:**

For color lights:

```text
‚ñ∏ Show zones
  ‚ñ† Current color
```

For multizone devices:

```text
‚ñ∏ Show zones (16)  (click to expand)
  [colored strips representing each zone]
```

For matrix/tile devices:

```text
‚ñ∏ Show tiles (5)  (click to expand)
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ T1       ‚îÇ  (8√ó8 pixel grid)
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îÇ ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  (repeats for each tile)
```

**Zone Display:**

- Each zone shown as a colored segment
- Colors represent current HSBK values
- Heights approximately proportional to brightness
- Saturation affects color intensity
- Hue determines the color

______________________________________________________________________

### 4. Recent Activity Log (Bottom)

Displays the last 100 LIFX protocol packets in real-time:

```text
Recent Activity

12:34:56  RX  GetColor           d073d5000001  192.168.1.100:54321
12:34:56  TX  State              d073d5000001  192.168.1.100:54321
12:34:57  RX  GetPower           d073d5000002  192.168.1.101:54322
12:34:57  TX  StatePower         d073d5000002  192.168.1.101:54322
```

**Activity Event Fields:**

- **Time**: HH:MM:SS (local time)
- **Direction**:
- `RX` (blue) - Received from client
- `TX` (orange) - Transmitted to client
- **Packet Name**: Human-readable LIFX packet type (e.g., "GetColor", "SetColor")
- **Device**: Target device serial number
- **Address**: Client IP address and port

**Use Cases:**

- Debugging LIFX client communication
- Verifying packet flow
- Monitoring protocol interactions
- Identifying communication problems

**Note:** Activity log is only visible if activity logging is enabled (`--api-activity` flag, default: true). Disable to reduce server traffic.

______________________________________________________________________

## Common Tasks

### Add a New Device

1. Open the web interface: `http://localhost:8080`
1. Find the "Add Device" card (top right)
1. Select a product from the dropdown menu
1. Click "Add Device" button
1. New device appears in the Devices section with auto-generated serial

The device is immediately available to LIFX clients and is added to the emulator runtime (not persisted to disk unless `--persistent` flag is used).

______________________________________________________________________

### Check Device Status

1. Locate device in the Devices section
1. Check power badge (`[ON]` or `[OFF]`)
1. Check capability badges (color, multizone, matrix, HEV, etc.)
1. Click "‚ñ∏ Show metadata" to view:
1. Firmware version
1. Product ID and vendor
1. Assigned group and location
1. Device uptime
1. WiFi signal strength

______________________________________________________________________

### View Multizone Colors

For multizone devices (strips, beams):

1. Locate device in Devices section
1. Click "‚ñ∏ Show zones" to expand
1. Colored bar displays all zone colors
1. Each segment represents one zone
1. Color indicates current HSBK values
1. Click again to collapse

**Color Interpretation:**

- Hue (0-360¬∞): Color wheel position
- Saturation (0-100%): Color intensity (white to saturated)
- Brightness (0-100%): Light intensity
- Kelvin (1500-9000K): Color temperature

______________________________________________________________________

### View Tile/Matrix Colors

For matrix devices (tiles, candles, ceiling):

1. Locate device in Devices section
1. Click "‚ñ∏ Show tiles" to expand
1. Grid display shows pixel colors
1. Each small square is one pixel
1. Tiles labeled T1, T2, etc.
1. Click again to collapse

______________________________________________________________________

### Monitor Packet Activity

1. Scroll to "Recent Activity" section (bottom)
1. Watch for real-time packet updates
1. Filter mentally by:
1. **Direction**: RX (requests) vs TX (responses)
1. **Packet type**: GetColor, SetColor, StatePower, etc.
1. **Device**: Compare multiple devices
1. **Client address**: Identify different clients

**Common Packet Patterns:**

```text
RX GetService (broadcast)     <- Client discovering devices
TX StateService (response)    <- Device responds

RX GetColor                   <- Client querying color
TX State (color response)     <- Device responds

RX SetColor + params          <- Client setting new color
TX Acknowledgment             <- Device confirms

RX GetPower                   <- Client querying power
TX StatePower                 <- Device responds
```

______________________________________________________________________

### Remove a Device

**Remove Single Device:**

1. Locate device in Devices section
1. Click red "Del" button on device card
1. Confirm deletion in prompt
1. Device disappears from list
1. Device stops responding to LIFX protocol packets

**Remove All Devices:**

1. Click "Remove All" button (top right of Devices section)
1. Confirmation dialog shows: "Remove all X device(s)?"
1. Click OK to confirm
1. All devices removed from runtime (storage preserved)

______________________________________________________________________

### Clear Persistent Storage

If `--persistent` flag was used to enable state persistence:

1. Click "Clear Storage" button (top right of Devices section)
1. Confirmation dialog shows: "Clear all persistent device state?"
1. Click OK to confirm
1. All saved device state files deleted from disk
1. Currently running devices NOT affected
1. Next restart will start with no saved state

______________________________________________________________________

## Features and Capabilities

### Real-Time Updates

- Dashboard auto-refreshes every 2 seconds
- Server statistics updated in real-time
- Device list and status refreshed
- Activity log scrolls with new packets
- No manual refresh button needed

### Persistent UI State

The interface remembers your preferences:

- Zone/tile display states (expanded/collapsed) per device
- Metadata display states (expanded/collapsed) per device
- Preferences stored in browser localStorage
- Persists across page reloads
- Per-device basis (no global toggle)

### Color Display

Colors are displayed accurately:

- HSBK to RGB conversion for display
- Hue: Color wheel position
- Saturation: Intensity/purity
- Brightness: Light level
- Kelvin: Color temperature (white point)

### Responsive Design

- Adapts to different screen sizes
- Device cards responsive grid layout
- Touch-friendly on tablets
- Dark theme optimized for monitoring

______________________________________________________________________

## Performance Considerations

### Activity Logging Impact

Activity logging has performance implications:

```bash
# Disable activity logging (reduces traffic)
lifx-emulator --api --api-activity=false

# Activity endpoint returns 503 Service Unavailable when disabled
curl http://localhost:8080/api/activity
# Response: 503 Service Unavailable
```

### Optimal Configuration for Monitoring

```bash
# Balance between visibility and performance
lifx-emulator --api \
  --api-host 127.0.0.1 \  # Limit to localhost if not needed on network
  --api-port 8080
```

### Browser Performance

For emulators with many devices (50+):

- Activity log auto-update may slow down browser
- Consider disabling activity logging (`--api-activity=false`)
- Refresh page if UI becomes sluggish
- Use REST API directly for automated monitoring

______________________________________________________________________

## Troubleshooting

### Web Interface Not Loading

```bash
# Check if API server is running
curl http://localhost:8080/api/stats

# Check if port is correct
# Default: http://localhost:8080
# Custom: http://localhost:9090  (if --api-port 9090)
```

### Activity Log Not Updating

- Ensure `--api-activity` is not disabled (default: enabled)
- Check browser developer console for errors
- Try refreshing page

### Devices Not Appearing

```bash
# Verify devices exist via API
curl http://localhost:8080/api/devices | jq

# Check emulator logs for creation errors
# Device should appear in response
```

### Zones Not Displaying

For multizone devices:

- Click "‚ñ∏ Show zones" to expand display
- Ensure device has `has_multizone: true`
- Check that zone_count > 0 and zone_colors array is populated

For tile/matrix devices:

- Click "‚ñ∏ Show tiles" to expand display
- Ensure device has `has_matrix: true`
- Check that tile_count > 0 and colors are populated

______________________________________________________________________

## Browser Compatibility

**Tested and Supported:**

- Chrome/Chromium 90+
- Firefox 88+
- Safari 14+
- Edge 90+

**Required:**

- JavaScript enabled
- LocalStorage for UI state persistence
- CSS Grid support

______________________________________________________________________

## Security Considerations

The web interface provides no authentication or authorization:

- Intended for local development/testing only
- No user login required
- All operations available to anyone with network access
- Consider firewall rules if on shared network
- Use `--api-host 127.0.0.1` for localhost-only access

______________________________________________________________________

## Advanced Features

### Serial Number Details

Each device has a unique 12-character hexadecimal serial:

- Default prefix: `d073d5`
- Default range: `d073d5000001` - `d073d5999999`
- Can be customized with `--serial-prefix` and `--serial-start` CLI flags

### Product IDs

Common products:

- 27: LIFX A19 (color light)
- 29: LIFX A19 Night Vision (infrared)
- 32: LIFX Z (multizone strip)
- 38: LIFX Beam (extended multizone)
- 50: LIFX Mini White to Warm (color temperature)
- 55: LIFX Tile (matrix/tile device)
- 90: LIFX Clean (HEV)

See `lifx-emulator list-products` for complete list.

______________________________________________________________________

## Related Documentation

- [Device Management API](../../advanced/device-management-api/) - Programmatic API access
- [Scenario Management API](../../advanced/scenario-api/) - Test scenario configuration

# Testing Scenarios

The LIFX Emulator provides a powerful scenarios system that allows you to simulate various error conditions, network issues, and edge cases. This guide covers all available testing scenarios and how to use them effectively.

## Overview

Testing scenarios are configured via the `scenarios` dictionary on an `EmulatedLifxDevice`. Each scenario modifies how the device responds to protocol packets, allowing you to test your client's resilience and error handling.

```python
from lifx_emulator import create_color_light

device = create_color_light("d073d5000001")

# Configure scenarios
device.scenarios = {
    'drop_packets': [101],  # Drop GetColor requests
    'response_delays': {102: 0.5},  # Delay SetColor by 500ms
    'malformed_packets': [107],  # Corrupt StateColor responses
}
```

## Available Scenarios

### 1. Packet Dropping (`drop_packets`)

Silently ignore specific packet types to simulate network packet loss or device unresponsiveness. Supports both deterministic dropping (always drop) and probabilistic dropping (drop X% of packets).

**Configuration:** Dictionary mapping packet type to drop rate (0.1-1.0)

- `1.0` = always drop (100%)
- `0.5` = drop 50% of packets
- `0.1` = drop 10% of packets

**Use Cases:**

- Test client retry logic
- Simulate network packet loss
- Test timeout handling
- Verify client doesn't hang on no response
- Test resilience to intermittent failures

**Example - Always Drop:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Always drop GetColor (101) and GetPower (20) requests
    device.scenarios = {
        'drop_packets': {101: 1.0, 20: 1.0}
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will drop 100% of GetColor and GetPower packets")
        print("Clients should timeout and implement retry logic")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Example - Probabilistic Drop:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Drop packets probabilistically (simulating flaky network)
    device.scenarios = {
        'drop_packets': {
            101: 0.3,   # Drop 30% of GetColor requests
            102: 0.2,   # Drop 20% of SetColor requests
            20: 0.4,    # Drop 40% of GetLabel requests
        }
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will drop packets probabilistically")
        print("Simulating an unreliable network connection")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Common Packet Types to Drop:**

- `20` - GetLabel
- `101` - GetColor (Light.GetColor)
- `116` - GetPower (Light.GetPower)
- `502` - GetColorZones (MultiZone.GetColorZones)
- `707` - Get64 (Tile.Get64)

**Drop Rate Recommendations:**

- **Testing retry logic:** 1.0 (always drop)
- **Simulating flaky WiFi:** 0.1-0.3 (10-30% drop rate)
- **Simulating congestion:** 0.2-0.4 (20-40% drop rate)
- **Simulating very poor connection:** 0.5-0.8 (50-80% drop rate)

**Testing Checklist:**

- [ ] Client implements retry logic
- [ ] Client has appropriate timeouts
- [ ] Client doesn't hang indefinitely
- [ ] User gets feedback about timeout
- [ ] Exponential backoff is implemented (if applicable)
- [ ] Client recovers after transient failures (for probabilistic drops)

### 2. Response Delays (`response_delays`)

Add artificial delays to specific packet responses to simulate slow devices or network latency.

**Configuration:** Dictionary mapping packet type to delay in seconds

**Use Cases:**

- Test timeout configuration
- Simulate slow network conditions
- Test concurrent request handling
- Verify UI doesn't freeze during slow responses

**Example:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Add various delays
    device.scenarios = {
        'response_delays': {
            101: 0.5,   # GetColor: 500ms delay
            102: 1.0,   # SetColor: 1 second delay
            20: 0.2,    # GetLabel: 200ms delay
            117: 2.0,   # SetPower: 2 second delay (very slow)
        }
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device configured with response delays")
        print("Test your client's async handling and timeouts")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Realistic Delay Values:**

- **Fast local network:** 0.01 - 0.05 seconds (10-50ms)
- **Normal local network:** 0.05 - 0.2 seconds (50-200ms)
- **Slow/congested network:** 0.5 - 2.0 seconds
- **Very slow/problematic:** 2.0+ seconds

**Testing Checklist:**

- [ ] UI remains responsive during slow operations
- [ ] Progress indicators show during slow requests
- [ ] Timeout values are appropriate for expected delays
- [ ] Multiple slow requests don't block each other
- [ ] Cancel operations work correctly

### 3. Malformed Packets (`malformed_packets`)

Send truncated or corrupted packet responses to test client parsing robustness.

**Configuration:** List of packet types to corrupt

**Use Cases:**

- Test packet parsing error handling
- Verify client doesn't crash on bad data
- Test protocol implementation resilience
- Ensure graceful degradation

**Example:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Corrupt StateColor and StateLabel responses
    device.scenarios = {
        'malformed_packets': [107, 25]  # StateColor, StateLabel
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will send malformed StateColor and StateLabel packets")
        print("Your client should handle parsing errors gracefully")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Implementation Details:**

- Packets are truncated to 50% of their normal size
- Binary data may be corrupted or incomplete
- Header is still valid (so packet is delivered)

**Testing Checklist:**

- [ ] Client doesn't crash on malformed packets
- [ ] Parsing errors are caught and logged
- [ ] User sees error message (not crash)
- [ ] Client can recover after parsing error
- [ ] Invalid data is rejected, not used

### 4. Invalid Field Values (`invalid_field_values`)

Send packets with all fields set to invalid values (0xFF bytes).

**Configuration:** List of packet types to send with invalid data

**Use Cases:**

- Test field validation
- Verify bounds checking
- Test handling of out-of-range values
- Ensure client validates data

**Example:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Send StateColor with invalid field values
    device.scenarios = {
        'invalid_field_values': [107]  # StateColor
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will send StateColor with all 0xFF bytes")
        print("Hue, saturation, brightness, kelvin all invalid")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**What Gets Invalidated:**

- All numeric fields set to 0xFFFF or 0xFFFFFFFF
- Strings filled with invalid characters
- Enums set to undefined values

**Testing Checklist:**

- [ ] Client validates field ranges
- [ ] Out-of-range values are rejected
- [ ] Invalid enums are handled
- [ ] Client uses safe defaults on invalid data
- [ ] Errors are reported to user

### 5. Partial Responses (`partial_responses`)

Send incomplete packet payloads to test client's handling of truncated data.

**Configuration:** List of packet types to truncate

**Use Cases:**

- Test buffer handling
- Verify client doesn't read past buffer
- Test partial data handling
- Simulate network truncation

**Example:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Send partial StateColor responses
    device.scenarios = {
        'partial_responses': [107]  # StateColor
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Device will send truncated StateColor packets")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Testing Checklist:**

- [ ] Client detects truncated packets
- [ ] No buffer overruns occur
- [ ] Partial data is rejected
- [ ] Client doesn't crash on short reads
- [ ] Error is logged appropriately

### 6. Custom Firmware Version (`firmware_version`)

Override the reported firmware version to test version compatibility.

**Configuration:** Tuple of (major, minor) version numbers

**Use Cases:**

- Test version detection
- Verify feature compatibility checks
- Test upgrade/downgrade scenarios
- Ensure graceful handling of unknown versions

**Example:**

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Pretend to be an older firmware version
    device.scenarios = {
        'firmware_version': (2, 50)  # Version 2.50 (old)
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print(f"Device reports firmware version: 2.50")
        print("Test your client's version compatibility logic")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

**Common Versions to Test:**

- `(2, 0)` - Very old firmware
- `(3, 50)` - Mid-range firmware
- `(3, 70)` - Current typical version
- `(99, 99)` - Future/unknown version

## Combining Multiple Scenarios

You can combine multiple scenarios to create complex test conditions:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    device = create_color_light("d073d5000001")

    # Realistic "problem device" scenario
    device.scenarios = {
        'drop_packets': {101: 0.4},  # Drops 40% of GetColor requests
        'response_delays': {
            102: 0.8,  # Color changes are slow
            20: 0.3,   # Label queries are slow
        },
        'malformed_packets': [25],  # StateLabel occasionally corrupted
        'firmware_version': (2, 77),  # Older firmware
    }

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print("Simulating a problematic device:")
        print("  - Drops 40% of GetColor requests")
        print("  - Slow to respond to commands")
        print("  - Occasionally sends corrupted labels")
        print("  - Reports older firmware")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Real-World Test Scenarios

### Scenario 1: Flaky WiFi Connection

Simulate a device on an unreliable network:

```python
device.scenarios = {
    'drop_packets': {
        101: 0.3,  # Drop 30% of GetColor requests
        20: 0.3,   # Drop 30% of GetLabel requests
        116: 0.2,  # Drop 20% of GetPower requests
    },
    'response_delays': {
        102: 1.5,  # Very slow commands
        117: 2.0,  # Very slow power changes
    },
}
```

**What to Test:**

- Does your client retry appropriately?
- Are users informed about connectivity issues?
- Does the UI remain responsive?
- Does the client recover after transient failures?

### Scenario 2: Firmware Bugs

Simulate a device with firmware issues:

```python
device.scenarios = {
    'malformed_packets': [107],  # Corrupted color state
    'invalid_field_values': [25],  # Invalid label data
    'firmware_version': (2, 50),  # Old firmware with known bugs
}
```

**What to Test:**

- Does your client validate responses?
- Are parsing errors handled gracefully?
- Is the user informed about potential device issues?

### Scenario 3: Overloaded Device

Simulate a busy device with limited resources:

```python
device.scenarios = {
    'response_delays': {
        101: 0.5,
        102: 1.0,
        20: 0.4,
        117: 1.2,
        116: 0.6,
    },
}
```

**What to Test:**

- Can your client handle slow devices?
- Do multiple concurrent requests work?
- Is there a loading indicator for slow operations?

### Scenario 4: Edge Case Testing

Test unusual but valid conditions:

```python
device.scenarios = {
    'firmware_version': (0, 1),  # Very old firmware
    'response_delays': {102: 5.0},  # Extremely slow (but valid)
}
```

**What to Test:**

- Minimum firmware version support
- Maximum timeout handling
- Version compatibility warnings

## Per-Device Scenarios

Apply different scenarios to different devices in a multi-device setup:

```python
import asyncio
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
)

async def main():
    # Device 1: Perfect device (no scenarios)
    device1 = create_color_light("d073d5000001")
    device1.state.label = "Perfect Light"

    # Device 2: Slow device
    device2 = create_color_light("d073d5000002")
    device2.state.label = "Slow Light"
    device2.scenarios = {
        'response_delays': {102: 1.0, 117: 1.5}
    }

    # Device 3: Unreliable device (drops some packets)
    device3 = create_multizone_light("d073d8000001", zone_count=16)
    device3.state.label = "Flaky Strip"
    device3.scenarios = {
        'drop_packets': {502: 0.4},  # Drop 40% of GetColorZones
        'response_delays': {503: 0.8},  # Slow SetColorZones
    }

    server = EmulatedLifxServer([device1, device2, device3], "127.0.0.1", 56700)

    async with server:
        print("Testing with mixed device reliability:")
        print(f"  {device1.state.label}: Normal")
        print(f"  {device2.state.label}: Slow")
        print(f"  {device3.state.label}: Unreliable (drops 40% of color zone queries)")
        await asyncio.sleep(60)

if __name__ == "__main__":
    asyncio.run(main())
```

## Debugging Scenario Issues

### Enable Verbose Logging

When scenarios aren't behaving as expected:

```python
import logging

# Enable debug logging
logging.basicConfig(level=logging.DEBUG)

# Your test code here
```

### Verify Packet Types

Make sure you're using the correct packet type numbers:

```python
from lifx_emulator.protocol.packets import Device, Light, MultiZone, Tile

# Common packet types
print(f"GetColor: {Light.GetColor.PKT_TYPE}")  # 101
print(f"SetColor: {Light.SetColor.PKT_TYPE}")  # 102
print(f"StateColor: {Light.StateColor.PKT_TYPE}")  # 107
print(f"GetPower: {Light.GetPower.PKT_TYPE}")  # 116
```

### Test Scenarios Independently

Test one scenario at a time to isolate issues:

```python
# Test drop_packets alone (always drop)
device.scenarios = {'drop_packets': {101: 1.0}}

# Then test response_delays alone
device.scenarios = {'response_delays': {102: 0.5}}

# Then combine them
device.scenarios = {
    'drop_packets': {101: 0.5},  # Drop 50% probabilistically
    'response_delays': {102: 0.5},
}
```

## Common Packet Types Reference

| Type | Name               | Description               |
| ---- | ------------------ | ------------------------- |
| 2    | GetService         | Device discovery          |
| 12   | GetHostInfo        | Get host firmware info    |
| 14   | GetHostFirmware    | Get host firmware version |
| 16   | GetWifiInfo        | Get WiFi info             |
| 18   | GetWifiFirmware    | Get WiFi firmware         |
| 20   | GetLabel           | Get device label          |
| 23   | SetLabel           | Set device label          |
| 32   | GetLocation        | Get location              |
| 35   | SetLocation        | Set location              |
| 48   | GetGroup           | Get group                 |
| 51   | SetGroup           | Set group                 |
| 101  | GetColor           | Get light color           |
| 102  | SetColor           | Set light color           |
| 116  | GetLightPower      | Get light power           |
| 117  | SetLightPower      | Set light power           |
| 502  | GetColorZones      | Get multizone colors      |
| 503  | SetColorZones      | Set multizone colors      |
| 510  | GetMultiZoneEffect | Get multizone effect      |
| 511  | SetMultiZoneEffect | Set multizone effect      |
| 701  | GetDeviceChain     | Get tile chain            |
| 707  | Get64              | Get tile 64 zones         |
| 715  | Set64              | Set tile 64 zones         |

## Best Practices

### 1. Start Simple

Begin with one scenario type, verify it works, then add more:

```python
# Step 1: Test drops (always drop)
device.scenarios = {'drop_packets': {101: 1.0}}

# Step 2: Test probabilistic drops
device.scenarios = {'drop_packets': {101: 0.5}}

# Step 3: Add delays
device.scenarios = {
    'drop_packets': {101: 0.5},
    'response_delays': {102: 0.5},
}

# Step 4: Add more complexity
device.scenarios = {
    'drop_packets': {101: 0.5},
    'response_delays': {102: 0.5},
    'malformed_packets': [107],
}
```

### 2. Use Realistic Values

Choose delay values that represent real-world conditions:

- Don't use 10-second delays (unrealistic)
- Do use 0.5-2 second delays (realistic for slow networks)

### 3. Test Error Recovery

Scenarios should test your recovery logic, not just error detection:

- After a drop, can the client retry successfully?
- After a timeout, can the client reconnect?
- After invalid data, can the client request fresh data?

### 4. Document Test Cases

Create named scenario configurations for common tests:

```python
SCENARIOS = {
    'flaky_network': {
        'drop_packets': {101: 0.3, 20: 0.3},  # 30% drop rate
        'response_delays': {102: 1.0},
    },
    'firmware_bug': {
        'malformed_packets': [107],
        'firmware_version': (2, 50),
    },
    'slow_device': {
        'response_delays': {
            101: 0.5,
            102: 1.0,
            20: 0.3,
        },
    },
    'intermittent_failures': {
        'drop_packets': {101: 0.5, 116: 0.4},  # 50% and 40% drop rates
    },
}

# Use in tests
device.scenarios = SCENARIOS['flaky_network']
```

## Next Steps

- **[Advanced Examples](../../tutorials/04-advanced-scenarios/)** - See scenarios in action
- **[Integration Testing](../integration-testing/)** - Use scenarios in test suites
- **[Best Practices](../best-practices/)** - Testing strategies
- **[API Reference: Device](../../api/device/)** - Full device API documentation

## See Also

- [Protocol Types Reference](../../api/protocol/) - All packet types and numbers
- [Device API](../../api/device/) - EmulatedLifxDevice documentation
- [FAQ](../../faq/) - Common issues and solutions

# Best Practices

This guide covers best practices for using the LIFX Emulator effectively in your development and testing workflows.

## When to Use the Emulator

### ‚úÖ Use the Emulator When:

**1. Developing LIFX Client Libraries**

- Testing protocol implementation
- Verifying packet handling
- Testing discovery mechanisms
- Validating state management

**2. Integration Testing**

- Testing application logic with LIFX devices
- Verifying end-to-end workflows
- Testing error handling
- CI/CD pipeline integration

**3. Protocol Exploration**

- Learning the LIFX LAN protocol
- Experimenting with different device types
- Understanding packet structures
- Testing edge cases

**4. Performance Testing**

- Load testing with many devices
- Concurrent request handling
- Network latency simulation
- Resource usage profiling

### ‚ùå Don't Use the Emulator When:

**1. Unit Testing Business Logic**

- Use mocks for faster, isolated tests
- Emulator adds unnecessary overhead
- Business logic should not depend on protocol details

```python
# Good: Unit test with mock
from unittest.mock import Mock

def test_color_converter():
    mock_device = Mock()
    mock_device.get_color.return_value = (21845, 65535, 32768, 3500)

    # Test your color conversion logic
    rgb = convert_hsbk_to_rgb(mock_device.get_color())
    assert rgb == (0, 255, 128)

# Bad: Unit test with emulator (too slow)
async def test_color_converter_slow():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    async with server:
        # Just testing conversion logic doesn't need a full emulator
        ...
```

**2. Testing Third-Party Hardware**

- Emulator can't reproduce hardware-specific bugs
- Real devices needed for hardware validation
- Firmware behavior may differ

**3. Testing WiFi/Network Stack**

- Emulator doesn't simulate WiFi issues
- Network stack testing needs real network conditions
- Use network simulation tools instead

## Decision Tree: Mock vs Emulator vs Real Device

```text
Are you testing protocol implementation?
‚îú‚îÄ Yes ‚Üí Use Emulator
‚îî‚îÄ No
    ‚îú‚îÄ Is this a unit test of business logic?
    ‚îÇ   ‚îî‚îÄ Yes ‚Üí Use Mock
    ‚îî‚îÄ No
        ‚îú‚îÄ Do you need to test hardware-specific behavior?
        ‚îÇ   ‚îî‚îÄ Yes ‚Üí Use Real Device
        ‚îî‚îÄ No
            ‚îú‚îÄ Is this an integration/E2E test?
            ‚îÇ   ‚îî‚îÄ Yes ‚Üí Use Emulator
            ‚îî‚îÄ No ‚Üí Use Mock
```

## Serial Number Strategies

### Consistent Naming Conventions

Use meaningful serial number patterns for easier debugging:

```python
# Good: Meaningful patterns
DEVICES = {
    'living_room': "d073d5001001",  # 1001 = living room
    'bedroom':     "d073d5001002",  # 1002 = bedroom
    'kitchen':     "d073d5001003",  # 1003 = kitchen
}

# Also good: By device type
DEVICES = {
    'color_1':     "d073d5100001",  # 1xxxxx = color lights
    'color_2':     "d073d5100002",
    'strip_1':     "d073d5200001",  # 2xxxxx = multizone
    'tile_1':      "d073d5300001",  # 3xxxxx = tiles
}
```

### Avoid Conflicts

Ensure serial numbers are unique across your test suite:

```python
# Bad: Reusing serials in different tests
# test_colors.py
device = create_color_light("d073d5000001")

# test_power.py
device = create_color_light("d073d5000001")  # Same serial!

# Good: Unique serials
# test_colors.py
device = create_color_light("d073d5010001")  # 01xxxx = color tests

# test_power.py
device = create_color_light("d073d5020001")  # 02xxxx = power tests
```

### Use Fixtures for Serial Generation

```python
import pytest

@pytest.fixture
def unique_serial():
    """Generate unique serial numbers."""
    counter = 0
    def _get_serial(prefix="d073d5"):
        nonlocal counter
        counter += 1
        return f"{prefix}{counter:06d}"
    return _get_serial

@pytest.mark.asyncio
async def test_with_unique_serial(unique_serial):
    device1 = create_color_light(unique_serial())  # d073d5000001
    device2 = create_color_light(unique_serial())  # d073d5000002
    # Guaranteed unique
```

## Port Management

### Dynamic Port Allocation

Always use dynamic ports to avoid conflicts:

```python
import socket

def get_free_port():
    """Get an available port from the OS."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0))
        s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        return s.getsockname()[1]

@pytest.fixture
async def emulator():
    """Emulator with dynamic port."""
    port = get_free_port()
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server, port
```

### Port Ranges for Parallel Tests

When using pytest-xdist:

```python
@pytest.fixture
async def emulator(worker_id):
    """Port allocation for parallel workers."""
    if worker_id == 'master':
        port = 56700
    else:
        # gw0 -> 56701, gw1 -> 56702, etc.
        worker_num = int(worker_id.replace('gw', ''))
        port = 56700 + worker_num + 1

    device = create_color_light(f"d073d500{worker_num:04d}")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server
```

### Environment Variable Override

```python
import os

@pytest.fixture
async def emulator():
    """Allow port override via environment."""
    port = int(os.getenv('LIFX_EMULATOR_PORT', get_free_port()))

    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server
```

## Async Context Manager Patterns

### Always Use Context Managers

```python
# Good: Context manager ensures cleanup
async with server:
    # Server automatically starts
    await do_tests()
# Server automatically stops

# Bad: Manual start/stop
await server.start()
try:
    await do_tests()
finally:
    await server.stop()  # Easy to forget!
```

### Nested Context Managers

```python
# Multiple servers
async with server1:
    async with server2:
        # Both running
        await test_multi_server()
# Both stopped

# Or use asynccontextmanager for custom fixtures
from contextlib import asynccontextmanager

@asynccontextmanager
async def multi_server_setup():
    server1 = EmulatedLifxServer([device1], "127.0.0.1", 56700)
    server2 = EmulatedLifxServer([device2], "127.0.0.1", 56701)

    async with server1, server2:
        yield server1, server2
```

### Timeout Protection

```python
import asyncio

@pytest.mark.asyncio
@pytest.mark.timeout(30)  # Fail if test takes >30s
async def test_with_timeout():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Test times out if it hangs
        await asyncio.wait_for(run_test(), timeout=25)
```

## Resource Cleanup

### Explicit Cleanup in Fixtures

```python
@pytest.fixture
async def emulator():
    """Fixture with explicit cleanup."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        try:
            yield server
        finally:
            # Additional cleanup if needed
            print("Cleaning up...")
            # Context manager already stopped server
```

### Cleanup Even on Exceptions

```python
import pytest

@pytest.fixture
async def robust_emulator():
    """Emulator that cleans up even on test failure."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        try:
            yield server
        except Exception as e:
            # Log error but still clean up
            print(f"Test failed: {e}")
            raise  # Re-raise after logging
```

### Background Task Management

```python
import asyncio

@pytest.fixture
async def emulator_with_task():
    """Emulator with background task."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Start background task
        task = asyncio.create_task(monitor_server(server))

        try:
            yield server
        finally:
            # Cancel background task
            task.cancel()
            try:
                await task
            except asyncio.CancelledError:
                pass
```

## Performance Considerations

### Fixture Scoping

Choose appropriate fixture scopes for performance:

```python
# Fastest: Session scope (one emulator for all tests)
@pytest.fixture(scope="session")
async def shared_emulator():
    """Shared across entire test session."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    async with server:
        yield server
    # Pros: Very fast, minimal overhead
    # Cons: Tests may affect each other

# Balanced: Module scope (one per test file)
@pytest.fixture(scope="module")
async def module_emulator():
    """Shared across one test file."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    async with server:
        yield server
    # Pros: Good isolation, reasonable speed
    # Cons: Some test coupling within module

# Safest: Function scope (one per test)
@pytest.fixture(scope="function")
async def fresh_emulator():
    """Fresh emulator for each test."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    async with server:
        yield server
    # Pros: Perfect isolation
    # Cons: Slowest (startup overhead per test)
```

### Parallel Test Execution

```bash
# Run tests in parallel with pytest-xdist
pytest -n auto  # Use all CPU cores
pytest -n 4     # Use 4 workers
```

```python
# Ensure tests are parallel-safe
@pytest.fixture
async def parallel_safe_emulator(worker_id):
    """Each worker gets unique port and serial."""
    if worker_id == 'master':
        port = 56700
        serial = "d073d5000001"
    else:
        worker_num = int(worker_id.replace('gw', ''))
        port = 56700 + worker_num + 1
        serial = f"d073d500{worker_num:04d}"

    device = create_color_light(serial)
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server
```

### Minimize Device Count

Create only the devices you need:

```python
# Bad: Creating unnecessary devices
devices = [create_color_light(f"d073d500{i:04d}") for i in range(100)]
server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
# Only testing with 1 device!

# Good: Create what you need
device = create_color_light("d073d5000001")
server = EmulatedLifxServer([device], "127.0.0.1", 56700)
```

## Test Organization Patterns

### Group Related Tests

```python
# tests/test_colors.py
class TestColorOperations:
    """Group color-related tests."""

    @pytest.fixture
    async def color_device(self):
        device = create_color_light("d073d5010001")
        server = EmulatedLifxServer([device], "127.0.0.1", 56700)
        async with server:
            yield server

    async def test_set_color(self, color_device):
        ...

    async def test_get_color(self, color_device):
        ...

# tests/test_power.py
class TestPowerOperations:
    """Group power-related tests."""
    ...
```

### Shared Fixtures in conftest.py

```python
# tests/conftest.py
import pytest
from lifx_emulator import create_color_light, EmulatedLifxServer

@pytest.fixture
async def basic_emulator():
    """Reusable basic emulator fixture."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    async with server:
        yield server

@pytest.fixture
async def multi_device_emulator():
    """Reusable multi-device fixture."""
    devices = [
        create_color_light(f"d073d500{i:04d}")
        for i in range(1, 4)
    ]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
    async with server:
        yield server
```

### Parametrized Device Tests

```python
import pytest
from lifx_emulator import (
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

@pytest.fixture(params=[
    ("color", create_color_light),
    ("multizone", lambda s: create_multizone_light(s, zone_count=16)),
    ("tile", lambda s: create_tile_device(s, tile_count=5)),
])
async def any_device_type(request):
    """Test against all device types."""
    device_type, factory = request.param
    device = factory("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server, device_type

async def test_basic_operations(any_device_type):
    """Test runs 3 times (once per device type)."""
    server, device_type = any_device_type
    print(f"Testing {device_type}")
    # Test common operations...
```

## Debugging Tips

### Enable Verbose Logging

```python
import logging

# At top of test file or conftest.py
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

# Or for specific module
logging.getLogger('lifx_emulator').setLevel(logging.DEBUG)
```

### Add Print Debugging

```python
async def test_with_debugging():
    device = create_color_light("d073d5000001")

    # Check initial state
    print(f"Initial state: {device.state}")

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        print(f"Server started on port {server.port}")
        print(f"Devices: {[d.state.serial for d in server.devices]}")

        # Your test here
        ...

        print(f"Final state: {device.state}")
```

### Use pytest -v and -s Flags

```bash
# Verbose output + show print statements
pytest tests/ -v -s

# Even more verbose
pytest tests/ -vv -s

# Show locals on failure
pytest tests/ -l
```

### Capture State on Failure

```python
@pytest.fixture
async def emulator_with_state_capture():
    """Capture state on test failure."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        try:
            yield server
        except Exception:
            # Capture state before cleanup
            print(f"\nDevice state at failure:")
            print(f"  Serial: {device.state.serial}")
            print(f"  Label: {device.state.label}")
            print(f"  Power: {device.state.power}")
            print(f"  Color: {device.state.color}")
            raise
```

## Common Pitfalls

### ‚ùå Pitfall 1: Forgetting await

```python
# Bad: Forgot await
async def test_bad():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    server.start()  # Returns coroutine, not called!

# Good: Using await
async def test_good():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    async with server:  # Properly awaits start/stop
        ...
```

### ‚ùå Pitfall 2: Port Conflicts

```python
# Bad: Hard-coded port (conflicts in parallel tests)
port = 56700

# Good: Dynamic port
port = get_free_port()

# Better: Let fixture handle it
@pytest.fixture
async def emulator():
    port = get_free_port()
    ...
```

### ‚ùå Pitfall 3: Shared Mutable State

```python
# Bad: Shared device across tests
GLOBAL_DEVICE = create_color_light("d073d5000001")

def test_1():
    GLOBAL_DEVICE.state.power = 0  # Modifies global state!

def test_2():
    assert GLOBAL_DEVICE.state.power == 65535  # Fails!

# Good: Fresh device per test
@pytest.fixture
async def device():
    return create_color_light("d073d5000001")
```

### ‚ùå Pitfall 4: Not Cleaning Up

```python
# Bad: Manual cleanup can be missed
server = EmulatedLifxServer([device], "127.0.0.1", 56700)
await server.start()
# If error occurs here, server never stops!
await run_test()
await server.stop()

# Good: Context manager guarantees cleanup
async with server:
    await run_test()
# Always stops, even on error
```

### ‚ùå Pitfall 5: Ignoring Async Event Loop

```python
# Bad: Wrong event loop policy on Windows
# May cause issues with asyncio on Windows

# Good: Set policy in conftest.py
import sys
import pytest

if sys.platform == 'win32':
    import asyncio
    asyncio.set_event_loop_policy(
        asyncio.WindowsProactorEventLoopPolicy()
    )
```

## Checklist for New Tests

Before writing a new test, ask:

- Do I need the full emulator, or would a mock suffice?
- What fixture scope is appropriate (function/module/session)?
- Am I using dynamic port allocation?
- Are my serial numbers unique and meaningful?
- Am I using context managers for cleanup?
- Have I added appropriate timeouts?
- Can this test run in parallel with others?
- Did I test the test? (Run it locally first)

## Next Steps

- **[Testing Scenarios](../testing-scenarios/)** - Error injection patterns
- **[Integration Testing](../integration-testing/)** - pytest integration
- **[Advanced Examples](../../tutorials/04-advanced-scenarios/)** - Complex scenarios
- **[CI/CD Integration](../../tutorials/05-cicd/)** - Running in CI

## See Also

- [pytest Best Practices](https://docs.pytest.org/en/stable/goodpractices.html)
- [pytest-asyncio Documentation](https://pytest-asyncio.readthedocs.io/)
- [API Reference: Server](../../api/server/)
- [API Reference: Device](../../api/device/)

# Integration Testing Guide

This comprehensive guide covers how to integrate the LIFX Emulator into your testing workflow using pytest and pytest-asyncio.

## Overview

Integration testing with the emulator allows you to test your LIFX client code against real protocol implementations without needing physical devices. This guide covers pytest patterns, fixture design, CI/CD integration, and best practices.

## Quick Start

### Install Testing Dependencies

```bash
# Core testing tools
pip install pytest pytest-asyncio

# Optional: Parallel testing
pip install pytest-xdist

# Optional: Coverage reporting
pip install pytest-cov

# Optional: Timeout handling
pip install pytest-timeout
```

### Basic Test Setup

```python
# test_basic.py
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def emulator():
    """Basic emulator fixture."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_device_creation(emulator):
    """Test device is created correctly."""
    assert len(emulator.devices) == 1
    assert emulator.devices[0].state.serial == "d073d5000001"
```

Run tests:

```bash
pytest test_basic.py -v
```

## pytest Fixture Patterns

### Function-Scoped Fixtures (Default)

Fresh emulator for each test - safest but slowest:

```python
@pytest.fixture(scope="function")
async def fresh_emulator():
    """New emulator for each test."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_one(fresh_emulator):
    """Each test gets fresh emulator."""
    assert len(fresh_emulator.devices) == 1

@pytest.mark.asyncio
async def test_two(fresh_emulator):
    """Separate fresh emulator."""
    assert len(fresh_emulator.devices) == 1
```

**Use When:**

- Tests modify device state
- Perfect isolation is critical
- Tests are few or parallelized

### Module-Scoped Fixtures

Shared emulator across one test file - good balance:

```python
@pytest.fixture(scope="module")
async def module_emulator():
    """Shared across entire module."""
    devices = [
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),
    ]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_first_device(module_emulator):
    """Use shared emulator."""
    device = module_emulator.devices[0]
    assert device.state.serial == "d073d5000001"

@pytest.mark.asyncio
async def test_second_device(module_emulator):
    """Same emulator instance."""
    device = module_emulator.devices[1]
    assert device.state.serial == "d073d5000002"
```

**Use When:**

- Tests don't modify shared state
- Want faster test execution
- Testing read-only operations

### Session-Scoped Fixtures

One emulator for entire test session - fastest:

```python
@pytest.fixture(scope="session")
async def session_emulator():
    """Shared across all tests."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server
```

**Use When:**

- Very large test suite
- All tests are read-only
- Speed is critical

**Warning:** Tests can affect each other

## Fixture Design Patterns

### Composable Fixtures

Build complex setups from simple fixtures:

```python
@pytest.fixture
async def basic_device():
    """Single device fixture."""
    return create_color_light("d073d5000001")

@pytest.fixture
async def server_with_device(basic_device):
    """Server using device fixture."""
    server = EmulatedLifxServer([basic_device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_with_composed_fixtures(server_with_device):
    """Use composed fixtures."""
    assert len(server_with_device.devices) == 1
```

### Parametrized Fixtures

Test against multiple configurations:

```python
from lifx_emulator import (
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

@pytest.fixture(params=[
    ("color", lambda: create_color_light("d073d5000001")),
    ("multizone", lambda: create_multizone_light("d073d8000001", zone_count=16)),
    ("tile", lambda: create_tile_device("d073d9000001", tile_count=5)),
])
async def any_device(request):
    """Parametrized device fixture."""
    device_type, factory = request.param
    device = factory()
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server, device_type

@pytest.mark.asyncio
async def test_all_device_types(any_device):
    """Test runs 3 times (once per device type)."""
    server, device_type = any_device
    print(f"Testing with {device_type} device")
    assert len(server.devices) == 1
```

### Conditional Fixtures

Skip tests based on conditions:

```python
import sys

@pytest.fixture
async def emulator_windows_only():
    """Only run on Windows."""
    if sys.platform != 'win32':
        pytest.skip("Windows-only test")

    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server
```

## conftest.py Organization

Centralize fixtures for reuse across test files:

```python
# tests/conftest.py
import pytest
import sys
from lifx_emulator import (
    EmulatedLifxServer,
    create_color_light,
    create_multizone_light,
)

# Event loop configuration (especially for Windows)
if sys.platform == 'win32':
    import asyncio
    asyncio.set_event_loop_policy(asyncio.WindowsProactorEventLoopPolicy())

@pytest.fixture(scope="session")
def event_loop():
    """Create event loop for async tests."""
    import asyncio
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
async def single_device():
    """Reusable single device fixture."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.fixture
async def multi_device():
    """Reusable multi-device fixture."""
    devices = [
        create_color_light("d073d5000001"),
        create_color_light("d073d5000002"),
        create_multizone_light("d073d8000001", zone_count=16),
    ]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.fixture
async def unreliable_device():
    """Device configured for error testing."""
    device = create_color_light("d073d5000001")
    device.scenarios = {
        'drop_packets': [101],
        'response_delays': {102: 0.5},
    }
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server
```

Now all test files can use these fixtures:

```python
# tests/test_colors.py
import pytest

@pytest.mark.asyncio
async def test_color_device(single_device):
    """Uses fixture from conftest.py"""
    assert single_device.devices[0].state.has_color
```

## Test Isolation Techniques

### State Reset Between Tests

```python
@pytest.fixture
async def emulator_with_reset():
    """Emulator that resets state between tests."""
    from lifx_emulator.protocol.protocol_types import LightHsbk

    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    # Store initial state
    initial_color = device.state.color
    initial_power = device.state.power

    async with server:
        yield server

        # Reset state after test
        device.state.color = initial_color
        device.state.power = initial_power
```

### Separate Device Instances

```python
@pytest.fixture
def device_factory():
    """Factory for creating fresh devices."""
    def _create(serial=None):
        if serial is None:
            import uuid
            serial = f"d073d5{uuid.uuid4().hex[:6]}"
        return create_color_light(serial)
    return _create

@pytest.mark.asyncio
async def test_with_factory(device_factory):
    """Each call creates fresh device."""
    device1 = device_factory()
    device2 = device_factory()
    assert device1.state.serial != device2.state.serial
```

### Port Isolation

```python
import socket

def get_free_port():
    """Get available port."""
    with socket.socket() as s:
        s.bind(('', 0))
        return s.getsockname()[1]

@pytest.fixture
async def isolated_emulator():
    """Emulator on unique port."""
    port = get_free_port()
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server, port
```

## Parallel Test Execution

### Basic Parallel Testing

Install pytest-xdist:

```bash
pip install pytest-xdist
```

Run tests in parallel:

```bash
# Use all CPU cores
pytest -n auto

# Use specific number of workers
pytest -n 4

# Parallel within modules only
pytest -n auto --dist loadfile
```

### Worker-Safe Fixtures

Ensure each worker gets unique ports:

```python
@pytest.fixture
async def worker_safe_emulator(worker_id):
    """Safe for parallel execution."""
    if worker_id == 'master':
        # Running in single-threaded mode
        port = 56700
        serial = "d073d5000001"
    else:
        # Running with pytest-xdist (gw0, gw1, etc.)
        worker_num = int(worker_id.replace('gw', ''))
        port = 56700 + worker_num + 1
        serial = f"d073d500{worker_num:04d}"

    device = create_color_light(serial)
    server = EmulatedLifxServer([device], "127.0.0.1", port)

    async with server:
        yield server
```

### Parallel Test Best Practices

```python
# Mark tests as safe for parallel execution
@pytest.mark.parallel
@pytest.mark.asyncio
async def test_parallel_safe(worker_safe_emulator):
    """Can run in parallel with other tests."""
    assert len(worker_safe_emulator.devices) == 1

# Mark tests that must run serially
@pytest.mark.serial
@pytest.mark.asyncio
async def test_must_run_alone():
    """Cannot run in parallel."""
    # Tests that modify global state, use hardcoded ports, etc.
    ...
```

Configure in pytest.ini:

```ini
[pytest]
markers =
    parallel: Tests safe for parallel execution
    serial: Tests that must run alone
```

## CI/CD Integration

### GitHub Actions

Basic workflow:

```yaml
# .github/workflows/test.yml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.13', '3.14']

    steps:
    - uses: actions/checkout@v4

    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v5
      with:
        python-version: ${{ matrix.python-version }}

    - name: Install dependencies
      run: |
        pip install pytest pytest-asyncio pytest-xdist
        pip install -e .

    - name: Run tests
      run: |
        pytest tests/ -v -n auto
```

### GitLab CI

```yaml
# .gitlab-ci.yml
test:
  image: python:3.13
  script:
    - pip install pytest pytest-asyncio
    - pip install -e .
    - pytest tests/ -v --junitxml=report.xml
  artifacts:
    when: always
    reports:
      junit: report.xml
```

### Docker-Based Testing

```dockerfile
# Dockerfile.test
FROM python:3.13-slim

WORKDIR /app
COPY . /app

RUN pip install pytest pytest-asyncio && \
    pip install -e .

CMD ["pytest", "tests/", "-v"]
```

Run tests in Docker:

```bash
docker build -f Dockerfile.test -t lifx-tests .
docker run lifx-tests
```

## Handling Test Dependencies

### Sequential Test Execution

When tests must run in order:

```python
import pytest

@pytest.mark.asyncio
@pytest.mark.order(1)
async def test_first():
    """Runs first."""
    ...

@pytest.mark.asyncio
@pytest.mark.order(2)
async def test_second():
    """Runs second."""
    ...
```

Requires pytest-order:

```bash
pip install pytest-order
```

### Test Data Dependencies

Share data between tests:

```python
import pytest

@pytest.fixture(scope="module")
def test_data():
    """Shared test data."""
    return {"device_serial": "d073d5000001"}

@pytest.mark.asyncio
async def test_create(test_data):
    """Use shared data."""
    device = create_color_light(test_data["device_serial"])
    assert device is not None

@pytest.mark.asyncio
async def test_query(test_data):
    """Use same data."""
    # Can use test_data["device_serial"]
    ...
```

### Cleanup Dependencies

Ensure cleanup happens in correct order:

```python
@pytest.fixture
async def database():
    """Mock database."""
    db = setup_database()
    yield db
    teardown_database(db)

@pytest.fixture
async def emulator_with_db(database):
    """Emulator using database."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server
    # database fixture will clean up after this
```

## Advanced Testing Patterns

### Testing Error Handling

```python
@pytest.mark.asyncio
async def test_timeout_handling():
    """Test client handles timeouts."""
    device = create_color_light("d073d5000001")

    # Drop all GetColor packets
    device.scenarios = {'drop_packets': [101]}

    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Your client should timeout gracefully
        import asyncio
        with pytest.raises(asyncio.TimeoutError):
            await asyncio.wait_for(query_color(device), timeout=1.0)
```

### Testing Concurrent Operations

```python
@pytest.mark.asyncio
async def test_concurrent_requests():
    """Test multiple concurrent operations."""
    devices = [create_color_light(f"d073d500{i:04d}") for i in range(5)]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        # Send requests to all devices concurrently
        tasks = [
            query_device(device.state.serial)
            for device in devices
        ]
        results = await asyncio.gather(*tasks)

        assert len(results) == 5
```

### Testing State Transitions

```python
@pytest.mark.asyncio
async def test_state_transitions():
    """Test device state changes."""
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        # Initial state
        assert device.state.power == 65535  # On

        # Transition to off
        device.state.power = 0
        assert device.state.power == 0

        # Back to on
        device.state.power = 65535
        assert device.state.power == 65535
```

## pytest Configuration

### pytest.ini

```ini
[pytest]
# Test discovery
python_files = test_*.py *_test.py
python_classes = Test*
python_functions = test_*

# Async support
asyncio_mode = auto

# Output
addopts =
    -v
    --strict-markers
    --tb=short
    --color=yes

# Markers
markers =
    slow: Slow tests (deselect with '-m "not slow"')
    integration: Integration tests
    unit: Unit tests
    parallel: Safe for parallel execution

# Coverage
[coverage:run]
source = src
omit = */tests/*

[coverage:report]
precision = 2
show_missing = True
```

### pyproject.toml

```toml
[tool.pytest.ini_options]
minversion = "7.0"
testpaths = ["tests"]
asyncio_mode = "auto"
```

## Test Organization Structure

```text
tests/
‚îú‚îÄ‚îÄ conftest.py              # Shared fixtures
‚îú‚îÄ‚îÄ unit/                    # Unit tests
‚îÇ   ‚îú‚îÄ‚îÄ test_colors.py
‚îÇ   ‚îú‚îÄ‚îÄ test_power.py
‚îÇ   ‚îî‚îÄ‚îÄ test_labels.py
‚îú‚îÄ‚îÄ integration/             # Integration tests
‚îÇ   ‚îú‚îÄ‚îÄ conftest.py         # Integration-specific fixtures
‚îÇ   ‚îú‚îÄ‚îÄ test_discovery.py
‚îÇ   ‚îú‚îÄ‚îÄ test_multidevice.py
‚îÇ   ‚îî‚îÄ‚îÄ test_scenarios.py
‚îú‚îÄ‚îÄ performance/             # Performance tests
‚îÇ   ‚îú‚îÄ‚îÄ test_load.py
‚îÇ   ‚îî‚îÄ‚îÄ test_concurrent.py
‚îî‚îÄ‚îÄ fixtures/                # Shared test data
    ‚îú‚îÄ‚îÄ device_configs.py
    ‚îî‚îÄ‚îÄ scenarios.py
```

## Debugging Failed Tests

### Capture Output

```python
import pytest

@pytest.mark.asyncio
async def test_with_capture(capfd):
    """Capture stdout/stderr."""
    device = create_color_light("d073d5000001")
    print(f"Device created: {device.state.serial}")

    # Test code...

    # Check captured output
    captured = capfd.readouterr()
    assert "d073d5000001" in captured.out
```

### Use pytest --pdb

```bash
# Drop into debugger on failure
pytest --pdb

# Drop into debugger on first failure
pytest -x --pdb

# Drop into debugger at start of test
pytest --trace
```

### Add Logging

```python
import logging
import pytest

@pytest.fixture(autouse=True)
def configure_logging():
    """Auto-configure logging for all tests."""
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
```

## Next Steps

- **[Best Practices](../best-practices/)** - Testing best practices
- **[Testing Scenarios](../testing-scenarios/)** - Error injection
- **[CI/CD Tutorial](../../tutorials/05-cicd/)** - Detailed CI/CD setup
- **[Integration Examples](../../tutorials/03-integration/)** - More examples

## See Also

- [pytest Documentation](https://docs.pytest.org/)
- [pytest-asyncio Documentation](https://pytest-asyncio.readthedocs.io/)
- [pytest-xdist Documentation](https://pytest-xdist.readthedocs.io/)
- [API Reference: Server](../../api/server/)
- [API Reference: Device](../../api/device/)
# API Reference

# API Reference

Complete Python API documentation for the LIFX Emulator.

## Overview

The LIFX Emulator API is designed for simplicity and ease of use. Most users only need the factory functions and server class.

## Reading This Guide

This reference is organized from most common to advanced usage:

1. **[Factory Functions](factories/)** ‚≠ê Start here - Creating devices (most common)
1. **[Server](server/)** - Server setup and configuration
1. **[Device](device/)** - Device API and state management
1. **[Products](products/)** - Product registry and specs
1. **[Protocol](protocol/)** - Low-level protocol types (advanced)
1. **[Storage](storage/)** - Persistent state (advanced)

## Quick Start

### Installation

**Recommended:** Using [uv](https://astral.sh/uv):

```bash
uv add lifx-emulator
```

**Alternative:** Using pip:

```bash
pip install lifx-emulator
```

### Basic Usage

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def main():
    # Create a device
    device = create_color_light("d073d5000001")

    # Start server
    async with EmulatedLifxServer([device], "127.0.0.1", 56700) as server:
        # Server is running, test your LIFX library here
        await asyncio.Event().wait()

asyncio.run(main())
```

## Core Components

### 1. Factory Functions (Most Common)

Use these to create devices easily:

```python
from lifx_emulator import (
    create_color_light,           # RGB color lights
    create_color_temperature_light, # White temperature lights
    create_infrared_light,         # IR-capable lights
    create_hev_light,             # HEV cleaning lights
    create_multizone_light,       # Linear strips
    create_tile_device,           # Matrix tiles
)
```

üëâ **[Full Factory Documentation](factories/)**

### 2. Server

The server manages UDP communication and device routing:

```python
from lifx_emulator import EmulatedLifxServer

# Create server
server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

# Use as context manager (recommended)
async with server:
    # Server running
    pass

# Or manual lifecycle
await server.start()
await server.stop()
```

üëâ **[Full Server Documentation](server/)**

### 3. Device (Advanced)

For custom device creation:

```python
from lifx_emulator.devices import EmulatedLifxDevice, DeviceState

state = DeviceState(serial="d073d5000001", label="Custom Device")
device = EmulatedLifxDevice(state)
```

üëâ **[Full Device Documentation](device/)**

### 4. Product Registry

Access official LIFX product definitions:

```python
from lifx_emulator.products.registry import get_product, get_registry

product = get_product(27)  # LIFX A19
all_products = get_registry()
```

üëâ **[Full Product Documentation](products/)**

## Quick Reference

### Creating Devices

| Function                           | Product                      | Description                           |
| ---------------------------------- | ---------------------------- | ------------------------------------- |
| `create_color_light()`             | LIFX A19 (27)                | Standard RGB color light              |
| `create_color_temperature_light()` | LIFX Mini White to Warm (50) | Variable color temperature            |
| `create_infrared_light()`          | LIFX A19 Night Vision (29)   | IR capable light                      |
| `create_hev_light()`               | LIFX Clean (90)              | HEV cleaning light                    |
| `create_multizone_light()`         | LIFX Z (32) or Beam (38)     | Linear multizone strip                |
| `create_tile_device()`             | LIFX Tile (55)               | Tile matrix (configurable dimensions) |

### Server Context Manager

The server can be used as an async context manager:

```python
async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    # Server is running
    # Your test code here
    pass
# Server automatically stops
```

### Server Lifecycle

Manual server lifecycle management:

```python
server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
await server.start()  # Start listening
# ... do work ...
await server.stop()   # Stop server
```

## Module Structure

```text
lifx_emulator/
‚îú‚îÄ‚îÄ __init__.py           # Public exports
‚îú‚îÄ‚îÄ server.py             # EmulatedLifxServer
‚îú‚îÄ‚îÄ device.py             # EmulatedLifxDevice, DeviceState
‚îú‚îÄ‚îÄ factories.py          # create_* factory functions
‚îú‚îÄ‚îÄ constants.py          # Protocol constants
‚îú‚îÄ‚îÄ protocol/
‚îÇ   ‚îú‚îÄ‚îÄ header.py         # LifxHeader
‚îÇ   ‚îú‚îÄ‚îÄ packets.py        # Packet definitions
‚îÇ   ‚îú‚îÄ‚îÄ protocol_types.py # LightHsbk, etc.
‚îÇ   ‚îî‚îÄ‚îÄ serializer.py     # Binary serialization
‚îî‚îÄ‚îÄ products/
    ‚îú‚îÄ‚îÄ registry.py       # Product registry
    ‚îú‚îÄ‚îÄ specs.py          # Product defaults
    ‚îî‚îÄ‚îÄ generator.py      # Registry generator
```

## Public Exports

The following are exported from `lifx_emulator`:

```python
from lifx_emulator import (
    # Server
    EmulatedLifxServer,

    # Device (for advanced usage)
    EmulatedLifxDevice,

    # Factory functions (recommended)
    create_color_light,
    create_color_temperature_light,
    create_hev_light,
    create_infrared_light,
    create_multizone_light,
    create_tile_device,
)
```

## Common Patterns

### Basic Test Setup

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light

async def test_basic():
    device = create_color_light("d073d5000001")

    async with EmulatedLifxServer([device], "127.0.0.1", 56700) as server:
        # Your test code using your LIFX library
        pass
```

### Multiple Device Types

```python
from lifx_emulator import (
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

devices = [
    create_color_light("d073d5000001"),
    create_multizone_light("d073d8000001", zone_count=16),
    create_tile_device("d073d9000001", tile_count=5),
]

async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    # Test with multiple device types
    pass
```

### Custom serials

```python
devices = [
    create_color_light("cafe00000001"),
    create_color_light("cafe00000002"),
    create_color_light("cafe00000003"),
]
```

### Accessing Device State

```python
device = create_color_light("d073d5000001")

# Check initial state
print(f"Label: {device.state.label}")
print(f"Power: {device.state.power_level}")
print(f"Color: {device.state.color}")

# After commands are sent to the device
print(f"New color: {device.state.color}")
```

## Next Steps

- [Server API](server/) - EmulatedLifxServer documentation
- [Device API](device/) - EmulatedLifxDevice and DeviceState
- [Factory Functions](factories/) - All create\_\* functions
- [Protocol Types](protocol/) - LightHsbk and other types
- [Product Registry](products/) - Product database

# Factory Functions

Factory functions provide the easiest way to create emulated LIFX devices with sensible defaults.

## Overview

All factory functions return an `EmulatedLifxDevice` instance configured for a specific product type. They automatically load product-specific defaults (like zone counts and tile dimensions) from the product registry.

Device factory for creating emulated LIFX devices.

This package provides a clean, testable API for creating LIFX devices using:

- Builder pattern for flexible device construction
- Separate services for serial generation, color config, firmware config
- Product registry integration for accurate device specifications

| FUNCTION                         | DESCRIPTION                                                      |
| -------------------------------- | ---------------------------------------------------------------- |
| `create_color_light`             | Create a regular color light (LIFX Color)                        |
| `create_color_temperature_light` | Create a color temperature light (LIFX Mini White to Warm).      |
| `create_infrared_light`          | Create an infrared-enabled light (LIFX A19 Night Vision)         |
| `create_hev_light`               | Create an HEV-enabled light (LIFX Clean)                         |
| `create_multizone_light`         | Create a multizone light (LIFX Beam)                             |
| `create_tile_device`             | Create a tile device (LIFX Tile)                                 |
| `create_device`                  | Create a device for any LIFX product using the product registry. |

## Functions

### create_color_light

```python
create_color_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create a regular color light (LIFX Color)

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_color_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create a regular color light (LIFX Color)"""
    return create_device(
        91,
        serial=serial,
        firmware_version=firmware_version,
        storage=storage,
        scenario_manager=scenario_manager,
    )  # LIFX Color
```

### create_color_temperature_light

```python
create_color_temperature_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create a color temperature light (LIFX Mini White to Warm).

Variable color temperature, no RGB.

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_color_temperature_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create a color temperature light (LIFX Mini White to Warm).

    Variable color temperature, no RGB.
    """
    return create_device(
        50,
        serial=serial,
        firmware_version=firmware_version,
        storage=storage,
        scenario_manager=scenario_manager,
    )  # LIFX Mini White to Warm
```

### create_infrared_light

```python
create_infrared_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create an infrared-enabled light (LIFX A19 Night Vision)

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_infrared_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create an infrared-enabled light (LIFX A19 Night Vision)"""
    return create_device(
        29,
        serial=serial,
        firmware_version=firmware_version,
        storage=storage,
        scenario_manager=scenario_manager,
    )  # LIFX A19 Night Vision
```

### create_hev_light

```python
create_hev_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create an HEV-enabled light (LIFX Clean)

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_hev_light(
    serial: str | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create an HEV-enabled light (LIFX Clean)"""
    return create_device(
        90,
        serial=serial,
        firmware_version=firmware_version,
        storage=storage,
        scenario_manager=scenario_manager,
    )  # LIFX Clean
```

### create_multizone_light

```python
create_multizone_light(
    serial: str | None = None,
    zone_count: int | None = None,
    extended_multizone: bool = True,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create a multizone light (LIFX Beam)

| PARAMETER            | DESCRIPTION                                                                          |
| -------------------- | ------------------------------------------------------------------------------------ |
| `serial`             | Optional serial **TYPE:** \`str                                                      |
| `zone_count`         | Optional zone count (uses product default if not specified) **TYPE:** \`int          |
| `extended_multizone` | enables support for extended multizone requests **TYPE:** `bool` **DEFAULT:** `True` |
| `firmware_version`   | Optional firmware version tuple (major, minor) **TYPE:** \`tuple[int, int]           |
| `storage`            | Optional storage for persistence **TYPE:** \`DevicePersistenceAsyncFile              |
| `scenario_manager`   | Optional scenario manager **TYPE:** \`HierarchicalScenarioManager                    |

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_multizone_light(
    serial: str | None = None,
    zone_count: int | None = None,
    extended_multizone: bool = True,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create a multizone light (LIFX Beam)

    Args:
        serial: Optional serial
        zone_count: Optional zone count (uses product default if not specified)
        extended_multizone: enables support for extended multizone requests
        firmware_version: Optional firmware version tuple (major, minor)
        storage: Optional storage for persistence
        scenario_manager: Optional scenario manager
    """
    return create_device(
        38,
        serial=serial,
        zone_count=zone_count,
        extended_multizone=extended_multizone,
        firmware_version=firmware_version,
        storage=storage,
        scenario_manager=scenario_manager,
    )
```

### create_tile_device

```python
create_tile_device(
    serial: str | None = None,
    tile_count: int | None = None,
    tile_width: int | None = None,
    tile_height: int | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create a tile device (LIFX Tile)

| PARAMETER          | DESCRIPTION                                                                |
| ------------------ | -------------------------------------------------------------------------- |
| `serial`           | Optional serial **TYPE:** \`str                                            |
| `tile_count`       | Optional tile count (uses product default) **TYPE:** \`int                 |
| `tile_width`       | Optional tile width in pixels (uses product default) **TYPE:** \`int       |
| `tile_height`      | Optional tile height in pixels (uses product default) **TYPE:** \`int      |
| `firmware_version` | Optional firmware version tuple (major, minor) **TYPE:** \`tuple[int, int] |
| `storage`          | Optional storage for persistence **TYPE:** \`DevicePersistenceAsyncFile    |
| `scenario_manager` | Optional scenario manager **TYPE:** \`HierarchicalScenarioManager          |

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_tile_device(
    serial: str | None = None,
    tile_count: int | None = None,
    tile_width: int | None = None,
    tile_height: int | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create a tile device (LIFX Tile)

    Args:
        serial: Optional serial
        tile_count: Optional tile count (uses product default)
        tile_width: Optional tile width in pixels (uses product default)
        tile_height: Optional tile height in pixels (uses product default)
        firmware_version: Optional firmware version tuple (major, minor)
        storage: Optional storage for persistence
        scenario_manager: Optional scenario manager
    """
    return create_device(
        55,
        serial=serial,
        tile_count=tile_count,
        tile_width=tile_width,
        tile_height=tile_height,
        firmware_version=firmware_version,
        storage=storage,
        scenario_manager=scenario_manager,
    )  # LIFX Tile
```

### create_device

```python
create_device(
    product_id: int,
    serial: str | None = None,
    zone_count: int | None = None,
    extended_multizone: bool | None = None,
    tile_count: int | None = None,
    tile_width: int | None = None,
    tile_height: int | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice
```

Create a device for any LIFX product using the product registry.

This function uses the DeviceBuilder pattern to construct devices with clean separation of concerns and testable components.

| PARAMETER            | DESCRIPTION                                                                                                                                      |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| `product_id`         | Product ID from the LIFX product registry **TYPE:** `int`                                                                                        |
| `serial`             | Optional serial (auto-generated if not provided) **TYPE:** \`str                                                                                 |
| `zone_count`         | Number of zones for multizone devices (auto-determined) **TYPE:** \`int                                                                          |
| `extended_multizone` | Enable extended multizone requests **TYPE:** \`bool                                                                                              |
| `tile_count`         | Number of tiles for matrix devices (default: 5) **TYPE:** \`int                                                                                  |
| `tile_width`         | Width of each tile in pixels (default: 8) **TYPE:** \`int                                                                                        |
| `tile_height`        | Height of each tile in pixels (default: 8) **TYPE:** \`int                                                                                       |
| `firmware_version`   | Optional firmware version tuple (major, minor). If not specified, uses 3.70 for extended_multizone or 2.60 otherwise **TYPE:** \`tuple[int, int] |
| `storage`            | Optional storage for persistence **TYPE:** \`DevicePersistenceAsyncFile                                                                          |
| `scenario_manager`   | Optional scenario manager for testing **TYPE:** \`HierarchicalScenarioManager                                                                    |

| RETURNS              | DESCRIPTION                                             |
| -------------------- | ------------------------------------------------------- |
| `EmulatedLifxDevice` | EmulatedLifxDevice configured for the specified product |

| RAISES       | DESCRIPTION                            |
| ------------ | -------------------------------------- |
| `ValueError` | If product_id is not found in registry |

Examples:

```pycon
>>> # Create LIFX A19 (PID 27)
>>> device = create_device(27)
>>> # Create LIFX Z strip (PID 32) with 24 zones
>>> strip = create_device(32, zone_count=24)
>>> # Create LIFX Tile (PID 55) with 10 tiles
>>> tiles = create_device(55, tile_count=10)
```

Source code in `src/lifx_emulator/factories/factory.py`

```python
def create_device(
    product_id: int,
    serial: str | None = None,
    zone_count: int | None = None,
    extended_multizone: bool | None = None,
    tile_count: int | None = None,
    tile_width: int | None = None,
    tile_height: int | None = None,
    firmware_version: tuple[int, int] | None = None,
    storage: DevicePersistenceAsyncFile | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
) -> EmulatedLifxDevice:
    """Create a device for any LIFX product using the product registry.

    This function uses the DeviceBuilder pattern to construct devices with
    clean separation of concerns and testable components.

    Args:
        product_id: Product ID from the LIFX product registry
        serial: Optional serial (auto-generated if not provided)
        zone_count: Number of zones for multizone devices (auto-determined)
        extended_multizone: Enable extended multizone requests
        tile_count: Number of tiles for matrix devices (default: 5)
        tile_width: Width of each tile in pixels (default: 8)
        tile_height: Height of each tile in pixels (default: 8)
        firmware_version: Optional firmware version tuple (major, minor).
                         If not specified, uses 3.70 for extended_multizone
                         or 2.60 otherwise
        storage: Optional storage for persistence
        scenario_manager: Optional scenario manager for testing

    Returns:
        EmulatedLifxDevice configured for the specified product

    Raises:
        ValueError: If product_id is not found in registry

    Examples:
        >>> # Create LIFX A19 (PID 27)
        >>> device = create_device(27)
        >>> # Create LIFX Z strip (PID 32) with 24 zones
        >>> strip = create_device(32, zone_count=24)
        >>> # Create LIFX Tile (PID 55) with 10 tiles
        >>> tiles = create_device(55, tile_count=10)
    """
    # Get product info from registry
    product_info = get_product(product_id)
    if product_info is None:
        raise ValueError(f"Unknown product ID: {product_id}")

    # Build device using builder pattern
    builder = DeviceBuilder(product_info)

    if serial is not None:
        builder.with_serial(serial)

    if zone_count is not None:
        builder.with_zone_count(zone_count)

    if extended_multizone is not None:
        builder.with_extended_multizone(extended_multizone)

    if tile_count is not None:
        builder.with_tile_count(tile_count)

    if tile_width is not None and tile_height is not None:
        builder.with_tile_dimensions(tile_width, tile_height)

    if firmware_version is not None:
        builder.with_firmware_version(*firmware_version)

    if storage is not None:
        builder.with_storage(storage)

    if scenario_manager is not None:
        builder.with_scenario_manager(scenario_manager)

    return builder.build()
```

## Usage Examples

### Color Light

Create a standard RGB color light (LIFX A19):

```python
from lifx_emulator import create_color_light

# Auto-generated serial
device = create_color_light()

# Custom serial
device = create_color_light("d073d5000001")

# Access state
print(f"Label: {device.state.label}")
print(f"Product: {device.state.product}")  # 27 (LIFX A19)
print(f"Has color: {device.state.has_color}")  # True
```

### Color Temperature Light

Create a white light with variable color temperature:

```python
from lifx_emulator import create_color_temperature_light

device = create_color_temperature_light("d073d5000001")

print(f"Has color: {device.state.has_color}")  # False
print(f"Product: {device.state.product}")  # 50 (LIFX Mini White to Warm)
```

### Infrared Light

Create a light with infrared capability:

```python
from lifx_emulator import create_infrared_light

device = create_infrared_light("d073d5000002")

print(f"Has infrared: {device.state.has_infrared}")  # True
print(f"Product: {device.state.product}")  # 29 (LIFX A19 Night Vision)
print(f"IR brightness: {device.state.infrared_brightness}")  # 16384 (25%)
```

### HEV Light

Create a light with HEV cleaning capability:

```python
from lifx_emulator import create_hev_light

device = create_hev_light("d073d5000003")

print(f"Has HEV: {device.state.has_hev}")  # True
print(f"Product: {device.state.product}")  # 90 (LIFX Clean)
print(f"HEV cycle duration: {device.state.hev_cycle_duration_s}")  # 7200 (2 hours)
```

### Multizone Light

Create a linear multizone device (strip or beam):

```python
from lifx_emulator import create_multizone_light

# Standard LIFX Z with default 16 zones
strip = create_multizone_light("d073d8000001")

# Custom zone count
strip_custom = create_multizone_light("d073d8000002", zone_count=24)

# Extended multizone (LIFX Beam) with default 80 zones
beam = create_multizone_light("d073d8000003", extended_multizone=True)

# Custom extended multizone
beam_custom = create_multizone_light(
    "d073d8000004",
    zone_count=60,
    extended_multizone=True
)

print(f"Strip zones: {strip.state.zone_count}")  # 16
print(f"Beam zones: {beam.state.zone_count}")   # 80
print(f"Strip product: {strip.state.product}")  # 32 (LIFX Z)
print(f"Beam product: {beam.state.product}")    # 38 (LIFX Beam)
```

### Tile Device

Create a matrix tile device:

```python
from lifx_emulator import create_tile_device

# Default configuration (5 tiles of 8x8)
tiles = create_tile_device("d073d9000001")

# Custom tile count
tiles_custom = create_tile_device("d073d9000002", tile_count=10)

# Custom tile dimensions (e.g., 16x8 with >64 zones per tile)
large_tile = create_tile_device(
    "d073d9000003",
    tile_count=1,
    tile_width=16,
    tile_height=8
)

print(f"Tile count: {tiles.state.tile_count}")      # 5
print(f"Tile width: {tiles.state.tile_width}")      # 8
print(f"Tile height: {tiles.state.tile_height}")    # 8
print(f"Product: {tiles.state.product}")            # 55 (LIFX Tile)

# Tiles with >64 zones require multiple Get64 requests (16x8 = 128 zones)
print(f"Large tile zones: {large_tile.state.tile_width * large_tile.state.tile_height}")  # 128
```

### Generic Device Creation

Create any device by product ID:

```python
from lifx_emulator.factories import create_device

# LIFX A19 (product ID 27)
a19 = create_device(27, serial="d073d5000001")

# LIFX Z (product ID 32) with custom zones
z_strip = create_device(32, serial="d073d8000001", zone_count=24)

# LIFX Tile (product ID 55) with custom configuration
tiles = create_device(
    55,
    serial="d073d9000001",
    tile_count=10,
    tile_width=8,
    tile_height=8
)

# LIFX Candle (product ID 57) - loads 5x6 dimensions from product defaults
candle = create_device(57, serial="d073d9000002")
print(f"Candle size: {candle.state.tile_width}x{candle.state.tile_height}")  # 5x6
```

## Serial Format

Serials must be 12 hex characters (6 bytes):

```python
# Valid formats
device = create_color_light("d073d5000001")  # Serial with LIFX prefix ("d073d5")
device = create_color_light("cafe00abcdef")  # Serial with custom prefix
device = create_color_light()                # Auto-generate serial

# Invalid (will raise error)
device = create_color_light("123")           # Too short
device = create_color_light("xyz")           # Not hex
```

Auto-generated serials use prefixes based on device type:

- `d073d5` - Regular lights
- `d073d6` - Infrared lights
- `d073d7` - HEV lights
- `d073d8` - Multizone strips/beams
- `d073d9` - Matrix tiles

## Product Defaults

When parameters like `zone_count` or `tile_count` are not specified, the factory functions automatically load defaults from the product registry's specs system:

```python
# Uses product default (16 zones for LIFX Z)
strip = create_multizone_light("d073d8000001")

# Uses product default (80 zones for LIFX Beam)
beam = create_multizone_light("d073d8000002", extended_multizone=True)

# Uses product default (5 tiles for LIFX Tile)
tiles = create_tile_device("d073d9000001")

# Uses product default (5x6 for LIFX Candle)
candle = create_device(57, serial="d073d9000002")
```

See [Product Registry](../products/) for all product definitions and defaults.

## Device State Access

After creation, access device state:

```python
device = create_color_light("d073d5000001")

# Device identity
print(device.state.serial)          # "d073d5000001"
print(device.state.label)           # "A19 d073d5"
print(device.state.vendor)          # 1 (LIFX)
print(device.state.product)         # 27 (LIFX A19)

# Device capabilities
print(device.state.has_color)       # True
print(device.state.has_infrared)    # False
print(device.state.has_multizone)   # False
print(device.state.has_matrix)      # False
print(device.state.has_hev)         # False

# Light state
print(device.state.power_level)     # 65535 (on)
print(device.state.color)           # LightHsbk(...)
print(device.state.port)            # 56700 (default)

# Firmware version
print(device.state.version_major)   # 2
print(device.state.version_minor)   # 80
```

## Multiple Devices

Create multiple devices for testing:

```python
from lifx_emulator import (
    create_color_light,
    create_multizone_light,
    create_tile_device,
    EmulatedLifxServer,
)

# Create a diverse set of devices
devices = [
    create_color_light("d073d5000001"),
    create_color_light("d073d5000002"),
    create_multizone_light("d073d8000001", zone_count=16),
    create_multizone_light("d073d8000002", zone_count=82, extended_multizone=True),
    create_tile_device("d073d9000001", tile_count=5),
]

# Start server with all devices
server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
await server.start()
```

## Advanced Options

### Persistent Storage

Devices can automatically persist state across restarts:

```python
from lifx_emulator import create_color_light
from lifx_emulator.async_storage import AsyncDeviceStorage

# Create storage (uses ~/.lifx-emulator by default)
storage = AsyncDeviceStorage()

# Create device with storage enabled
device = create_color_light("d073d5000001", storage=storage)

# State changes are automatically saved asynchronously
device.state.label = "My Light"

# On next run, state is automatically restored from disk
```

### Test Scenarios

Inject test scenarios (packet loss, delays, etc.) for error testing:

```python
from lifx_emulator import create_color_light
from lifx_emulator.scenarios.manager import HierarchicalScenarioManager, ScenarioConfig

# Create scenario manager
manager = HierarchicalScenarioManager()

# Create device with scenario support
device = create_color_light("d073d5000001", scenario_manager=manager)

# Configure scenarios for testing error handling
manager.set_device_scenario(
    device.state.serial,
    ScenarioConfig(
        drop_packets={101: 0.3},  # Drop 30% of GetColor packets
        response_delays={102: 0.5},  # Add 500ms delay to SetColor
    )
)
```

### Custom Firmware Versions

Override firmware version for compatibility testing:

```python
from lifx_emulator import create_color_light

# Simulate older firmware
old_device = create_color_light(
    "d073d5000001",
    firmware_version=(2, 60)
)

# Simulate newer firmware
new_device = create_color_light(
    "d073d5000002",
    firmware_version=(3, 90)
)
```

## Next Steps

- [Server API](../server/) - Running the emulator server
- [Device API](../device/) - Device and state details
- [Product Registry](../products/) - All available products
- [Basic Tutorial](../../tutorials/02-basic/) - Complete usage examples

# Device API Reference

> Device state management and emulated device implementation.

The device module provides the core classes for emulating LIFX devices: `DeviceState` holds all stateful information, and `EmulatedLifxDevice` processes incoming LIFX protocol packets and generates appropriate responses.

______________________________________________________________________

## Table of Contents

### Classes

- [DeviceState](#devicestate)
- [EmulatedLifxDevice](#emulatedlifxdevice)

### Key Concepts

- [Capability Flags](#capability-flags)
- [Testing Scenarios](#testing-scenarios)
- [State Access Patterns](#state-access-patterns)
- [Packet Processing Flow](#packet-processing-flow)

______________________________________________________________________

## DeviceState

Dataclass holding all stateful information for an emulated LIFX device.

`DeviceState` represents the complete state of a virtual LIFX device, including identity (serial, product ID), current settings (color, power, label), capabilities (color, multizone, matrix, etc.), and feature-specific state (zones, tiles, HEV cycle status).

### Fields

#### Identity

- **`serial`** (`str` = `'d073d5123456'`) - 12-character hexadecimal device serial number
- **`mac_address`** (`bytes` = `bytes.fromhex('d073d5123456')`) - 6-byte MAC address (derived from serial)
- **`vendor`** (`int` = `1`) - LIFX vendor ID (always 1)
- **`product`** (`int` = `27`) - Product ID (e.g., 27 for A19, 32 for Z strip)
- **`version_major`** (`int` = `3`) - Firmware major version
- **`version_minor`** (`int` = `70`) - Firmware minor version

#### Basic State

- **`port`** (`int` = `56700`) - UDP port for communication
- **`label`** (`str` = `'Emulated LIFX'`) - Device label (max 32 bytes)
- **`power_level`** (`int` = `0`) - Power state (0=off, 65535=on)
- **`color`** (`LightHsbk`) - Current HSBK color
- **`uptime_ns`** (`int` = `0`) - Device uptime in nanoseconds
- **`build_timestamp`** (`int`) - Firmware build timestamp (Unix epoch)

#### Capability Flags

- **`has_color`** (`bool` = `True`) - Supports full RGB color
- **`has_infrared`** (`bool` = `False`) - Supports infrared (night vision)
- **`has_multizone`** (`bool` = `False`) - Supports multizone (linear strips)
- **`has_matrix`** (`bool` = `False`) - Supports matrix (2D tiles)
- **`has_hev`** (`bool` = `False`) - Supports HEV (germicidal light)

#### Location & Group

- **`location_id`** (`bytes`) - 16-byte location UUID
- **`location_label`** (`str` = `'Test Location'`) - Location name
- **`location_updated_at`** (`int`) - Location update timestamp (nanoseconds)
- **`group_id`** (`bytes`) - 16-byte group UUID
- **`group_label`** (`str` = `'Test Group'`) - Group name
- **`group_updated_at`** (`int`) - Group update timestamp (nanoseconds)

#### Network

- **`wifi_signal`** (`float` = `-45.0`) - WiFi signal strength in dBm

#### Infrared (Night Vision)

- **`infrared_brightness`** (`int` = `0`) - IR brightness (0-65535)

#### HEV (Germicidal Light)

- **`hev_cycle_duration_s`** (`int` = `7200`) - HEV cycle duration in seconds
- **`hev_cycle_remaining_s`** (`int` = `0`) - Remaining time in current cycle
- **`hev_cycle_last_power`** (`bool` = `False`) - Last power state before cycle
- **`hev_indication`** (`bool` = `True`) - Enable visual indication during cycle
- **`hev_last_result`** (`int` = `0`) - Result of last HEV cycle

#### Multizone (Linear Strips)

- **`zone_count`** (`int` = `0`) - Number of zones (0 if not multizone)
- **`zone_colors`** (`list[LightHsbk]` = `[]`) - Color for each zone

#### Matrix (Tiles)

- **`tile_count`** (`int` = `0`) - Number of tiles in chain
- **`tile_devices`** (`list[dict]` = `[]`) - Per-tile state (position, colors)
- **`tile_width`** (`int` = `8`) - Width of each tile in pixels
- **`tile_height`** (`int` = `8`) - Height of each tile in pixels

#### Effects (Waveforms & Animations)

- **`waveform_active`** (`bool` = `False`) - Whether a waveform is running
- **`waveform_type`** (`int` = `0`) - Waveform type (saw, sine, etc.)
- **`waveform_transient`** (`bool` = `False`) - Return to original color after waveform
- **`waveform_color`** (`LightHsbk`) - Target waveform color
- **`waveform_period_ms`** (`int` = `0`) - Waveform period in milliseconds
- **`waveform_cycles`** (`float` = `0`) - Number of cycles (0 = infinite)
- **`waveform_duty_cycle`** (`int` = `0`) - Duty cycle for pulse waveform
- **`waveform_skew_ratio`** (`int` = `0`) - Skew ratio for waveform
- **`multizone_effect_type`** (`int` = `0`) - Multizone effect type (move, etc.)
- **`multizone_effect_speed`** (`int` = `5`) - Multizone effect speed
- **`tile_effect_type`** (`int` = `0`) - Tile effect type
- **`tile_effect_speed`** (`int` = `5`) - Tile effect speed
- **`tile_effect_palette_count`** (`int` = `0`) - Number of colors in effect palette
- **`tile_effect_palette`** (`list[LightHsbk]` = `[]`) - Effect palette colors

### Methods

#### `get_target_bytes() -> bytes`

Get the 8-byte target field for this device (6-byte serial + 2 null bytes).

**Returns:** `bytes` - Target bytes for packet header

**Example:**

```python
device_state = DeviceState(serial="d073d5000001")
target = device_state.get_target_bytes()
# Returns: b'\xd0\x73\xd5\x00\x00\x01\x00\x00'
```

______________________________________________________________________

## EmulatedLifxDevice

Emulated LIFX device that processes protocol packets and manages state.

`EmulatedLifxDevice` is the main class for emulating a LIFX device. It receives LIFX protocol packets via `process_packet()`, updates internal state, and returns appropriate response packets. It supports configurable testing scenarios for error injection, delays, and malformed responses.

### Constructor

#### `EmulatedLifxDevice(device_state, scenarios=None, storage=None, handler_registry=None)`

Create a new emulated LIFX device.

**Parameters:**

- **`device_state`** (`DeviceState`) - Initial device state
- **`scenarios`** (`dict | None`) - Optional testing scenarios configuration (see [Testing Scenarios](#testing-scenarios))
- **`storage`** (`AsyncDeviceStorage | None`) - Optional async persistent storage for state
- **`handler_registry`** (`HandlerRegistry | None`) - Optional custom packet handler registry

**Example:**

```python
from lifx_emulator.devices import DeviceState, EmulatedLifxDevice

# Create basic device
state = DeviceState(serial="d073d5000001", product=27, label="Living Room")
device = EmulatedLifxDevice(state)

# Create device with testing scenarios
scenarios = {
    "drop_packets": {116: 1.0},  # Drop all SetColor packets (100% drop rate)
    "response_delays": {2: 0.5},  # Delay GetService responses by 500ms
}
device = EmulatedLifxDevice(state, scenarios=scenarios)
```

### Methods

#### `get_uptime_ns() -> int`

Calculate current uptime in nanoseconds since device creation.

**Returns:** `int` - Uptime in nanoseconds

#### `should_respond(packet_type: int) -> bool`

Check if device should respond to a packet (for testing packet drop scenarios).

**Parameters:**

- **`packet_type`** (`int`) - LIFX packet type number

**Returns:** `bool` - `False` if packet should be dropped, `True` otherwise

#### `get_response_delay(packet_type: int) -> float`

Get configured response delay for a packet type (for testing timeout scenarios).

**Parameters:**

- **`packet_type`** (`int`) - LIFX packet type number

**Returns:** `float` - Delay in seconds (0.0 if no delay configured)

#### `should_send_malformed(packet_type: int) -> bool`

Check if response packet should be malformed (for testing error handling).

**Parameters:**

- **`packet_type`** (`int`) - LIFX packet type number

**Returns:** `bool` - `True` if response should be truncated/corrupted

#### `should_send_invalid_fields(packet_type: int) -> bool`

Check if response packet should have invalid field values (all 0xFF bytes).

**Parameters:**

- **`packet_type`** (`int`) - LIFX packet type number

**Returns:** `bool` - `True` if response fields should be invalid

#### `get_firmware_version_override() -> tuple[int, int] | None`

Get firmware version override from scenarios configuration.

**Returns:** `tuple[int, int] | None` - (major, minor) version tuple or `None`

#### `should_send_partial_response(packet_type: int) -> bool`

Check if multizone/tile response should be partial (incomplete data for testing).

**Parameters:**

- **`packet_type`** (`int`) - LIFX packet type number

**Returns:** `bool` - `True` if response should be incomplete

#### `process_packet(header: LifxHeader, packet: Any | None) -> list[tuple[LifxHeader, Any]]`

Process an incoming LIFX protocol packet and generate response packets.

This is the main entry point for packet processing. It:

1. Checks if an acknowledgment is required (`ack_required` flag)
1. Routes the packet to the appropriate handler based on packet type
1. Applies testing scenarios (delays, drops, malformed responses)
1. Returns a list of response packets (header, payload) tuples

**Parameters:**

- **`header`** (`LifxHeader`) - Parsed packet header
- **`packet`** (`Any | None`) - Parsed packet payload (None for header-only packets)

**Returns:** `list[tuple[LifxHeader, Any]]` - List of response packets to send

**Example:**

```python
from lifx_emulator.protocol.header import LifxHeader
from lifx_emulator.protocol.packets import Light

# Parse incoming packet
header = LifxHeader.unpack(raw_header)
packet = Light.SetColor.unpack(raw_payload)

# Process and get responses
responses = device.process_packet(header, packet)

# Send each response
for resp_header, resp_packet in responses:
    raw_response = resp_header.pack() + resp_packet.pack()
    sock.sendto(raw_response, client_address)
```

______________________________________________________________________

## Capability Flags

Capability flags in `DeviceState` determine which features the device supports and which packet types it can handle.

| Flag            | Description                  | Example Products                      | Supported Packets                                                                                       |
| --------------- | ---------------------------- | ------------------------------------- | ------------------------------------------------------------------------------------------------------- |
| `has_color`     | Full RGB color control       | A19 (27), BR30 (43), GU10 (66)        | `Light.Get`, `Light.SetColor`, `Light.State`                                                            |
| `has_infrared`  | Night vision IR capability   | A19 Night Vision (29), BR30 NV (44)   | `Light.GetInfrared`, `Light.SetInfrared`, `Light.StateInfrared`                                         |
| `has_multizone` | Linear zone control (strips) | LIFX Z (32), Beam (38)                | `MultiZone.GetColorZones`, `MultiZone.SetColorZones`, `MultiZone.StateZone`, `MultiZone.StateMultiZone` |
| `has_matrix`    | 2D tile/matrix control       | Tile (55), Candle (57), Ceiling (176) | `Tile.GetDeviceChain`, `Tile.Get64`, `Tile.Set64`, `Tile.StateDeviceChain`, `Tile.State64`              |
| `has_hev`       | Germicidal UV-C light        | LIFX Clean (90)                       | `Hev.GetCycle`, `Hev.SetCycle`, `Hev.StateCycle`                                                        |

**Notes:**

- Devices without a capability flag will ignore related packets
- Most devices have `has_color=True` (except switches and relays)
- Extended multizone (>16 zones) is indicated by `zone_count > 16`
- Matrix devices store tile data in `tile_devices` list

**Example:**

```python
# Create a multizone device
state = DeviceState(
    serial="d073d5000002",
    product=32,  # LIFX Z
    has_multizone=True,
    zone_count=16,
    zone_colors=[LightHsbk(hue=0, saturation=65535, brightness=32768, kelvin=3500) for _ in range(16)]
)

# Create a tile device
state = DeviceState(
    serial="d073d5000003",
    product=55,  # LIFX Tile
    has_matrix=True,
    tile_count=5,
    tile_width=8,
    tile_height=8,
)
```

______________________________________________________________________

## Testing Scenarios

The `scenarios` parameter allows you to configure error injection and testing behaviors for emulated devices. This is useful for testing client library error handling, timeouts, and edge cases.

### Available Scenarios

| Scenario               | Type               | Description                                      | Example                                                |
| ---------------------- | ------------------ | ------------------------------------------------ | ------------------------------------------------------ |
| `drop_packets`         | `dict[int, float]` | Packet types to drop with rates (0.0-1.0)        | `{116: 1.0, 117: 0.5}` - Always drop 116, drop 117 50% |
| `response_delays`      | `dict[int, float]` | Delay (seconds) before responding to packet type | `{2: 1.5}` - Delay GetService by 1.5s                  |
| `malformed_packets`    | `list[int]`        | Packet types to send truncated/corrupted         | `[107]` - Corrupt State packets                        |
| `invalid_field_values` | `list[int]`        | Packet types to send with invalid fields (0xFF)  | `[107]` - Invalid State values                         |
| `partial_responses`    | `list[int]`        | Multizone/tile packets to send incomplete        | `[506]` - Partial zone data                            |
| `firmware_version`     | `tuple[int, int]`  | Override firmware version                        | `(2, 80)` - Report v2.80                               |

### Examples

**Simulate network issues:**

```python
scenarios = {
    "drop_packets": {2: 1.0},  # Drop all GetService packets - simulate discovery failure
    "response_delays": {116: 2.0},  # Delay SetColor by 2 seconds
}
device = EmulatedLifxDevice(state, scenarios=scenarios)
```

**Test error handling:**

```python
scenarios = {
    "malformed_packets": [107],  # Corrupt Light.State responses
    "invalid_field_values": [118],  # Invalid Light.StatePower values
}
device = EmulatedLifxDevice(state, scenarios=scenarios)
```

**Test multizone edge cases:**

```python
scenarios = {
    "partial_responses": [506],  # Send incomplete StateMultiZone packets
}
device = EmulatedLifxDevice(state, scenarios=scenarios)
```

**Test firmware compatibility:**

```python
scenarios = {
    "firmware_version": (2, 77),  # Report older firmware version
}
device = EmulatedLifxDevice(state, scenarios=scenarios)
```

______________________________________________________________________

## State Access Patterns

### Reading State

Access device state directly through the `state` attribute:

```python
device = EmulatedLifxDevice(state)

# Check power
if device.state.power_level == 65535:
    print("Device is on")

# Check color
print(f"Hue: {device.state.color.hue}")
print(f"Brightness: {device.state.color.brightness}")

# Check zones (multizone)
if device.state.has_multizone:
    for i, color in enumerate(device.state.zone_colors):
        print(f"Zone {i}: {color}")
```

### Modifying State

Modify state fields directly and optionally save to persistent storage:

```python
# Change color
device.state.color = LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500)

# Change label
device.state.label = "Kitchen Light"

# Power on
device.state.power_level = 65535

# Save to persistent storage (if configured)
# State changes are automatically queued for async save
# If needed, manually queue a save:
# await device.storage.save_device_state(device.state)
```

### Persistent Storage Integration

Use `AsyncDeviceStorage` to persist state across restarts:

```python
import asyncio
from lifx_emulator.async_storage import AsyncDeviceStorage

async def main():
    storage = AsyncDeviceStorage()  # Uses ~/.lifx-emulator by default
    device = EmulatedLifxDevice(state, storage=storage)

    # State changes are automatically queued for async save
    # Manual async save:
    await storage.save_device_state(device.state)

    # On next run, state is automatically restored

asyncio.run(main())
restored_device = EmulatedLifxDevice(DeviceState(serial=state.serial), storage=storage)
# restored_device.state.label == "Kitchen Light"
```

______________________________________________________________________

## Packet Processing Flow

The packet processing flow in `EmulatedLifxDevice.process_packet()` follows these steps:

```
graph TD
    A[Incoming Packet] --> B{ack_required?}
    B -->|Yes| C[Add Acknowledgment]
    B -->|No| D{res_required?}

    D -->|Yes| E[Route to Handler]
    D -->|No| F[Route to Handler]

    E --> G{Handler Returns Response?}
    F --> H{Handler Returns Response?}

    G -->|Yes| I[Apply Scenarios]
    G -->|No| J[Return Responses]

    H -->|Yes| I
    H -->|No| J

    I --> K{Drop Packet?}
    K -->|Yes| L[Return Empty]
    K -->|No| M{Delay?}

    M -->|Yes| N[Wait Delay Time]
    M -->|No| O{Malformed?}

    N --> O
    O -->|Yes| P[Truncate Packet]
    O -->|No| Q{Invalid Fields?}

    P --> J
    Q -->|Yes| R[Set Fields to 0xFF]
    Q -->|No| J

    R --> J
    C --> J
    J[Return Responses]
```

**Key Points:**

- Acknowledgments (packet type 45) are sent when `ack_required=True` in header
- Response packets are sent when `res_required=True` in header
- Handlers are registered by packet type and dispatched via `HandlerRegistry`
- Testing scenarios are applied after handler execution, before returning responses
- Multiple response packets may be returned (e.g., multizone queries return multiple `StateMultiZone` packets)

**See Also:**

- [EmulatedLifxServer](../server/) - UDP server that routes packets to devices
- [Protocol Packets](../protocol/) - LIFX protocol packet definitions
- [Factories](../factories/) - Helper functions for creating pre-configured devices
- [Storage](../storage/) - Persistent state storage API

______________________________________________________________________

## References

**Source:** `src/lifx_emulator/device.py`

**Related Documentation:**

- [Getting Started](../../getting-started/quickstart/) - Quick start guide
- [Device Types](../../guide/device-types/) - Supported device types and capabilities
- [Testing Scenarios](../../guide/testing-scenarios/) - Detailed testing scenario guide
- [Architecture Overview](../../architecture/overview/) - System architecture

# EmulatedLifxServer

The `EmulatedLifxServer` class manages the UDP server and routes packets to emulated devices.

## Overview

The server:

- Listens on a UDP socket for LIFX protocol packets
- Parses packet headers to determine routing
- Forwards packets to appropriate devices
- Sends response packets back to clients
- Supports both targeted and broadcast packets

## API Reference

## EmulatedLifxServer

```python
EmulatedLifxServer(
    devices: list[EmulatedLifxDevice],
    device_manager: IDeviceManager,
    bind_address: str = "127.0.0.1",
    port: int = LIFX_UDP_PORT,
    track_activity: bool = True,
    storage=None,
    activity_observer: ActivityObserver | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
    persist_scenarios: bool = False,
    scenario_storage: IScenarioStorageBackend | None = None,
)
```

UDP server that simulates LIFX devices

| METHOD  | DESCRIPTION      |
| ------- | ---------------- |
| `start` | Start the server |
| `stop`  | Stop the server  |

Source code in `src/lifx_emulator/server.py`

```python
def __init__(
    self,
    devices: list[EmulatedLifxDevice],
    device_manager: IDeviceManager,
    bind_address: str = "127.0.0.1",
    port: int = LIFX_UDP_PORT,
    track_activity: bool = True,
    storage=None,
    activity_observer: ActivityObserver | None = None,
    scenario_manager: HierarchicalScenarioManager | None = None,
    persist_scenarios: bool = False,
    scenario_storage: IScenarioStorageBackend | None = None,
):
    # Device manager (required dependency injection)
    self._device_manager = device_manager
    self.bind_address = bind_address
    self.port = port
    self.transport = None
    self.storage = storage

    # Scenario storage backend (optional - only needed for persistence)
    self.scenario_persistence: IScenarioStorageBackend | None = None
    if persist_scenarios:
        if scenario_storage is None:
            raise ValueError(
                "scenario_storage is required when persist_scenarios=True"
            )
        if scenario_manager is None:
            raise ValueError(
                "scenario_manager is required when persist_scenarios=True "
                "(must be pre-loaded from storage before server initialization)"
            )
        self.scenario_persistence = scenario_storage

    # Scenario manager (shared across all devices for runtime updates)
    self.scenario_manager = scenario_manager or HierarchicalScenarioManager()

    # Add initial devices to the device manager
    for device in devices:
        self._device_manager.add_device(device, self.scenario_manager)

    # Activity observer - defaults to ActivityLogger if track_activity=True
    if activity_observer is not None:
        self.activity_observer = activity_observer
    elif track_activity:
        self.activity_observer = ActivityLogger(max_events=100)
    else:
        self.activity_observer = NullObserver()

    # Statistics tracking
    self.start_time = time.time()
    self.packets_received = 0
    self.packets_sent = 0
    self.packets_received_by_type: dict[int, int] = defaultdict(int)
    self.packets_sent_by_type: dict[int, int] = defaultdict(int)
    self.error_count = 0
```

### Functions

#### start

```python
start()
```

Start the server

Source code in `src/lifx_emulator/server.py`

```python
async def start(self):
    """Start the server"""
    loop = asyncio.get_running_loop()
    self.transport, _ = await loop.create_datagram_endpoint(
        lambda: self.LifxProtocol(self), local_addr=(self.bind_address, self.port)
    )
```

#### stop

```python
stop()
```

Stop the server

Source code in `src/lifx_emulator/server.py`

```python
async def stop(self):
    """Stop the server"""
    if self.transport:
        self.transport.close()
```

## Usage

### Basic Server

```python
from lifx_emulator import EmulatedLifxServer, create_color_light

# Create devices
devices = [create_color_light("d073d5000001")]

# Create server
server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

# Start server
await server.start()

# ... do work ...

# Stop server
await server.stop()
```

### Context Manager

The recommended way to use the server:

```python
async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    # Server automatically starts
    # Your test code here
    pass
# Server automatically stops
```

### Multiple Devices

```python
from lifx_emulator import (
    create_color_light,
    create_multizone_light,
    create_tile_device,
)

devices = [
    create_color_light("d073d5000001"),
    create_multizone_light("d073d8000001", zone_count=16),
    create_tile_device("d073d9000001", tile_count=5),
]

async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    # All devices are discoverable and controllable
    pass
```

## Parameters

### `devices`

List of `EmulatedLifxDevice` instances to emulate.

**Type:** `list[EmulatedLifxDevice]`

### `bind_address`

IP address to bind the UDP server to.

**Type:** `str`

**Examples:**

- `"0.0.0.0"` - Listen on all interfaces
- `"127.0.0.1"` - Localhost only
- `"192.168.1.100"` - Specific interface

### `port`

UDP port to listen on.

**Type:** `int`

**Default:** 56700 (standard LIFX port)

### `track_activity`

Enable packet activity tracking for the HTTP API dashboard.

**Type:** `bool`

**Default:** `True`

**Notes:**

- When enabled, the server tracks recent packet activity for the API dashboard
- Disable to reduce memory usage in production or CI environments
- Activity tracking is independent of packet logging (controlled by `--verbose` CLI flag)

**Example:**

```python
# Disable activity tracking
server = EmulatedLifxServer(
    devices,
    "127.0.0.1",
    56700,
    track_activity=False
)
```

### `storage`

Optional persistent storage for device state.

**Type:** `AsyncDeviceStorage | None`

**Default:** `None`

**Notes:**

- When provided, device state changes are automatically saved asynchronously
- Allows device state to persist across emulator restarts
- Must be used with devices created with the same storage instance
- See [Persistent Storage Guide](../../advanced/storage/) for details

**Example:**

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()
device = create_color_light("d073d5000001", storage=storage)

# Create server with storage support
server = EmulatedLifxServer(
    [device],
    "127.0.0.1",
    56700,
    storage=storage
)
```

### `activity_observer`

Optional observer for packet activity events.

**Type:** `ActivityObserver | None`

**Default:** `None`

**Notes:**

- Implement `ActivityObserver` protocol to receive packet events
- Useful for custom activity tracking or metrics collection
- Receives events for all packets sent and received

### `scenario_manager`

Optional scenario manager for test scenario configuration.

**Type:** `HierarchicalScenarioManager | None`

**Default:** `None`

**Notes:**

- When provided, enables runtime scenario management via REST API
- Supports device-specific, type-specific, location-based, group-based, and global scenarios
- Scenarios control packet dropping, delays, malformed responses, etc.
- See [Testing Scenarios Guide](../../advanced/scenarios/) for detailed examples

**Example:**

```python
from lifx_emulator.scenarios.manager import HierarchicalScenarioManager

manager = HierarchicalScenarioManager()
server = EmulatedLifxServer(
    devices,
    "127.0.0.1",
    56700,
    scenario_manager=manager
)

# Now scenario management API is available
```

### `persist_scenarios`

Enable persistent storage of scenario configurations.

**Type:** `bool`

**Default:** `False`

**Notes:**

- When enabled, scenario configurations are saved to `~/.lifx-emulator/scenarios.json`
- Scenarios are restored from disk on startup
- Requires `scenario_manager` to be provided
- Ignored if `scenario_manager` is `None`

**Example:**

```python
# Enable both state and scenario persistence
server = EmulatedLifxServer(
    devices,
    "127.0.0.1",
    56700,
    storage=storage,
    scenario_manager=manager,
    persist_scenarios=True
)
```

## Methods

### Lifecycle Methods

#### `async start()`

Start the UDP server and begin accepting connections.

**Notes:**

- Call this method before sending any packets to the emulator
- Binds to the configured address and port
- Logs server startup information
- Required if not using context manager

**Example:**

```python
server = EmulatedLifxServer(devices, "127.0.0.1", 56700)
await server.start()
try:
    # Use server
    pass
finally:
    await server.stop()
```

#### `async stop()`

Stop the UDP server and clean up resources.

**Notes:**

- Gracefully closes the UDP endpoint
- Cleans up internal state
- Safe to call multiple times
- Automatically called by context manager

### Context Manager Protocol

The server implements the async context manager protocol for clean resource management:

#### `async __aenter__()`

Enter async context manager - automatically calls `start()`.

#### `async __aexit__()`

Exit async context manager - automatically calls `stop()`.

**Recommended Usage:**

```python
async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    # Server is automatically started
    # Perform your tests
    pass
# Server is automatically stopped
```

### Utility Methods

#### `get_uptime_ns()`

Get the server uptime in nanoseconds since startup.

**Returns:** `int` - Nanoseconds elapsed since server started

**Notes:**

- Returns 0 if server hasn't started yet
- Useful for performance testing and benchmarking
- Uses monotonic clock for accurate timing

**Example:**

```python
async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    await asyncio.sleep(1)
    uptime_ns = server.get_uptime_ns()
    uptime_ms = uptime_ns / 1_000_000
    print(f"Server uptime: {uptime_ms:.2f}ms")
```

#### `invalidate_scenario_cache()`

Clear the internal scenario precedence cache.

**Notes:**

- Normally called automatically after scenario updates via API
- Only needed if modifying scenario manager state outside of API
- Safe to call - no side effects
- Non-blocking operation

**Example:**

```python
manager = HierarchicalScenarioManager()
server = EmulatedLifxServer(devices, "127.0.0.1", 56700, scenario_manager=manager)

async with server:
    # Update scenarios externally
    manager.set_global_scenario(ScenarioConfig(...))
    # Invalidate cache to apply changes immediately
    server.invalidate_scenario_cache()
```

## Packet Routing

### Broadcast Packets

Packets with `tagged=True` or `target=000000000000` are forwarded to all devices:

```python
# GetService broadcasts are answered by all devices
# Client discovers all emulated devices
```

### Targeted Packets

Packets with a specific target serial are routed to that device:

```python
# LightSetColor for d073d5000001 goes only to that device
# Other devices don't see the packet
```

### Unknown Targets

Packets for unknown serial addresses are silently dropped:

```python
# Packet for d073d5999999 (not in server) is ignored
# No error or response generated
```

## Response Handling

The server handles responses automatically:

1. Device processes packet and returns response(s)
1. Server packs response packets to bytes
1. Server sends responses back to source address
1. Multiple responses (e.g., multizone StateMultiZone) are sent sequentially

## Concurrency

The server uses asyncio for concurrent operation:

```python
# Multiple clients can send packets concurrently
# Each device processes packets independently
# Responses are sent asynchronously
```

## Error Handling

The server handles errors gracefully:

- Invalid packets are logged and dropped
- Device exceptions are caught and logged
- Server continues running despite errors
- Malformed headers don't crash the server

## Lifecycle

### Startup

1. Create UDP endpoint
1. Bind to address and port
1. Start receiving packets
1. Log server start

### Runtime

1. Receive packet bytes
1. Parse header
1. Route to device(s)
1. Get responses
1. Send responses

### Shutdown

1. Stop accepting packets
1. Close UDP endpoint
1. Clean up resources
1. Log server stop

## Testing Integration

### pytest-asyncio

```python
import pytest
from lifx_emulator import EmulatedLifxServer, create_color_light

@pytest.fixture
async def lifx_server():
    device = create_color_light("d073d5000001")
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)

    async with server:
        yield server

@pytest.mark.asyncio
async def test_discovery(lifx_server):
    # Test code using the server
    pass
```

### Module-Scoped Fixture

For faster tests, use module scope:

```python
@pytest.fixture(scope="module")
async def lifx_server():
    devices = [create_color_light(f"d073d500000{i}") for i in range(5)]
    server = EmulatedLifxServer(devices, "127.0.0.1", 56700)

    async with server:
        yield server
```

## Next Steps

- [Device API](../device/) - EmulatedLifxDevice documentation
- [Factory Functions](../factories/) - Device creation
- [Integration Testing Tutorial](../../tutorials/03-integration/) - Integration test examples

# Protocol API Reference

> LIFX LAN Protocol implementation - packet types, headers, and serialization

The protocol module provides a complete implementation of the LIFX LAN binary protocol, including packet definitions, header parsing, type serialization, and packet registry management.

______________________________________________________________________

## Table of Contents

### Core Components

- [LifxHeader](#lifxheader) - Packet header structure
- [Packet Types](#packet-types) - Protocol packet definitions
- [Protocol Types](#protocol-types) - Structured data types (HSBK, TileState, etc.)
- [Packet Registry](#packet-registry) - Mapping packet type numbers to classes

### Concepts

- [Binary Format Overview](#binary-format-overview)
- [Serialization and Deserialization](#serialization-and-deserialization)
- [Working with Packets](#working-with-packets)
- [Type Conversion](#type-conversion)

______________________________________________________________________

## LifxHeader

The LIFX protocol header is a 36-byte structure that precedes every packet payload.

### Structure

```python
@dataclass
class LifxHeader:
    # Frame
    size: int = 0                # Total packet size (header + payload)
    origin: int = 0              # Message origin (always 0)
    tagged: bool = False         # Broadcast flag (True = all devices)
    addressable: bool = True     # Addressable flag (always True)
    protocol: int = 1024         # Protocol number (always 1024)
    source: int = 0              # Unique client identifier

    # Frame Address
    target: bytes = b'\x00' * 8  # 6-byte serial + 2 null bytes
    ack_required: bool = False   # Request acknowledgment
    res_required: bool = False   # Request response
    sequence: int = 0            # Message sequence number (0-255)

    # Protocol Header
    pkt_type: int = 0            # Packet type number (e.g., 2, 101, 116)
```

### Key Fields

#### `tagged` (bool)

- **`True`**: Broadcast packet - sent to all devices on network
- **`False`**: Unicast packet - sent to specific device (requires valid `target`)

#### `target` (bytes)

- 8-byte field: 6-byte device serial + 2 null bytes
- Example: `b'\xd0\x73\xd5\x00\x00\x01\x00\x00'` for serial `d073d5000001`
- All zeros (`b'\x00' * 8`) when `tagged=True`

#### `ack_required` (bool)

- **`True`**: Device must send acknowledgment (packet type 45)
- **`False`**: No acknowledgment needed

#### `res_required` (bool)

- **`True`**: Device must send response packet (e.g., `State` for `Get`)
- **`False`**: No response packet expected

#### `source` (int)

- 32-bit client identifier
- Used to match responses to requests
- Should be unique per client instance

#### `sequence` (int)

- 8-bit sequence number (0-255, wraps around)
- Used to match responses to specific requests
- Client should increment for each request

#### `pkt_type` (int)

- Identifies the packet payload type
- Common types: 2 (`GetService`), 101 (`Get`), 102 (`SetColor`), 107 (`State`), etc.

### Methods

#### `pack() -> bytes`

Serialize header to 36-byte binary format.

**Returns:** `bytes` - 36-byte header

**Example:**

```python
from lifx_emulator.protocol.header import LifxHeader

header = LifxHeader(
    size=36,
    source=12345,
    target=bytes.fromhex("d073d5000001") + b'\x00\x00',
    res_required=True,
    sequence=1,
    pkt_type=101,  # Light.Get
)
raw_header = header.pack()
# Returns: 36 bytes
```

#### `unpack(data: bytes) -> LifxHeader`

Parse 36 bytes into a LifxHeader object.

**Parameters:**

- **`data`** (`bytes`) - 36-byte header data

**Returns:** `LifxHeader` - Parsed header object

**Example:**

```python
raw_header = sock.recv(36)
header = LifxHeader.unpack(raw_header)
print(f"Packet type: {header.pkt_type}")
print(f"Source: {header.source}")
print(f"Target: {header.target.hex()}")
```

______________________________________________________________________

## Packet Types

The protocol module provides classes for all LIFX protocol packets, organized into namespaces:

### Packet Organization

```python
from lifx_emulator.protocol.packets import Device, Light, MultiZone, Tile, Relay, Hev

# Device discovery and information
Device.GetService             # Type 2
Device.StateService           # Type 3
Device.GetHostInfo            # Type 12
Device.StateHostInfo          # Type 13
Device.GetVersion             # Type 32
Device.StateVersion           # Type 33
Device.GetLocation            # Type 48
Device.StateLocation          # Type 50
Device.GetGroup               # Type 51
Device.StateGroup             # Type 53
Device.Acknowledgement        # Type 45
Device.EchoRequest            # Type 58
Device.EchoResponse           # Type 59

# Light control (all color-capable devices)
Light.Get                     # Type 101
Light.SetColor                # Type 102
Light.SetWaveform             # Type 103
Light.State                   # Type 107
Light.GetPower                # Type 116
Light.SetPower                # Type 117
Light.StatePower              # Type 118
Light.GetInfrared             # Type 120 (infrared devices only)
Light.SetInfrared             # Type 122
Light.StateInfrared           # Type 121

# Multizone control (strips/beams)
MultiZone.SetColorZones       # Type 501
MultiZone.GetColorZones       # Type 502
MultiZone.StateZone           # Type 503
MultiZone.StateMultiZone      # Type 506
MultiZone.SetMultiZoneEffect  # Type 508
MultiZone.GetMultiZoneEffect  # Type 509
MultiZone.StateMultiZoneEffect # Type 510

# Extended multizone (>16 zones)
MultiZone.SetExtendedColorZones       # Type 510
MultiZone.GetExtendedColorZones       # Type 511
MultiZone.StateExtendedColorZones     # Type 512

# Tile/Matrix control (2D arrangements)
Tile.GetDeviceChain           # Type 701
Tile.StateDeviceChain         # Type 702
Tile.Get64                    # Type 707
Tile.State64                  # Type 711
Tile.Set64                    # Type 715
Tile.SetUserPosition          # Type 703
Tile.GetTileEffect            # Type 718
Tile.SetTileEffect            # Type 719
Tile.StateTileEffect          # Type 720

# HEV (germicidal light)
Hev.GetCycle                  # Type 142
Hev.SetCycle                  # Type 143
Hev.StateCycle                # Type 144
Hev.GetConfiguration          # Type 145
Hev.StateConfiguration        # Type 146
```

### Packet Class Structure

Each packet class has:

- **`PKT_TYPE`**: Class constant with packet type number
- **`pack()`**: Serialize to binary format
- **`unpack(data)`**: Parse from binary format

### Example: Light.SetColor

```python
from lifx_emulator.protocol.packets import Light
from lifx_emulator.protocol.protocol_types import LightHsbk

# Create SetColor packet
packet = Light.SetColor(
    reserved=0,
    color=LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500),
    duration_ms=1000,
)

# Serialize to bytes
raw_payload = packet.pack()

# Parse from bytes
received_packet = Light.SetColor.unpack(raw_payload)
print(f"Color: H={received_packet.color.hue} S={received_packet.color.saturation}")
print(f"Duration: {received_packet.duration_ms}ms")
```

### Example: MultiZone.GetColorZones

```python
from lifx_emulator.protocol.packets import MultiZone

# Request zones 0-7
packet = MultiZone.GetColorZones(
    start_index=0,
    end_index=7,
)

raw_payload = packet.pack()
```

### Example: Tile.Get64

```python
from lifx_emulator.protocol.packets import Tile

# Request 8x8 rectangle starting at (0,0) from tile 0
packet = Tile.Get64(
    tile_index=0,
    length=1,      # Not used for Get64
    rect_x=0,
    rect_y=0,
    rect_width=8,
)

raw_payload = packet.pack()
```

______________________________________________________________________

## Protocol Types

Protocol types are structured data types used within packets.

### LightHsbk

HSBK color representation (Hue, Saturation, Brightness, Kelvin).

```python
@dataclass
class LightHsbk:
    hue: int          # 0-65535 (0¬∞ to 360¬∞)
    saturation: int   # 0-65535 (0% to 100%)
    brightness: int   # 0-65535 (0% to 100%)
    kelvin: int       # 1500-9000 (color temperature)
```

**Color Conversion:**

- **Hue**: `degrees * 65535 / 360`
- **Saturation**: `percent * 65535 / 100`
- **Brightness**: `percent * 65535 / 100`
- **Kelvin**: Absolute value (e.g., 3500 for warm white)

**Examples:**

```python
from lifx_emulator.protocol.protocol_types import LightHsbk

# Red at 50% brightness
red = LightHsbk(hue=0, saturation=65535, brightness=32768, kelvin=3500)

# Green at full brightness
green = LightHsbk(hue=21845, saturation=65535, brightness=65535, kelvin=3500)

# Blue at 75% brightness
blue = LightHsbk(hue=43690, saturation=65535, brightness=49152, kelvin=3500)

# Warm white (no color)
warm_white = LightHsbk(hue=0, saturation=0, brightness=65535, kelvin=2700)

# Cool white (no color)
cool_white = LightHsbk(hue=0, saturation=0, brightness=65535, kelvin=6500)
```

### TileStateDevice

Tile position and metadata in a matrix chain.

```python
@dataclass
class TileStateDevice:
    accel_meas_x: int
    accel_meas_y: int
    accel_meas_z: int
    user_x: float         # User-configured X position
    user_y: float         # User-configured Y position
    width: int            # Tile width in pixels (e.g., 8)
    height: int           # Tile height in pixels (e.g., 8)
    device_version_vendor: int
    device_version_product: int
    device_version_version: int
    firmware_build: int
    firmware_version_minor: int
    firmware_version_major: int
```

### Enums

The protocol defines several enums for packet fields:

```python
from lifx_emulator.protocol.protocol_types import (
    DeviceService,
    LightWaveform,
    LightLastHevCycleResult,
    MultiZoneEffectType,
    MultiZoneApplicationRequest,
    TileEffectType,
)

# Service types
DeviceService.UDP                          # 1

# Waveform types for Light.SetWaveform
LightWaveform.SAW                          # 0
LightWaveform.SINE                         # 1
LightWaveform.HALF_SINE                    # 2
LightWaveform.TRIANGLE                     # 3
LightWaveform.PULSE                        # 4

# Multizone effects
MultiZoneEffectType.OFF                    # 0
MultiZoneEffectType.MOVE                   # 1

# Tile effects
TileEffectType.OFF                         # 0
TileEffectType.MORPH                       # 2
TileEffectType.FLAME                       # 3
```

______________________________________________________________________

## Packet Registry

The `PACKET_REGISTRY` maps packet type numbers to packet classes.

### Usage

```python
from lifx_emulator.protocol.packets import PACKET_REGISTRY, get_packet_class

# Get packet class by type number
packet_class = PACKET_REGISTRY[102]  # Light.SetColor
print(packet_class.PKT_TYPE)  # 102

# Or use the helper function
packet_class = get_packet_class(102)

# Parse unknown packet type
raw_payload = receive_payload()
packet_class = get_packet_class(header.pkt_type)
if packet_class:
    packet = packet_class.unpack(raw_payload)
else:
    print(f"Unknown packet type: {header.pkt_type}")
```

### Complete Packet Type List

| Type | Packet                              | Description                |
| ---- | ----------------------------------- | -------------------------- |
| 2    | `Device.GetService`                 | Device discovery request   |
| 3    | `Device.StateService`               | Device discovery response  |
| 12   | `Device.GetHostInfo`                | Get host MCU info          |
| 13   | `Device.StateHostInfo`              | Host MCU info response     |
| 14   | `Device.GetHostFirmware`            | Get host firmware          |
| 15   | `Device.StateHostFirmware`          | Host firmware response     |
| 16   | `Device.GetWifiInfo`                | Get WiFi info              |
| 17   | `Device.StateWifiInfo`              | WiFi info response         |
| 18   | `Device.GetWifiFirmware`            | Get WiFi firmware          |
| 19   | `Device.StateWifiFirmware`          | WiFi firmware response     |
| 20   | `Device.GetPower`                   | Get device power           |
| 21   | `Device.SetPower`                   | Set device power           |
| 22   | `Device.StatePower`                 | Device power response      |
| 23   | `Device.GetLabel`                   | Get device label           |
| 24   | `Device.SetLabel`                   | Set device label           |
| 25   | `Device.StateLabel`                 | Device label response      |
| 32   | `Device.GetVersion`                 | Get firmware version       |
| 33   | `Device.StateVersion`               | Firmware version response  |
| 34   | `Device.GetInfo`                    | Get device info            |
| 35   | `Device.StateInfo`                  | Device info response       |
| 45   | `Device.Acknowledgement`            | Acknowledgment response    |
| 48   | `Device.GetLocation`                | Get location               |
| 50   | `Device.StateLocation`              | Location response          |
| 51   | `Device.GetGroup`                   | Get group                  |
| 53   | `Device.StateGroup`                 | Group response             |
| 58   | `Device.EchoRequest`                | Echo request               |
| 59   | `Device.EchoResponse`               | Echo response              |
| 101  | `Light.Get`                         | Get light state            |
| 102  | `Light.SetColor`                    | Set color                  |
| 103  | `Light.SetWaveform`                 | Set waveform effect        |
| 107  | `Light.State`                       | Light state response       |
| 116  | `Light.GetPower`                    | Get light power            |
| 117  | `Light.SetPower`                    | Set light power            |
| 118  | `Light.StatePower`                  | Light power response       |
| 120  | `Light.GetInfrared`                 | Get IR brightness          |
| 121  | `Light.StateInfrared`               | IR brightness response     |
| 122  | `Light.SetInfrared`                 | Set IR brightness          |
| 142  | `Hev.GetCycle`                      | Get HEV cycle              |
| 143  | `Hev.SetCycle`                      | Set HEV cycle              |
| 144  | `Hev.StateCycle`                    | HEV cycle response         |
| 501  | `MultiZone.SetColorZones`           | Set zone colors            |
| 502  | `MultiZone.GetColorZones`           | Get zone colors            |
| 503  | `MultiZone.StateZone`               | Single zone response       |
| 506  | `MultiZone.StateMultiZone`          | Multiple zones response    |
| 508  | `MultiZone.SetMultiZoneEffect`      | Set zone effect            |
| 509  | `MultiZone.GetMultiZoneEffect`      | Get zone effect            |
| 510  | `MultiZone.StateMultiZoneEffect`    | Zone effect response       |
| 511  | `MultiZone.GetExtendedColorZones`   | Get extended zones         |
| 512  | `MultiZone.StateExtendedColorZones` | Extended zones response    |
| 513  | `MultiZone.SetExtendedColorZones`   | Set extended zones         |
| 701  | `Tile.GetDeviceChain`               | Get tile chain info        |
| 702  | `Tile.StateDeviceChain`             | Tile chain response        |
| 703  | `Tile.SetUserPosition`              | Set tile position          |
| 707  | `Tile.Get64`                        | Get tile colors (64 zones) |
| 711  | `Tile.State64`                      | Tile colors response       |
| 715  | `Tile.Set64`                        | Set tile colors            |
| 718  | `Tile.GetTileEffect`                | Get tile effect            |
| 719  | `Tile.SetTileEffect`                | Set tile effect            |
| 720  | `Tile.StateTileEffect`              | Tile effect response       |

______________________________________________________________________

## Binary Format Overview

### Packet Structure

Every LIFX packet consists of:

1. **Header** (36 bytes) - See [LifxHeader](#lifxheader)
1. **Payload** (variable length) - Packet-specific data

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Header (36 bytes)           ‚îÇ
‚îÇ  - Frame (8 bytes)                  ‚îÇ
‚îÇ  - Frame Address (16 bytes)         ‚îÇ
‚îÇ  - Protocol Header (12 bytes)       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ         Payload (variable)          ‚îÇ
‚îÇ  - Packet-specific fields           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Header Binary Layout

```text
Bytes 0-1:   Size (uint16, little-endian)
Bytes 2-3:   Protocol/Origin/Tagged/Addressable (bitfield)
Bytes 4-7:   Source (uint32, little-endian)
Bytes 8-15:  Target (6-byte MAC + 2 reserved bytes)
Bytes 16-21: Reserved
Byte  22:    Ack/Res flags + reserved bits
Byte  23:    Sequence (uint8)
Bytes 24-31: Reserved
Bytes 32-33: Packet type (uint16, little-endian)
Bytes 34-35: Reserved
```

### Payload Encoding

Payload fields are serialized using little-endian byte order:

- **Integers**: `uint8`, `uint16`, `uint32`, `uint64`
- **Floats**: `float32` (IEEE 754)
- **Booleans**: `uint8` (0=False, 1=True)
- **Strings**: UTF-8 encoded, null-padded to fixed length
- **Bytes**: Raw byte arrays
- **Nested types**: Recursively serialized structures
- **Arrays**: Consecutive serialized elements

______________________________________________________________________

## Serialization and Deserialization

### Packing (Python ‚Üí Binary)

```python
from lifx_emulator.protocol.header import LifxHeader
from lifx_emulator.protocol.packets import Light
from lifx_emulator.protocol.protocol_types import LightHsbk

# Create header
header = LifxHeader(
    size=0,  # Will be calculated
    source=12345,
    target=bytes.fromhex("d073d5000001") + b'\x00\x00',
    res_required=True,
    sequence=1,
    pkt_type=102,  # SetColor
)

# Create packet
packet = Light.SetColor(
    reserved=0,
    color=LightHsbk(hue=21845, saturation=65535, brightness=32768, kelvin=3500),
    duration_ms=1000,
)

# Pack to binary
payload = packet.pack()
header.size = 36 + len(payload)
header_bytes = header.pack()

# Send over UDP
full_packet = header_bytes + payload
sock.sendto(full_packet, (device_ip, 56700))
```

### Unpacking (Binary ‚Üí Python)

```python
from lifx_emulator.protocol.header import LifxHeader
from lifx_emulator.protocol.packets import get_packet_class

# Receive packet
data, addr = sock.recvfrom(1024)

# Parse header
header = LifxHeader.unpack(data[:36])
print(f"Received packet type: {header.pkt_type}")

# Parse payload
packet_class = get_packet_class(header.pkt_type)
if packet_class:
    payload_data = data[36:]
    packet = packet_class.unpack(payload_data)
    print(f"Packet: {packet}")
else:
    print(f"Unknown packet type: {header.pkt_type}")
```

______________________________________________________________________

## Working with Packets

### Complete Request/Response Example

```python
import socket
from lifx_emulator.protocol.header import LifxHeader
from lifx_emulator.protocol.packets import Light
from lifx_emulator.protocol.protocol_types import LightHsbk

# Create UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.settimeout(2.0)

# Build GetService request (discovery)
header = LifxHeader(
    size=36,
    tagged=True,  # Broadcast
    source=12345,
    res_required=True,
    sequence=1,
    pkt_type=2,  # GetService
)

# Send discovery
sock.sendto(header.pack(), ('<broadcast>', 56700))

# Receive StateService response
data, addr = sock.recvfrom(1024)
resp_header = LifxHeader.unpack(data[:36])
print(f"Device found at {addr}: serial={resp_header.target[:6].hex()}")

# Get light state
header = LifxHeader(
    size=36,
    source=12345,
    target=resp_header.target,
    res_required=True,
    sequence=2,
    pkt_type=101,  # Light.Get
)
sock.sendto(header.pack(), addr)

# Receive Light.State response
data, addr = sock.recvfrom(1024)
resp_header = LifxHeader.unpack(data[:36])
state = Light.State.unpack(data[36:])
print(f"Color: H={state.color.hue} S={state.color.saturation} B={state.color.brightness}")
print(f"Power: {state.power}")
print(f"Label: {state.label}")

sock.close()
```

### Handling Acknowledgments

```python
# Request acknowledgment
header = LifxHeader(
    size=36 + len(payload),
    source=12345,
    target=device_target,
    ack_required=True,  # Request ack
    res_required=False,  # Don't need state response
    sequence=3,
    pkt_type=117,  # SetPower
)

sock.sendto(header.pack() + payload, addr)

# Wait for acknowledgment (type 45)
data, addr = sock.recvfrom(1024)
ack_header = LifxHeader.unpack(data[:36])
if ack_header.pkt_type == 45:
    print("Command acknowledged")
```

______________________________________________________________________

## Type Conversion

### HSBK to RGB

```python
import colorsys

def hsbk_to_rgb(hsbk: LightHsbk) -> tuple[int, int, int]:
    """Convert HSBK to RGB (0-255 range)."""
    h = hsbk.hue / 65535.0  # 0-1
    s = hsbk.saturation / 65535.0  # 0-1
    v = hsbk.brightness / 65535.0  # 0-1

    r, g, b = colorsys.hsv_to_rgb(h, s, v)
    return int(r * 255), int(g * 255), int(b * 255)
```

### RGB to HSBK

```python
import colorsys

def rgb_to_hsbk(r: int, g: int, b: int, kelvin: int = 3500) -> LightHsbk:
    """Convert RGB (0-255) to HSBK."""
    h, s, v = colorsys.rgb_to_hsv(r / 255.0, g / 255.0, b / 255.0)

    return LightHsbk(
        hue=int(h * 65535),
        saturation=int(s * 65535),
        brightness=int(v * 65535),
        kelvin=kelvin,
    )
```

### Percentage Conversions

```python
def percent_to_uint16(percent: float) -> int:
    """Convert percentage (0-100) to uint16 (0-65535)."""
    return int(percent * 65535 / 100)

def uint16_to_percent(value: int) -> float:
    """Convert uint16 (0-65535) to percentage (0-100)."""
    return value * 100 / 65535
```

______________________________________________________________________

## References

**Source Files:**

- `src/lifx_emulator/protocol/header.py` - Header implementation
- `src/lifx_emulator/protocol/packets.py` - Packet definitions (auto-generated)
- `src/lifx_emulator/protocol/protocol_types.py` - Type definitions (auto-generated)
- `src/lifx_emulator/protocol/serializer.py` - Serialization utilities
- `src/lifx_emulator/protocol/generator.py` - Code generator from YAML spec

**Related Documentation:**

- [Device API](../device/) - Device state and packet processing
- [Server API](../server/) - UDP server implementation
- [LIFX LAN Protocol Specification](https://lan.developer.lifx.com/) - Official protocol docs
- [Architecture Overview](../../architecture/overview/) - System architecture

**Protocol Specification:**

- Auto-generated from [LIFX public-protocol](https://github.com/LIFX/public-protocol)
- Generator: `src/lifx_emulator/protocol/generator.py`
- Source: `protocol.yml` from LIFX/public-protocol repository

# Storage API Reference

> Persistent storage for device state across emulator restarts

The storage module provides asynchronous persistent storage of device state using JSON files on disk. When enabled, device state (color, power, label, zones, tiles, etc.) is automatically saved and restored across emulator sessions with high-performance non-blocking I/O.

______________________________________________________________________

## Table of Contents

### Core Components

- [AsyncDeviceStorage](#asyncdevicestorage) - Async storage handler class
- [File Format](#file-format) - JSON state file specification
- [State Serialization](#state-serialization) - Converting state to/from JSON

### Concepts

- [Storage Location](#storage-location) - Where files are stored
- [Device Lifecycle](#device-lifecycle) - State save/load during device lifecycle
- [Backup and Restore](#backup-and-restore) - Managing saved states
- [CLI Integration](#cli-integration) - Using persistent storage from CLI

______________________________________________________________________

## AsyncDeviceStorage

Main class for handling asynchronous persistent device state storage with smart debouncing and batch writes.

### Constructor

#### `AsyncDeviceStorage(storage_dir: Path | str = DEFAULT_STORAGE_DIR, debounce_ms: int = 100, batch_size_threshold: int = 50)`

Initialize an async storage handler for device state persistence.

**Parameters:**

- **`storage_dir`** (`Path | str`) - Directory to store state files (default: `~/.lifx-emulator`)
- **`debounce_ms`** (`int`) - Milliseconds to wait before flushing pending saves (default: 100ms)
- **`batch_size_threshold`** (`int`) - Flush early if queue exceeds this size (default: 50)

**Example:**

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

# Use default location (~/.lifx-emulator)
storage = AsyncDeviceStorage()

# Use custom location with custom debounce settings
storage = AsyncDeviceStorage(
    "/var/lib/lifx-emulator",
    debounce_ms=200,
    batch_size_threshold=100
)
```

### Methods

#### `async save_device_state(device_state: DeviceState) -> None`

Queue device state for saving (non-blocking async).

Queues the device state for saving. The write is performed asynchronously with debouncing to minimize I/O overhead.

**Parameters:**

- **`device_state`** (`DeviceState`) - Device state to persist

**Returns:** `None` (task runs in background)

**Example:**

```python
import asyncio
from lifx_emulator.devices import DeviceState
from lifx_emulator.async_storage import AsyncDeviceStorage

async def main():
    state = DeviceState(serial="d073d5000001", label="Living Room", power_level=65535)
    storage = AsyncDeviceStorage()

    # Queue state for async save (non-blocking)
    await storage.save_device_state(state)

    # File will be created at: ~/.lifx-emulator/d073d5000001.json

asyncio.run(main())
```

#### `load_device_state(serial: str) -> dict[str, Any] | None`

Load device state from disk (synchronous).

Reads the JSON file for the specified serial and returns the deserialized state dictionary. Returns `None` if the file doesn't exist or cannot be loaded.

**Parameters:**

- **`serial`** (`str`) - Device serial to load

**Returns:** `dict[str, Any] | None` - State dictionary or `None` if not found

**Example:**

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()
state_dict = storage.load_device_state("d073d5000001")

if state_dict:
    print(f"Label: {state_dict['label']}")
    print(f"Power: {state_dict['power_level']}")
else:
    print("No saved state found")
```

#### `delete_device_state(serial: str) -> None`

Delete saved state for a device (synchronous).

Removes the JSON file for the specified serial from disk.

**Parameters:**

- **`serial`** (`str`) - Device serial to delete

**Returns:** `None`

**Example:**

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()
storage.delete_device_state("d073d5000001")
# Removes: ~/.lifx-emulator/d073d5000001.json
```

#### `list_devices() -> list[str]`

List all devices with saved state (synchronous).

Returns a list of device serials that have saved state files in the storage directory.

**Returns:** `list[str]` - List of device serials

**Example:**

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()
devices = storage.list_devices()
print(f"Found {len(devices)} saved devices:")
for serial in devices:
    print(f"  - {serial}")
```

#### `delete_all_device_states() -> int`

Delete all saved device states (synchronous).

Removes all `.json` files from the storage directory.

**Returns:** `int` - Number of devices deleted

**Example:**

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()
count = storage.delete_all_device_states()
print(f"Deleted {count} device states")
```

______________________________________________________________________

## File Format

Device state is saved as JSON files with the naming convention `{serial}.json`.

### JSON Structure

```json
{
  "serial": "d073d5000001",
  "product": 27,
  "label": "Living Room Light",
  "power_level": 65535,
  "color": {
    "hue": 21845,
    "saturation": 65535,
    "brightness": 32768,
    "kelvin": 3500
  },
  "location_id": "01234567-89ab-cdef-0123-456789abcdef",
  "location_label": "Home",
  "group_id": "fedcba98-7654-3210-fedc-ba9876543210",
  "group_label": "Living Room",
  "infrared_brightness": 0,
  "hev_cycle_duration_s": 7200,
  "hev_cycle_remaining_s": 0,
  "zone_count": 0,
  "zone_colors": [],
  "tile_count": 0,
  "tile_devices": []
}
```

### Multizone Device Example

```json
{
  "serial": "d073d5000002",
  "product": 32,
  "label": "Kitchen Strip",
  "power_level": 65535,
  "color": {
    "hue": 0,
    "saturation": 0,
    "brightness": 65535,
    "kelvin": 3500
  },
  "zone_count": 16,
  "zone_colors": [
    {"hue": 0, "saturation": 65535, "brightness": 32768, "kelvin": 3500},
    {"hue": 21845, "saturation": 65535, "brightness": 32768, "kelvin": 3500},
    ...
  ]
}
```

### Matrix Device Example

```json
{
  "serial": "d073d5000003",
  "product": 55,
  "label": "Wall Art",
  "power_level": 65535,
  "tile_count": 5,
  "tile_width": 8,
  "tile_height": 8,
  "tile_devices": [
    {
      "user_x": 0.0,
      "user_y": 0.0,
      "width": 8,
      "height": 8,
      "colors": [...]
    },
    ...
  ]
}
```

______________________________________________________________________

## State Serialization

The `state_serializer` module handles conversion between DeviceState objects and JSON-compatible dictionaries.

### `serialize_device_state(device_state: DeviceState) -> dict`

Convert DeviceState to JSON-compatible dictionary.

**Parameters:**

- **`device_state`** (`DeviceState`) - State to serialize

**Returns:** `dict` - JSON-compatible dictionary

**Example:**

```python
from lifx_emulator.devices import DeviceState
from lifx_emulator.state_serializer import serialize_device_state

state = DeviceState(serial="d073d5000001", label="Test Light")
state_dict = serialize_device_state(state)
# state_dict is JSON-compatible dict
```

### `deserialize_device_state(state_dict: dict) -> dict`

Convert JSON dictionary back to DeviceState-compatible format.

**Parameters:**

- **`state_dict`** (`dict`) - Serialized state dictionary

**Returns:** `dict` - Deserialized state dictionary

**Example:**

```python
from lifx_emulator.state_serializer import deserialize_device_state

loaded_dict = storage.load_device_state("d073d5000001")
if loaded_dict:
    # Already deserialized by load_device_state
    print(f"Label: {loaded_dict['label']}")
```

______________________________________________________________________

## Storage Location

### Default Location

By default, device state files are stored in:

- **Linux/macOS**: `~/.lifx-emulator/`
- **Windows**: `C:\Users\{username}\.lifx-emulator\`

### Custom Location

You can specify a custom storage directory:

```python
from pathlib import Path
from lifx_emulator.async_storage import AsyncDeviceStorage

# Project-specific storage
storage = AsyncDeviceStorage("./lifx_state")

# System-wide storage (requires permissions)
storage = AsyncDeviceStorage("/var/lib/lifx-emulator")

# Temporary storage (for testing)
import tempfile
storage = AsyncDeviceStorage(tempfile.mkdtemp())
```

______________________________________________________________________

## Device Lifecycle

### State Restoration on Device Creation

When creating a device with storage enabled, existing state is automatically restored:

```python
from lifx_emulator.factories import create_color_light
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()

# First run: Create device and save state
device = create_color_light(serial="d073d5000001", storage=storage)
device.state.label = "Living Room"
device.state.power_level = 65535
await storage.save_device_state(device.state)  # Queue async save

# Later run: State is automatically restored
device = create_color_light(serial="d073d5000001", storage=storage)
print(device.state.label)  # "Living Room"
print(device.state.power_level)  # 65535
```

### Automatic State Saving

Device state is automatically saved when:

- Device properties are updated via protocol packets (SetColor, SetPower, SetLabel, etc.)
- Device is properly shut down (via context manager or explicit save)

**Example with automatic saving:**

```python
from lifx_emulator.devices import EmulatedLifxDevice, DeviceState
from lifx_emulator.async_storage import AsyncDeviceStorage
from lifx_emulator.protocol.header import LifxHeader
from lifx_emulator.protocol.packets import Light
from lifx_emulator.protocol.protocol_types import LightHsbk

storage = AsyncDeviceStorage()
state = DeviceState(serial="d073d5000001")
device = EmulatedLifxDevice(state, storage=storage)

# Simulate SetLabel packet
header = LifxHeader(pkt_type=24, source=1, sequence=1)
packet = Light.SetLabel(label="Kitchen Light")
device.process_packet(header, packet)

# State is automatically saved after processing
# Restarting the emulator will restore "Kitchen Light" label
```

### Manual State Management

For fine-grained control, use manual save/load:

```python
import asyncio

# Manual async save
await storage.save_device_state(device.state)

# Manual load (during initialization)
state_dict = storage.load_device_state(serial)
if state_dict:
    # Apply loaded state to device
    device.state.label = state_dict['label']
    device.state.power_level = state_dict['power_level']
    # ... etc
```

______________________________________________________________________

## Backup and Restore

### Creating Backups

```python
import shutil
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()

# Backup entire storage directory
shutil.copytree(storage.storage_dir, "/backup/lifx-emulator-backup")

# Backup single device
device_path = storage.storage_dir / "d073d5000001.json"
shutil.copy(device_path, "/backup/d073d5000001.json.bak")
```

### Restoring from Backup

```python
import shutil

# Restore entire storage directory
shutil.copytree("/backup/lifx-emulator-backup", "~/.lifx-emulator", dirs_exist_ok=True)

# Restore single device
shutil.copy("/backup/d073d5000001.json.bak", "~/.lifx-emulator/d073d5000001.json")
```

### Exporting Device State

```python
import json
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()

# Export all device states to a single file
all_states = {}
for serial in storage.list_devices():
    state = storage.load_device_state(serial)
    if state:
        all_states[serial] = state

with open("lifx-export.json", "w") as f:
    json.dump(all_states, f, indent=2)
```

### Importing Device State

```python
import json
from lifx_emulator.async_storage import AsyncDeviceStorage
from lifx_emulator.devices import DeviceState

storage = AsyncDeviceStorage()

# Import from exported file
with open("lifx-export.json") as f:
    all_states = json.load(f)

for serial, state_dict in all_states.items():
    # Create device state and save
    state = DeviceState(**state_dict)
    storage.save_device_state(state)

print(f"Imported {len(all_states)} devices")
```

______________________________________________________________________

## CLI Integration

### Enabling Persistent Storage from CLI

Use the `--persistent` flag to enable state persistence:

```bash
# Enable persistence with default location (~/.lifx-emulator)
lifx-emulator --persistent

# Create devices and modify state
# State changes are automatically saved

# Stop and restart emulator - state is restored
lifx-emulator --persistent
```

### Viewing Saved Devices

```bash
# List saved devices
ls ~/.lifx-emulator/

# View device state
cat ~/.lifx-emulator/d073d5000001.json

# Pretty print
python -m json.tool ~/.lifx-emulator/d073d5000001.json
```

### Clearing Persistent Storage

```bash
# Remove all saved states
rm -rf ~/.lifx-emulator/

# Remove specific device
rm ~/.lifx-emulator/d073d5000001.json
```

### Programmatic CLI Access

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

storage = AsyncDeviceStorage()

# List devices
print("Saved devices:")
for serial in storage.list_devices():
    state = storage.load_device_state(serial)
    if state:
        print(f"  {serial}: {state.get('label', 'Unnamed')}")

# Clear all
count = storage.delete_all_device_states()
print(f"Cleared {count} device states")
```

______________________________________________________________________

## Best Practices

### 1. Always Use Same Serial Numbers

For state persistence to work, devices must use consistent serial numbers:

```python
# Good: Fixed serial
device = create_color_light(serial="d073d5000001", storage=storage)

# Bad: Random serial (state won't persist)
import uuid
device = create_color_light(serial=uuid.uuid4().hex[:12], storage=storage)
```

### 2. Handle Storage Errors Gracefully

Storage operations may fail due to permissions, disk space, etc:

```python
try:
    storage.save_device_state(device.state)
except Exception as e:
    logger.error("Failed to save state: %s", e)
    # Continue without persistence
```

### 3. Validate Restored State

Always validate restored state before using it:

```python
state_dict = storage.load_device_state(serial)
if state_dict:
    # Validate product ID matches
    if state_dict.get('product') != expected_product:
        logger.warning("Product ID mismatch, ignoring saved state")
        state_dict = None
```

### 4. Use Context Managers for Cleanup

Ensure state is saved on cleanup:

```python
import asyncio
from contextlib import asynccontextmanager

@asynccontextmanager
async def managed_device(serial, storage):
    device = create_color_light(serial=serial, storage=storage)
    try:
        yield device
    finally:
        # Ensure state is saved on exit
        await storage.save_device_state(device.state)

async def main():
    async with managed_device("d073d5000001", storage) as device:
        # Use device
        device.state.power_level = 65535
    # State automatically saved on exit

asyncio.run(main())
```

### 5. Regular Backups

For production use, create regular backups:

```bash
#!/bin/bash
# Backup script
BACKUP_DIR="/backup/lifx-emulator/$(date +%Y%m%d)"
mkdir -p "$BACKUP_DIR"
cp -r ~/.lifx-emulator/* "$BACKUP_DIR/"
echo "Backed up to $BACKUP_DIR"
```

______________________________________________________________________

## Troubleshooting

### State Not Persisting

**Problem:** Changes aren't saved between restarts

**Solutions:**

1. Verify `--persistent` flag is used
1. Check storage directory exists and is writable
1. Ensure consistent serial numbers
1. Check logs for save errors

```python
import logging
logging.basicConfig(level=logging.DEBUG)
# Will show "Saved state for device..." messages
```

### Permission Errors

**Problem:** Cannot write to storage directory

**Solutions:**

1. Check directory permissions: `ls -la ~/.lifx-emulator`
1. Use custom directory with proper permissions
1. Run with appropriate user permissions

### Corrupted State Files

**Problem:** Invalid JSON or deserialization errors

**Solutions:**

```python
# Validate and repair
import json
from pathlib import Path

storage_dir = Path.home() / ".lifx-emulator"
for file_path in storage_dir.glob("*.json"):
    try:
        with open(file_path) as f:
            json.load(f)
        print(f"‚úì {file_path.name}")
    except json.JSONDecodeError:
        print(f"‚úó {file_path.name} - CORRUPTED")
        # Delete or repair
        file_path.unlink()
```

______________________________________________________________________

## References

**Source Files:**

- `src/lifx_emulator/storage.py` - Storage implementation
- `src/lifx_emulator/state_serializer.py` - State serialization
- `src/lifx_emulator/async_storage.py` - Async storage variant

**Related Documentation:**

- [Device API](../device/) - Device state structure
- [CLI Reference](../../getting-started/cli/) - Using `--persistent` flag
- [Getting Started](../../getting-started/quickstart/) - Quick start with persistence
- [Best Practices](../../guide/best-practices/) - Storage best practices

**See Also:**

- Persistent storage is optional and disabled by default
- Storage uses standard JSON format for easy inspection and editing
- State files can be manually edited (stop emulator first)
- Storage directory can be version controlled for test fixtures

# Products API Reference

> LIFX product registry and capability detection

The products module provides auto-generated product definitions from the official LIFX product registry, including product IDs, capabilities, temperature ranges, and device specifications. This enables accurate emulation of specific LIFX device types.

______________________________________________________________________

## Table of Contents

### Core Components

- [ProductInfo](#productinfo) - Product metadata and capabilities
- [ProductCapability](#productcapability) - Capability flags enum
- [Product Registry](#product-registry) - Accessing product database
- [ProductSpecs](#productspecs) - Device-specific specifications

### Concepts

- [Capability Matrix](#capability-matrix) - Complete product capabilities
- [Product Filtering](#product-filtering) - Query products by capability
- [Using Products](#using-products) - Creating devices from products

______________________________________________________________________

## ProductInfo

Dataclass containing complete information about a LIFX product.

```python
@dataclass
class ProductInfo:
    pid: int                              # Product ID
    name: str                             # Product name (e.g., "LIFX A19")
    vendor: int                           # Vendor ID (always 1 for LIFX)
    capabilities: int                     # Bitfield of capabilities
    temperature_range: TemperatureRange | None  # Min/max Kelvin
    min_ext_mz_firmware: int | None       # Min firmware for extended multizone
```

### Fields

#### `pid` (int)

Product ID number. Common examples:

- `27`: LIFX A19
- `32`: LIFX Z (multizone strip)
- `38`: LIFX Beam (extended multizone)
- `55`: LIFX Tile
- `90`: LIFX Clean (HEV)

#### `name` (str)

Human-readable product name (e.g., "LIFX A19", "LIFX Z", "LIFX Tile").

#### `vendor` (int)

Vendor ID. Always `1` for LIFX products.

#### `capabilities` (int)

Bitfield of `ProductCapability` flags. Use `has_capability()` or property methods to check.

#### `temperature_range` (TemperatureRange | None)

Supported color temperature range in Kelvin.

- `min`: Minimum Kelvin (e.g., 2500 for warm white)
- `max`: Maximum Kelvin (e.g., 9000 for cool white)
- `None` for non-color-temperature devices (relays, switches)

#### `min_ext_mz_firmware` (int | None)

Minimum firmware version required for extended multizone support (>16 zones).

- `None` if not applicable or always supported

### Methods

#### `has_capability(capability: ProductCapability) -> bool`

Check if product has a specific capability.

**Parameters:**

- **`capability`** (`ProductCapability`) - Capability to check

**Returns:** `bool` - `True` if product has the capability

**Example:**

```python
from lifx_emulator.products import get_product, ProductCapability

product = get_product(32)  # LIFX Z
if product.has_capability(ProductCapability.MULTIZONE):
    print(f"{product.name} supports multizone")
```

#### Property Methods

Convenience properties for common capability checks:

- **`has_color`** ‚Üí `bool` - Full RGB color support
- **`has_infrared`** ‚Üí `bool` - Infrared (night vision) support
- **`has_multizone`** ‚Üí `bool` - Multizone (linear strips) support
- **`has_chain`** ‚Üí `bool` - Device chaining support
- **`has_matrix`** ‚Üí `bool` - 2D matrix/tile support
- **`has_relays`** ‚Üí `bool` - Relay switches
- **`has_buttons`** ‚Üí `bool` - Physical buttons
- **`has_hev`** ‚Üí `bool` - HEV (germicidal light) support
- **`has_extended_multizone`** ‚Üí `bool` - Extended multizone (>16 zones)

**Example:**

```python
product = get_product(55)  # LIFX Tile
print(f"Color: {product.has_color}")         # True
print(f"Matrix: {product.has_matrix}")       # True
print(f"Multizone: {product.has_multizone}") # False
```

#### `supports_extended_multizone(firmware_version: int | None = None) -> bool`

Check if extended multizone is supported for a given firmware version.

**Parameters:**

- **`firmware_version`** (`int | None`) - Firmware version to check (optional)

**Returns:** `bool` - `True` if extended multizone is supported

**Example:**

```python
product = get_product(38)  # LIFX Beam
if product.supports_extended_multizone():
    print("Supports 80 zones!")
```

______________________________________________________________________

## ProductCapability

Enum of capability flags used in product definitions.

```python
class ProductCapability(IntEnum):
    COLOR = 1               # Full RGB color
    INFRARED = 2            # Night vision IR
    MULTIZONE = 4           # Linear zones (strips)
    CHAIN = 8               # Device chaining
    MATRIX = 16             # 2D tile grid
    RELAYS = 32             # Relay switches
    BUTTONS = 64            # Physical buttons
    HEV = 128               # Germicidal light
    EXTENDED_MULTIZONE = 256  # >16 zones
```

### Usage

```python
from lifx_emulator.products import ProductCapability

# Check multiple capabilities
capabilities = ProductCapability.COLOR | ProductCapability.INFRARED
has_color = bool(capabilities & ProductCapability.COLOR)        # True
has_multizone = bool(capabilities & ProductCapability.MULTIZONE) # False
```

______________________________________________________________________

## Product Registry

The `PRODUCTS` dictionary and helper functions provide access to the product database.

### `get_product(pid: int) -> ProductInfo | None`

Retrieve product information by product ID.

**Parameters:**

- **`pid`** (`int`) - Product ID

**Returns:** `ProductInfo | None` - Product information or `None` if not found

**Example:**

```python
from lifx_emulator.products import get_product

product = get_product(27)  # LIFX A19
if product:
    print(f"Product: {product.name}")
    print(f"Capabilities: {product.capabilities}")
    print(f"Temperature range: {product.temperature_range.min}-{product.temperature_range.max}K")
```

### `get_registry() -> dict[int, ProductInfo]`

Get the complete product registry.

**Returns:** `dict[int, ProductInfo]` - Mapping of product ID to ProductInfo

**Example:**

```python
from lifx_emulator.products import get_registry

registry = get_registry()
print(f"Total products: {len(registry)}")

for pid, product in registry.items():
    if product.has_multizone:
        print(f"{pid}: {product.name}")
```

### `get_device_class_name(product: ProductInfo) -> str`

Get the device class name based on capabilities.

**Parameters:**

- **`product`** (`ProductInfo`) - Product to classify

**Returns:** `str` - Device class name ("color", "multizone", "matrix", "hev", etc.)

**Example:**

```python
from lifx_emulator.products import get_product, get_device_class_name

product = get_product(32)
class_name = get_device_class_name(product)
print(f"Device class: {class_name}")  # "multizone"
```

______________________________________________________________________

## ProductSpecs

Device-specific specifications (zone counts, tile dimensions, etc.) are stored in the specs system.

### `get_product_specs(product_id: int) -> dict | None`

Get detailed specifications for a product.

**Parameters:**

- **`product_id`** (`int`) - Product ID

**Returns:** `dict | None` - Specifications dictionary or `None`

**Spec Fields:**

- `zone_count`: Number of zones (multizone devices)
- `extended_multizone`: Extended multizone support flag
- `tile_count`: Default number of tiles (matrix devices)
- `tile_width`: Tile width in pixels (matrix devices)
- `tile_height`: Tile height in pixels (matrix devices)

**Example:**

```python
from lifx_emulator.specs import get_product_specs

# LIFX Z (standard multizone)
specs = get_product_specs(32)
print(f"Zones: {specs['zone_count']}")  # 16

# LIFX Beam (extended multizone)
specs = get_product_specs(38)
print(f"Zones: {specs['zone_count']}")           # 80
print(f"Extended: {specs['extended_multizone']}") # True

# LIFX Tile
specs = get_product_specs(55)
print(f"Tiles: {specs['tile_count']}")     # 5
print(f"Dimensions: {specs['tile_width']}x{specs['tile_height']}")  # 8x8
```

______________________________________________________________________

## Capability Matrix

Complete capability matrix for major LIFX products:

| Product ID | Name                    | Color | Infrared | Multizone | Extended MZ | Matrix | HEV | Temp Range (K) |
| ---------- | ----------------------- | ----- | -------- | --------- | ----------- | ------ | --- | -------------- |
| 1          | LIFX Original 1000      | ‚úì     |          |           |             |        |     | 2500-9000      |
| 27         | LIFX A19                | ‚úì     |          |           |             |        |     | 2500-9000      |
| 29         | LIFX A19 Night Vision   | ‚úì     | ‚úì        |           |             |        |     | 2500-9000      |
| 32         | LIFX Z                  | ‚úì     |          | ‚úì         |             |        |     | 2500-9000      |
| 36         | LIFX Downlight          | ‚úì     |          |           |             |        |     | 2500-9000      |
| 38         | LIFX Beam               | ‚úì     |          | ‚úì         | ‚úì           |        |     | 2500-9000      |
| 43         | LIFX BR30               | ‚úì     |          |           |             |        |     | 2500-9000      |
| 44         | LIFX BR30 Night Vision  | ‚úì     | ‚úì        |           |             |        |     | 2500-9000      |
| 50         | LIFX Mini White to Warm |       |          |           |             |        |     | 2700-6500      |
| 55         | LIFX Tile               | ‚úì     |          |           |             | ‚úì      |     | 2500-9000      |
| 57         | LIFX Candle             | ‚úì     |          |           |             | ‚úì      |     | 2500-9000      |
| 66         | LIFX GU10               | ‚úì     |          |           |             |        |     | 2500-9000      |
| 90         | LIFX Clean              | ‚úì     |          |           |             |        | ‚úì   | 2500-9000      |
| 141        | LIFX Neon               | ‚úì     |          | ‚úì         |             |        |     | 2500-9000      |
| 176        | LIFX Ceiling            | ‚úì     |          |           |             | ‚úì      |     | 2500-9000      |

**Legend:**

- **Color**: Full RGB color control
- **Infrared**: Night vision capability
- **Multizone**: Linear zone control (up to 16 zones)
- **Extended MZ**: Extended multizone (>16 zones)
- **Matrix**: 2D tile/matrix control
- **HEV**: Germicidal UV-C light
- **Temp Range**: Color temperature range in Kelvin

______________________________________________________________________

## Product Filtering

Filter products by capabilities using the registry:

### Filter by Single Capability

```python
from lifx_emulator.products import get_registry, ProductCapability

registry = get_registry()

# Find all multizone products
multizone_products = [
    product for product in registry.values()
    if product.has_multizone
]

for product in multizone_products:
    print(f"{product.pid}: {product.name}")
# Output: 32: LIFX Z, 38: LIFX Beam, 141: LIFX Neon, etc.
```

### Filter by Multiple Capabilities

```python
# Find all color + infrared products
color_ir_products = [
    product for product in registry.values()
    if product.has_color and product.has_infrared
]

for product in color_ir_products:
    print(f"{product.pid}: {product.name}")
# Output: 29: LIFX A19 Night Vision, 44: LIFX BR30 Night Vision
```

### Filter by Temperature Range

```python
# Find products that support warm white (< 3000K)
warm_white_products = [
    product for product in registry.values()
    if product.temperature_range and product.temperature_range.min < 3000
]

for product in warm_white_products:
    print(f"{product.pid}: {product.name} ({product.temperature_range.min}K)")
```

### Filter Extended Multizone

```python
# Find extended multizone products (>16 zones)
extended_mz_products = [
    product for product in registry.values()
    if product.has_extended_multizone
]

for product in extended_mz_products:
    print(f"{product.pid}: {product.name}")
# Output: 38: LIFX Beam, etc.
```

### Custom Filter Function

```python
def filter_products(
    color: bool = False,
    multizone: bool = False,
    matrix: bool = False,
    hev: bool = False,
) -> list[ProductInfo]:
    """Filter products by capabilities."""
    registry = get_registry()
    results = []

    for product in registry.values():
        if color and not product.has_color:
            continue
        if multizone and not product.has_multizone:
            continue
        if matrix and not product.has_matrix:
            continue
        if hev and not product.has_hev:
            continue
        results.append(product)

    return results

# Usage
matrix_products = filter_products(matrix=True)
color_multizone = filter_products(color=True, multizone=True)
```

______________________________________________________________________

## Using Products

### Creating Devices from Product IDs

```python
from lifx_emulator.factories import create_device
from lifx_emulator.products import get_product

# Create device by product ID
device = create_device(product_id=27)  # LIFX A19

# Get product info
product = get_product(27)
print(f"Created: {product.name}")
print(f"Color: {device.state.has_color}")
print(f"Multizone: {device.state.has_multizone}")
```

### Using Product Specs for Configuration

```python
from lifx_emulator.factories import create_device
from lifx_emulator.specs import get_product_specs

# Create LIFX Z with product defaults
device = create_device(product_id=32)

# Specs are automatically applied
specs = get_product_specs(32)
assert device.state.zone_count == specs['zone_count']  # 16 zones

# Override defaults
device = create_device(product_id=32, zone_count=8)  # Custom: 8 zones
```

### Listing Available Products

Command-line tool to list all products:

```bash
# List all products
lifx-emulator list-products

# Filter by capability
lifx-emulator list-products --filter-type multizone
lifx-emulator list-products --filter-type matrix
lifx-emulator list-products --filter-type hev
```

**Example Output:**

```text
LIFX Product Registry
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ID   ‚îÇ Product Name                               ‚îÇ Capabilities             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 27   ‚îÇ LIFX A19                                   ‚îÇ full color               ‚îÇ
‚îÇ 29   ‚îÇ LIFX A19 Night Vision                      ‚îÇ full color, infrared     ‚îÇ
‚îÇ 32   ‚îÇ LIFX Z                                     ‚îÇ full color, multizone    ‚îÇ
‚îÇ 38   ‚îÇ LIFX Beam                                  ‚îÇ full color, extended-mz  ‚îÇ
‚îÇ 55   ‚îÇ LIFX Tile                                  ‚îÇ full color, matrix       ‚îÇ
‚îÇ 90   ‚îÇ LIFX Clean                                 ‚îÇ full color, HEV          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Programmatic Product Listing

```python
from lifx_emulator.products import get_registry

def list_products(filter_capability: str | None = None):
    """List all products with optional capability filter."""
    registry = get_registry()

    for pid, product in sorted(registry.items()):
        # Apply filter
        if filter_capability == "multizone" and not product.has_multizone:
            continue
        if filter_capability == "matrix" and not product.has_matrix:
            continue
        if filter_capability == "hev" and not product.has_hev:
            continue

        # Print product info
        capabilities = []
        if product.has_color:
            capabilities.append("color")
        if product.has_infrared:
            capabilities.append("infrared")
        if product.has_multizone:
            capabilities.append("multizone")
        if product.has_extended_multizone:
            capabilities.append("extended-mz")
        if product.has_matrix:
            capabilities.append("matrix")
        if product.has_hev:
            capabilities.append("HEV")

        print(f"{pid:3d}  {product.name:40s}  {', '.join(capabilities)}")

# Usage
list_products()
list_products(filter_capability="matrix")
```

______________________________________________________________________

## Product Data Source

The product registry is auto-generated from the official LIFX product database:

- **Source:** [LIFX/products on GitHub](https://github.com/LIFX/products)
- **Generator:** `src/lifx_emulator/products/generator.py`
- **Registry:** `src/lifx_emulator/products/registry.py` (auto-generated)
- **Specs:** `src/lifx_emulator/specs/` (manually curated device specifications)

### Updating Products

To update the product registry with the latest LIFX products:

```bash
# Run the generator (fetches latest from GitHub)
python -m lifx_emulator.products.generator

# Verify changes
git diff src/lifx_emulator/products/registry.py
```

______________________________________________________________________

## References

**Source Files:**

- `src/lifx_emulator/products/registry.py` - Product registry (auto-generated)
- `src/lifx_emulator/products/generator.py` - Registry generator
- `src/lifx_emulator/specs/` - Product specifications

**Related Documentation:**

- [Factories API](../factories/) - Device creation from product IDs
- [Device API](../device/) - Device capabilities and state
- [Device Types Guide](../../guide/device-types/) - Supported device types
- [CLI Reference](../../getting-started/cli/) - Command-line product usage

**External Resources:**

- [LIFX Products GitHub](https://github.com/LIFX/products) - Official product database
- [LIFX Developer Docs](https://lan.developer.lifx.com/) - Protocol specification
# Advanced Topics

# Advanced Features

Power-user features for sophisticated testing scenarios.

## Overview

This section covers advanced emulator features for complex testing needs. These features are optional but powerful for:

- Maintaining device state across test runs
- Runtime device management
- Comprehensive error simulation
- Complex multi-scenario testing

## Prerequisites

Before exploring advanced features, you should:

- Be comfortable with basic emulator usage
- Have completed at least the first 2-3 tutorials
- Understand your testing requirements
- Be familiar with REST APIs (for API features)

## Learning Path

Read these guides in order from simple to complex:

1. **[Persistent Storage](storage/)** - Save device state across restarts
1. **[Device Management API](device-management-api/)** - Add/remove devices at runtime
1. **[Scenarios](scenarios/)** - Comprehensive error simulation concepts
1. **[Scenario API](scenario-api/)** - REST API for managing test scenarios

## Quick Concepts

### Persistent Storage

Save device state (colors, labels, power) across emulator restarts:

```bash
lifx-emulator --persistent
```

Device states are saved to `~/.lifx-emulator/` and automatically restored.

üëâ **[Storage Guide](storage/)**

### Device Management API

Enable the HTTP API to manage devices at runtime:

```bash
lifx-emulator --api
```

Access the web dashboard at `http://localhost:8080` or use the REST API to add/remove devices dynamically.

üëâ **[Device Management Guide](device-management-api/)**

### Testing Scenarios

Configure error conditions for comprehensive testing:

- Packet loss (test retries)
- Response delays (test timeouts)
- Malformed data (test error handling)
- Firmware version overrides

üëâ **[Scenarios Guide](scenarios/)**

### Scenario API

Manage scenarios via REST API with hierarchical scoping:

```bash
# Drop 100% of GetColor packets for all color devices
curl -X PUT http://localhost:8080/api/scenarios/types/color \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 1.0}}'
```

Supports device-specific, type-based, location-based, group-based, and global scenarios.

üëâ **[Scenario API Reference](scenario-api/)**

## Feature Comparison

| Feature            | Basic | Advanced      |
| ------------------ | ----- | ------------- |
| Create devices     | ‚úÖ    | ‚úÖ            |
| Device discovery   | ‚úÖ    | ‚úÖ            |
| Control devices    | ‚úÖ    | ‚úÖ            |
| State persistence  | ‚ùå    | ‚úÖ            |
| Runtime management | ‚ùå    | ‚úÖ            |
| Error simulation   | Basic | Comprehensive |
| Web UI             | ‚ùå    | ‚úÖ            |
| REST API           | ‚ùå    | ‚úÖ            |

## When to Use Advanced Features

### Use Persistent Storage When:

- Running long test suites where state matters
- Testing state restoration after failures
- Developing iteratively and want to preserve state
- Simulating real-world device persistence

### Use Device Management API When:

- Tests need dynamic device creation/removal
- Running multi-stage test scenarios
- Need visual monitoring during development
- Integrating with external test orchestration

### Use Scenarios When:

- Testing retry logic and error handling
- Simulating network issues (packet loss, delays)
- Testing edge cases (malformed data, timeouts)
- Validating firmware version compatibility
- Testing client resilience

## Combined Example

Use multiple advanced features together:

```bash
# Start with persistence, API, and scenarios
lifx-emulator --persistent --api --color 2

# Configure global scenario for packet loss
curl -X PUT http://localhost:8080/api/scenarios/global \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 0.3}}'  # 30% packet loss

# Add device at runtime
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{"product_id": 32, "zone_count": 16}'

# Run your tests...
# State persists across restarts
```

## Next Steps

Choose a topic based on your needs, or read through all guides in order for comprehensive understanding.

# Persistent Storage Guide

> Save and restore device state across emulator sessions

The LIFX Emulator supports optional persistent storage that automatically saves device state (color, power, labels, zone colors, etc.) to disk and restores it when the emulator restarts.

## Overview

With persistent storage enabled, device state survives emulator restarts, making it useful for:

- Testing long-running applications with stateful devices
- Preserving test setup between development sessions
- Simulating real-world device behavior where state persists

## Quick Start

Enable persistent storage from the CLI:

```bash
# Start emulator with persistent storage
lifx-emulator --persistent

# State will be saved and restored across restarts
```

Or from Python:

```python
import asyncio
from lifx_emulator import EmulatedLifxServer, create_color_light
from lifx_emulator.async_storage import AsyncDeviceStorage

async def main():
    # Create storage handler
    storage = AsyncDeviceStorage()

    # Create device with storage
    device = create_color_light("d073d5000001", storage=storage)

    # State changes are automatically saved
    device.state.label = "My Light"
    device.state.color.hue = 21845  # 120 degrees

    # Start server
    server = EmulatedLifxServer([device], "127.0.0.1", 56700)
    await server.start()

    # Device state will be restored on next run with same serial

asyncio.run(main())
```

## Storage Location

By default, device state is stored in `~/.lifx-emulator/`:

```bash
~/.lifx-emulator/
‚îú‚îÄ‚îÄ d073d5000001.json  # State for first device
‚îú‚îÄ‚îÄ d073d5000002.json  # State for second device
‚îî‚îÄ‚îÄ d073d8000001.json  # State for multizone device
```

### Custom Storage Directory

```python
from lifx_emulator.async_storage import AsyncDeviceStorage

# Use custom directory
storage = AsyncDeviceStorage("/var/lib/lifx-emulator")

# Now state files will be stored in /var/lib/lifx-emulator/
```

## What Gets Saved

The following device state is persisted:

- **Label** - Device name
- **Power Level** - On/off and brightness
- **Color** - Hue, saturation, brightness, kelvin (for color lights)
- **Location** - Device location
- **Group** - Device group
- **Zone Colors** - Individual zone colors (for multizone devices)
- **Tile Colors** - Individual tile colors (for matrix devices)
- **Infrared Brightness** - IR brightness level (for IR capable devices)
- **HEV State** - HEV cycle state (for HEV capable devices)

## State File Format

Device state is stored as JSON:

```json
{
  "serial": "d073d5000001",
  "product_id": 27,
  "label": "Living Room Light",
  "power_level": 65535,
  "color": {
    "hue": 21845,
    "saturation": 65535,
    "brightness": 32768,
    "kelvin": 4000
  },
  "location": "Living Room",
  "group": "Main Lights",
  "zone_colors": [],
  "tile_devices": [],
  "infrared_brightness": 0,
  "hev_state": null
}
```

## Restoration on Startup

When a device is created with the same serial as a previously saved device, its state is automatically restored:

```python
from lifx_emulator.async_storage import AsyncDeviceStorage
from lifx_emulator import create_color_light

storage = AsyncDeviceStorage()

# First session - state is created
device1 = create_color_light("d073d5000001", storage=storage)
device1.state.label = "Kitchen Light"
device1.state.color.hue = 10923  # Orange

# State changes are automatically queued for saving
# (saved asynchronously with debouncing)

# Later session - state is restored
device2 = create_color_light("d073d5000001", storage=storage)
assert device2.state.label == "Kitchen Light"
assert device2.state.color.hue == 10923
```

## Automatic Saving

Device state is automatically saved (asynchronously) after certain operations:

```python
device = create_color_light("d073d5000001", storage=storage)

# These automatically trigger async saves with debouncing:
# - Color changes (via protocol packets)
# - Power state changes
# - Label changes
# - Group/Location changes

# AsyncDeviceStorage queues saves and flushes with debouncing
# to minimize I/O overhead (default: 100ms debounce)
```

The `AsyncDeviceStorage` class provides high-performance non-blocking saves by:

- **Debouncing**: Coalescing rapid changes to the same device
- **Batch writes**: Grouping multiple devices in single flush
- **Executor-based I/O**: Running I/O in background thread
- **Adaptive flushing**: Flushing early if queue size threshold is reached

## Advanced Usage

### Managing Multiple Devices

```python
from lifx_emulator.async_storage import AsyncDeviceStorage
from lifx_emulator import create_color_light, create_multizone_light

storage = AsyncDeviceStorage()

# Create multiple devices - each maintains its own state file
devices = [
    create_color_light("d073d5000001", storage=storage),
    create_color_light("d073d5000002", storage=storage),
    create_multizone_light("d073d8000001", storage=storage),
]

# All state is independently persisted and restored asynchronously
```

### Clearing Saved State

```python
storage = AsyncDeviceStorage()

# Delete saved state for one device (synchronous)
storage.delete_device_state("d073d5000001")

# Delete all saved state
storage.delete_all_device_states()

# List all saved devices
devices = storage.list_devices()
```

### Backup and Restore

```bash
# Backup device state
cp -r ~/.lifx-emulator ~/.lifx-emulator.backup

# Restore from backup
cp -r ~/.lifx-emulator.backup/* ~/.lifx-emulator/
```

## Scenarios with Persistent Storage

Combine persistent storage with test scenarios:

```python
from lifx_emulator import create_color_light
from lifx_emulator.async_storage import AsyncDeviceStorage
from lifx_emulator.scenarios.manager import ScenarioConfig

storage = AsyncDeviceStorage()
device = create_color_light("d073d5000001", storage=storage)

# Configure scenario
device.scenarios = ScenarioConfig(
    response_delays={101: 0.5}  # 500ms delay on GetColor
)

# State + scenario config both persist across restarts
```

## Persistent Scenarios

In addition to device state, test scenarios can also be persisted:

```bash
# Enable both device state and scenario persistence
lifx-emulator --persistent --persistent-scenarios
```

This saves scenario configurations to `~/.lifx-emulator/scenarios.json`.

## API Reference

For complete API documentation, see:

- [Storage API Reference](../../api/storage/)
- [AsyncDeviceStorage class reference](../../api/storage/#asyncdevicestorage)
- [File format specification](../../api/storage/#file-format)

## Troubleshooting

### Saved State Not Loading

1. Check that the serial matches exactly (case-sensitive hex)
1. Verify the file exists: `ls ~/.lifx-emulator/`
1. Check file permissions: `ls -la ~/.lifx-emulator/`
1. Check for JSON syntax errors: `cat ~/.lifx-emulator/{serial}.json | python -m json.tool`

### Storage Directory Issues

```bash
# Ensure storage directory exists with proper permissions
mkdir -p ~/.lifx-emulator
chmod 700 ~/.lifx-emulator

# Check for disk space
df -h ~/.lifx-emulator
```

### Clearing All State

```bash
# Remove all saved state
rm -rf ~/.lifx-emulator/

# Or use the API
from lifx_emulator.async_storage import AsyncDeviceStorage
storage = AsyncDeviceStorage()
for serial in storage.list_devices():
    storage.delete_device_state(serial)
```

## Best Practices

1. **Use storage for integration tests** - Persist state across test sessions
1. **Back up important state** - Use `cp -r ~/.lifx-emulator ~/.lifx-emulator.backup`
1. **Clean up after tests** - Delete device state when tests complete
1. **Use meaningful serials** - Make it easy to identify saved devices
1. **Version your state** - Keep track of state changes in git if needed

## Next Steps

- [Testing Scenarios Guide](../../guide/testing-scenarios/) - Combine with error scenarios
- [Storage API Reference](../../api/storage/) - Detailed API documentation
- [Advanced Testing Guide](../../guide/integration-testing/) - Integration patterns

# Device Management API

## Overview

The LIFX Emulator provides a comprehensive REST API for monitoring server status and managing emulated devices. The API is built with FastAPI and provides an OpenAPI 3.1.0 compliant specification.

**Base URL**: `http://localhost:8080/api`

**Interactive Documentation**:

- Swagger UI: `http://localhost:8080/docs`
- ReDoc: `http://localhost:8080/redoc`
- OpenAPI Schema: `http://localhost:8080/openapi.json`

## Quick Start

### Enable the API Server

```bash
# Start emulator with API server
lifx-emulator --api

# Custom host and port
lifx-emulator --api --api-host 127.0.0.1 --api-port 9090

# Disable activity logging to reduce traffic
lifx-emulator --api --api-activity=false
```

### Basic Examples

```bash
# Get server statistics
curl http://localhost:8080/api/stats

# List all devices
curl http://localhost:8080/api/devices

# Create a new color light (product 27)
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{"product_id": 27}'

# Get specific device info
curl http://localhost:8080/api/devices/d073d5000001

# Delete a device
curl -X DELETE http://localhost:8080/api/devices/d073d5000001

# Get recent activity
curl http://localhost:8080/api/activity
```

______________________________________________________________________

## Monitoring Endpoints

### Get Server Statistics

```text
GET /api/stats
```

Returns server uptime, packet counts, error counts, and device count.

**Response (200 OK):**

```json
{
  "uptime_seconds": 123.45,
  "start_time": 1699564800.0,
  "device_count": 3,
  "packets_received": 1250,
  "packets_sent": 2100,
  "packets_received_by_type": {
    "2": 50,
    "101": 200,
    "102": 300
  },
  "packets_sent_by_type": {
    "3": 50,
    "107": 200,
    "116": 300
  },
  "error_count": 2,
  "activity_enabled": true
}
```

**Use Cases:**

- Monitor emulator health and uptime
- Track packet statistics by type
- Verify API is running
- Check error rates

______________________________________________________________________

### Get Recent Activity

```text
GET /api/activity
```

Returns the last 100 packet events (TX/RX) with timestamps and packet details.

**Response (200 OK):**

```json
[
  {
    "timestamp": 1699564923.456,
    "direction": "rx",
    "packet_type": 101,
    "packet_name": "GetColor",
    "device": "d073d5000001",
    "target": "00:00:00:00:00:00:00:00",
    "addr": "192.168.1.100:54321"
  },
  {
    "timestamp": 1699564923.457,
    "direction": "tx",
    "packet_type": 107,
    "packet_name": "State",
    "device": "d073d5000001",
    "target": "192.168.1.100",
    "addr": "192.168.1.100:54321"
  }
]
```

**Activity Event Fields:**

- `timestamp`: Unix timestamp of the packet
- `direction`: "rx" (received) or "tx" (transmitted)
- `packet_type`: Numeric packet type ID
- `packet_name`: Human-readable packet name
- `device`: Target device serial (if applicable)
- `target`: LIFX protocol target field
- `addr`: Client IP and port

**Use Cases:**

- Debugging LIFX client communication
- Verifying packet flow
- Monitoring protocol interactions
- Testing packet handling

**Note:** Activity logging must be enabled with `--api-activity` flag (default: true). Disable it to reduce traffic if not needed.

______________________________________________________________________

## Device Management Endpoints

### List All Devices

```text
GET /api/devices
```

Returns a list of all emulated devices with their current configuration.

**Response (200 OK):**

```json
[
  {
    "serial": "d073d5000001",
    "label": "Living Room Light",
    "product": 27,
    "vendor": 1,
    "power_level": 65535,
    "has_color": true,
    "has_infrared": false,
    "has_multizone": false,
    "has_extended_multizone": false,
    "has_matrix": false,
    "has_hev": false,
    "zone_count": 0,
    "tile_count": 0,
    "color": {
      "hue": 32768,
      "saturation": 65535,
      "brightness": 65535,
      "kelvin": 3500
    },
    "zone_colors": [],
    "tile_devices": [],
    "version_major": 3,
    "version_minor": 70,
    "build_timestamp": 0,
    "group_label": "",
    "location_label": "",
    "uptime_ns": 123000000000,
    "wifi_signal": -45.5
  }
]
```

**Device Info Fields:**

- `serial`: Unique device identifier (12-char hex string)
- `label`: Human-readable device label
- `product`: LIFX product ID
- `vendor`: Vendor ID (always 1 for LIFX)
- `power_level`: 0 (off) or 65535 (on)
- `has_*`: Boolean capability flags
- `zone_count`: Number of multizone zones (if multizone)
- `tile_count`: Number of tiles (if matrix device)
- `color`: Current HSBK color (if color-capable)
- `zone_colors`: Array of colors per zone (if multizone)
- `tile_devices`: Tile configuration and colors (if matrix)
- `version_major/minor`: Firmware version
- `build_timestamp`: Build timestamp (usually 0)
- `group_label`: Group assignment
- `location_label`: Location assignment
- `uptime_ns`: Device uptime in nanoseconds
- `wifi_signal`: WiFi signal strength in dBm

______________________________________________________________________

### Get Device Information

```text
GET /api/devices/{serial}
```

Returns detailed information about a specific device by its serial number.

**Path Parameters:**

- `serial`: Device serial number (e.g., `d073d5000001`)

**Response (200 OK):** Same as list devices, but for a single device.

**Error Response (404):**

```json
{
  "detail": "Device d073d5000001 not found"
}
```

**Example:**

```bash
curl http://localhost:8080/api/devices/d073d5000001
```

______________________________________________________________________

### Create Device

```text
POST /api/devices
```

Creates a new emulated device by product ID. The device will be added to the emulator immediately.

**Request Body:**

```json
{
  "product_id": 27,
  "serial": "d073d5000099",
  "zone_count": 16,
  "tile_count": 5,
  "tile_width": 8,
  "tile_height": 8,
  "firmware_major": 3,
  "firmware_minor": 70
}
```

**Request Fields:**

- `product_id` (required): LIFX product ID from registry
- `serial` (optional): Device serial (auto-generated if not provided)
- `zone_count` (optional): Number of zones for multizone devices
- `tile_count` (optional): Number of tiles for matrix devices
- `tile_width` (optional): Width of each tile in pixels
- `tile_height` (optional): Height of each tile in pixels
- `firmware_major` (optional): Firmware major version
- `firmware_minor` (optional): Firmware minor version

**Response (201 Created):** Same as get device response.

**Error Responses:**

- `400 Bad Request`: Invalid parameters

```json
{
  "detail": "Failed to create device: Invalid product ID 9999"
}
```

- `409 Conflict`: Duplicate serial

```json
{
  "detail": "Device with serial d073d5000001 already exists"
}
```

**Examples:**

```bash
# Create color light with auto-generated serial
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{"product_id": 27}'

# Create multizone device with specific zone count
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{
    "product_id": 32,
    "zone_count": 16
  }'

# Create tile device with specific count
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{
    "product_id": 55,
    "tile_count": 3
  }'

# Create device with specific serial
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{
    "product_id": 27,
    "serial": "d073d5cafe00"
  }'
```

______________________________________________________________________

### Delete Device

```text
DELETE /api/devices/{serial}
```

Removes an emulated device from the server. The device will stop responding to LIFX protocol packets.

**Path Parameters:**

- `serial`: Device serial number

**Response (204 No Content):** No response body.

**Error Response (404):**

```json
{
  "detail": "Device d073d5000001 not found"
}
```

**Example:**

```bash
curl -X DELETE http://localhost:8080/api/devices/d073d5000001
```

______________________________________________________________________

### Delete All Devices

```text
DELETE /api/devices
```

Removes all emulated devices from the server. All devices will stop responding to LIFX protocol packets.

**Response (200 OK):**

```json
{
  "deleted": 5,
  "message": "Removed 5 device(s) from server"
}
```

**Example:**

```bash
curl -X DELETE http://localhost:8080/api/devices
```

**Note:** This only removes devices from memory. Persistent state files remain intact.

______________________________________________________________________

### Clear Persistent Storage

```text
DELETE /api/storage
```

Deletes all persistent device state files from disk. This does not affect currently running devices, only saved state files.

**Response (200 OK):**

```json
{
  "deleted": 3,
  "message": "Deleted 3 device state(s) from persistent storage"
}
```

**Error Response (503):**

```json
{
  "detail": "Persistent storage is not enabled"
}
```

**Example:**

```bash
curl -X DELETE http://localhost:8080/api/storage
```

**Note:** Requires `--persistent` flag when starting the emulator.

______________________________________________________________________

## Code Examples

### Python

```python
import requests
import json

BASE_URL = "http://localhost:8080/api"

# Get server statistics
stats = requests.get(f"{BASE_URL}/stats").json()
print(f"Uptime: {stats['uptime_seconds']:.1f}s")
print(f"Devices: {stats['device_count']}")
print(f"Packets RX: {stats['packets_received']}")
print(f"Packets TX: {stats['packets_sent']}")

# List all devices
devices = requests.get(f"{BASE_URL}/devices").json()
for device in devices:
    print(f"\nDevice: {device['label']} ({device['serial']})")
    print(f"  Product: {device['product']}")
    print(f"  Power: {'ON' if device['power_level'] > 0 else 'OFF'}")
    if device['has_color']:
        color = device['color']
        print(f"  Color: H={color['hue']} S={color['saturation']} B={color['brightness']} K={color['kelvin']}")

# Create a new device
response = requests.post(
    f"{BASE_URL}/devices",
    json={"product_id": 27, "zone_count": 16}
)
if response.status_code == 201:
    device = response.json()
    print(f"Created device: {device['serial']}")

# Get recent activity
activity = requests.get(f"{BASE_URL}/activity").json()
for event in activity[-5:]:  # Last 5 events
    direction = "RX" if event['direction'] == "rx" else "TX"
    print(f"{direction} {event['packet_name']} from {event['addr']}")

# Delete a device
serial = devices[0]['serial']
requests.delete(f"{BASE_URL}/devices/{serial}")
print(f"Deleted device: {serial}")
```

### JavaScript/Node.js

```javascript
const BASE_URL = "http://localhost:8080/api";

// Get server statistics
async function getStats() {
    const response = await fetch(`${BASE_URL}/stats`);
    const stats = await response.json();
    console.log(`Uptime: ${stats.uptime_seconds.toFixed(1)}s`);
    console.log(`Devices: ${stats.device_count}`);
    console.log(`Packets RX: ${stats.packets_received}`);
    console.log(`Packets TX: ${stats.packets_sent}`);
}

// List all devices
async function listDevices() {
    const response = await fetch(`${BASE_URL}/devices`);
    const devices = await response.json();

    for (const device of devices) {
        console.log(`\nDevice: ${device.label} (${device.serial})`);
        console.log(`  Product: ${device.product}`);
        console.log(`  Power: ${device.power_level > 0 ? "ON" : "OFF"}`);
        if (device.has_color) {
            const c = device.color;
            console.log(`  Color: H=${c.hue} S=${c.saturation} B=${c.brightness} K=${c.kelvin}`);
        }
    }
}

// Create a new device
async function createDevice(productId) {
    const response = await fetch(`${BASE_URL}/devices`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ product_id: productId })
    });

    if (response.status === 201) {
        const device = await response.json();
        console.log(`Created device: ${device.serial}`);
        return device;
    } else {
        const error = await response.json();
        console.error(`Failed: ${error.detail}`);
    }
}

// Delete a device
async function deleteDevice(serial) {
    const response = await fetch(`${BASE_URL}/devices/${serial}`, {
        method: "DELETE"
    });

    if (response.status === 204) {
        console.log(`Deleted device: ${serial}`);
    } else {
        const error = await response.json();
        console.error(`Failed: ${error.detail}`);
    }
}

// Get recent activity
async function getActivity() {
    const response = await fetch(`${BASE_URL}/activity`);
    const activities = await response.json();

    console.log("Recent activity:");
    for (const event of activities.slice(-5)) {
        const dir = event.direction === "rx" ? "RX" : "TX";
        console.log(`  ${dir} ${event.packet_name} from ${event.addr}`);
    }
}

// Run examples
getStats();
listDevices();
createDevice(27);
getActivity();
```

### cURL

```bash
# Get stats (pretty-print with jq)
curl http://localhost:8080/api/stats | jq

# List devices
curl http://localhost:8080/api/devices | jq '.[] | {serial, label, product}'

# Create color light
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{"product_id": 27}' | jq '.serial'

# Create multizone device with 16 zones
curl -X POST http://localhost:8080/api/devices \
  -H "Content-Type: application/json" \
  -d '{"product_id": 32, "zone_count": 16}' | jq

# Get specific device
curl http://localhost:8080/api/devices/d073d5000001 | jq '{serial, label, power_level}'

# Get recent activity
curl http://localhost:8080/api/activity | jq '.[-5:] | .[] | {direction, packet_name, addr}'

# Delete device
curl -X DELETE http://localhost:8080/api/devices/d073d5000001 -v

# Delete all devices
curl -X DELETE http://localhost:8080/api/devices | jq
```

______________________________________________________________________

## Common Patterns

### Monitor Emulator Status

```python
import requests
import time

while True:
    try:
        stats = requests.get("http://localhost:8080/api/stats", timeout=2).json()
        print(f"Status: {stats['device_count']} devices, "
              f"{stats['packets_received']} RX, "
              f"{stats['packets_sent']} TX, "
              f"uptime {stats['uptime_seconds']:.0f}s")
    except:
        print("API unavailable")

    time.sleep(5)
```

### Maintain Minimum Device Count

```python
def ensure_min_devices(min_count, product_id):
    devices = requests.get(f"{BASE_URL}/devices").json()
    current = len(devices)

    if current < min_count:
        for i in range(min_count - current):
            requests.post(f"{BASE_URL}/devices",
                         json={"product_id": product_id})
            print(f"Created device {i+1}")
```

### Log Activity to File

```python
import json
from datetime import datetime

while True:
    activity = requests.get(f"{BASE_URL}/activity").json()

    for event in activity:
        log_entry = {
            "timestamp": datetime.fromtimestamp(event['timestamp']).isoformat(),
            "direction": event['direction'],
            "packet": event['packet_name'],
            "device": event['device'],
            "addr": event['addr']
        }

        with open("emulator_activity.jsonl", "a") as f:
            f.write(json.dumps(log_entry) + "\n")
```

______________________________________________________________________

## Error Handling

All error responses follow this format:

```json
{
  "detail": "Error message describing what went wrong"
}
```

**Common Status Codes:**

- `200 OK`: Successful GET/DELETE request with response body
- `201 Created`: Successful POST request (device creation)
- `204 No Content`: Successful DELETE request (no body)
- `400 Bad Request`: Invalid parameters or request body
- `404 Not Found`: Resource not found
- `409 Conflict`: Resource conflict (e.g., duplicate serial)
- `503 Service Unavailable`: Feature not enabled (e.g., storage)

______________________________________________________________________

## See Also

- [Web Interface Guide](../../guide/web-interface/) - Browser-based monitoring dashboard
- [Scenario Management API](../scenario-api/) - Test scenario configuration

# Custom Test Scenarios

> Simulate real-world conditions and protocol edge cases

Test scenarios allow you to configure the emulator to simulate various real-world conditions like packet loss, network delays, malformed packets, and more. This is useful for testing how your application handles protocol errors and network unreliability.

## Overview

Scenarios are organized in a hierarchical structure with automatic precedence resolution:

1. **Device-specific** - Affects single device by serial
1. **Type-specific** - Affects all devices of a type (color, multizone, etc.)
1. **Location-based** - Affects all devices in a location
1. **Group-based** - Affects all devices in a group
1. **Global** - Affects all devices

This allows fine-grained control over which devices experience which conditions.

## Quick Start

Configure a simple scenario via Python API:

```python
from lifx_emulator import create_color_light
from lifx_emulator.scenarios.manager import ScenarioConfig

device = create_color_light("d073d5000001")

# Drop 30% of GetColor packets
device.scenarios = ScenarioConfig(
    drop_packets={"101": 0.3}
)
```

Or via REST API:

```bash
# Set global scenario - drop 100% of GetColor packets
curl -X PUT http://localhost:8080/api/scenarios/global \
  -H "Content-Type: application/json" \
  -d '{
    "drop_packets": {"101": 1.0},
    "response_delays": {},
    "malformed_packets": [],
    "invalid_field_values": [],
    "firmware_version": null,
    "partial_responses": [],
    "send_unhandled": false
  }'
```

## Scenario Types

### Packet Dropping

Simulate packet loss by dropping incoming packets:

```python
from lifx_emulator.scenarios.manager import ScenarioConfig

# Drop 100% of GetColor packets
config = ScenarioConfig(drop_packets={"101": 1.0})

# Drop 30% probabilistically
config = ScenarioConfig(drop_packets={"101": 0.3})

# Drop multiple packet types
config = ScenarioConfig(drop_packets={"101": 1.0, "102": 0.5})
```

### Response Delays

Add latency to responses to simulate slow networks:

```python
# Add 500ms delay to all GetColor responses
config = ScenarioConfig(response_delays={"101": 0.5})

# Multiple delays
config = ScenarioConfig(response_delays={
    "101": 0.5,    # GetColor - 500ms
    "102": 0.2,    # SetColor - 200ms
    "116": 1.0,    # GetPower - 1000ms
})
```

### Malformed Packets

Send corrupted/truncated packets to test error handling:

```python
# Send truncated StateColor packets
config = ScenarioConfig(malformed_packets=[107])

# Multiple packet types
config = ScenarioConfig(malformed_packets=[107, 108, 110])
```

### Invalid Field Values

Send packets with invalid field values (all 0xFF bytes):

```python
# Send StateColor with all 0xFF values
config = ScenarioConfig(invalid_field_values=[107])
```

### Partial Responses

Send incomplete multizone/tile data:

```python
# Send only partial zone data
config = ScenarioConfig(partial_responses=[506])  # StateMultiZone
```

### Firmware Version Override

Simulate different firmware versions:

```python
# Simulate older firmware
config = ScenarioConfig(firmware_version=(2, 60))

# Simulate newer firmware
config = ScenarioConfig(firmware_version=(3, 90))
```

## Scenario Scope

### Global Scenarios

Apply to all devices:

```python
from lifx_emulator.scenarios.manager import HierarchicalScenarioManager

manager = HierarchicalScenarioManager()

manager.set_global_scenario(ScenarioConfig(
    drop_packets={"101": 1.0}
))

# All devices now drop GetColor packets
```

### Device-Specific Scenarios

Target individual devices by serial:

```python
# Only device d073d5000001 experiences delays
manager.set_device_scenario(
    "d073d5000001",
    ScenarioConfig(response_delays={"101": 0.5})
)
```

### Type-Specific Scenarios

Target all devices of a type:

```python
# All color devices drop GetColor packets
manager.set_type_scenario(
    "color",
    ScenarioConfig(drop_packets={"101": 0.3})
)

# All multizone devices get 500ms delay
manager.set_type_scenario(
    "multizone",
    ScenarioConfig(response_delays={"502": 0.5})
)

# Supported types: color, multizone, extended_multizone, matrix, hev, infrared, basic
```

### Location-Based Scenarios

Target all devices in a location:

```python
# All devices in "Kitchen" experience delays
manager.set_location_scenario(
    "Kitchen",
    ScenarioConfig(response_delays={"101": 0.2})
)
```

### Group-Based Scenarios

Target all devices in a group:

```python
# All devices in "Bedroom Lights" group
manager.set_group_scenario(
    "Bedroom Lights",
    ScenarioConfig(drop_packets={"101": 0.5})
)
```

## Scenario Precedence

When multiple scopes apply, precedence is:

1. **Device-specific** (highest priority)
1. **Type-specific**
1. **Location-based**
1. **Group-based**
1. **Global** (lowest priority)

Example:

```python
manager = HierarchicalScenarioManager()

# Global: drop 100% of GetColor
manager.set_global_scenario(
    ScenarioConfig(drop_packets={"101": 1.0})
)

# Type: multizone devices get 500ms delay
manager.set_type_scenario(
    "multizone",
    ScenarioConfig(response_delays={"502": 0.5})
)

# Device: d073d5000001 drops 50% of SetColor
manager.set_device_scenario(
    "d073d5000001",
    ScenarioConfig(drop_packets={"102": 0.5})
)

# Result for d073d5000001:
# - Drop 100% of GetColor (from global)
# - Drop 50% of SetColor (from device, overrides global)
# - 500ms delay for packet 502 (from type if multizone)
```

## REST API Examples

Full REST API documentation is in the [Scenario Management API guide](../scenario-api/).

### Get Current Scenario

```bash
# Get global scenario
curl http://localhost:8080/api/scenarios/global

# Get scenario for specific device
curl http://localhost:8080/api/scenarios/devices/d073d5000001

# Get scenario for device type
curl http://localhost:8080/api/scenarios/types/multizone
```

### Update Scenarios

```bash
# Set global scenario
curl -X PUT http://localhost:8080/api/scenarios/global \
  -H "Content-Type: application/json" \
  -d '{
    "drop_packets": {"101": 0.3},
    "response_delays": {"101": 0.2},
    "malformed_packets": [],
    "invalid_field_values": [],
    "firmware_version": null,
    "partial_responses": [],
    "send_unhandled": false
  }'

# Set device-specific scenario
curl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \
  -H "Content-Type: application/json" \
  -d '{
    "drop_packets": {"101": 1.0},
    "response_delays": {},
    "malformed_packets": [],
    "invalid_field_values": [],
    "firmware_version": [2, 60],
    "partial_responses": [],
    "send_unhandled": false
  }'
```

### Clear Scenarios

```bash
# Clear global scenario
curl -X DELETE http://localhost:8080/api/scenarios/global

# Clear device scenario
curl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000001

# Clear type scenario
curl -X DELETE http://localhost:8080/api/scenarios/types/multizone
```

## Practical Testing Patterns

### Testing Retry Logic

```python
# Simulate flaky network - drop 30% of packets
config = ScenarioConfig(drop_packets={"101": 0.3})

# Your client should retry and eventually succeed
```

### Testing Timeout Handling

```python
# Add 2 second delay to simulate slow device
config = ScenarioConfig(response_delays={"101": 2.0})

# Test that client timeout is > 2 seconds
```

### Testing Error Recovery

```python
# Send malformed responses
config = ScenarioConfig(malformed_packets=[107])

# Test that client handles parse errors gracefully
```

### Testing Firmware Compatibility

```python
# Simulate older firmware
config = ScenarioConfig(firmware_version=(2, 60))

# Test client behavior with older firmware

# Simulate newer firmware
config = ScenarioConfig(firmware_version=(3, 90))

# Test client with newer features
```

### Testing Concurrent Operations

```python
# Create multiple devices with different scenarios
devices = [
    create_color_light("d073d5000001"),  # No delays
    create_color_light("d073d5000002"),  # 500ms delay
    create_color_light("d073d5000003"),  # Drop packets
]

manager.set_device_scenario(
    "d073d5000002",
    ScenarioConfig(response_delays={"101": 0.5})
)

manager.set_device_scenario(
    "d073d5000003",
    ScenarioConfig(drop_packets={"101": 0.5})
)

# Test client behavior with heterogeneous device conditions
```

## Persistent Scenarios

Save scenarios across emulator restarts:

```bash
lifx-emulator --api --persistent --persistent-scenarios
```

Scenarios are saved to `~/.lifx-emulator/scenarios.json`.

## API Reference

For complete API documentation, see:

- [Scenario Management API Guide](../scenario-api/) - REST API endpoints
- [Testing Scenarios Guide](../../guide/testing-scenarios/) - Configuration details
- [Scenario Manager API](../../api/server/) - Python API

## Common Packet Types

| Type                   | ID  | Description              |
| ---------------------- | --- | ------------------------ |
| GetColor               | 101 | Request device color     |
| SetColor               | 102 | Set device color         |
| GetPower               | 116 | Request power state      |
| SetPower               | 117 | Set power state          |
| StateColor             | 107 | Color state response     |
| StatePower             | 118 | Power state response     |
| StateMultiZone         | 506 | Multizone state          |
| ExtendedStateMultiZone | 512 | Extended multizone state |
| Get64                  | 514 | Get tile 64              |
| Set64                  | 715 | Set tile 64              |

See [Protocol Documentation](../../architecture/protocol/) for complete list.

## Next Steps

- [Scenario Management API](../scenario-api/) - REST API reference
- [Testing Scenarios Guide](../../guide/testing-scenarios/) - Configuration details
- [Integration Testing](../../guide/integration-testing/) - Testing patterns

# Scenario Management REST API

The LIFX Emulator provides a comprehensive REST API for runtime management of testing scenarios via HTTP. This guide covers all endpoints and practical examples for managing scenarios.

## Quick Start

```bash
# Start emulator with API enabled
lifx-emulator --api

# Create a global scenario that drops all GetColor packets (100% drop rate)
curl -X PUT http://localhost:8080/api/scenarios/global \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 1.0}}'

# Verify the scenario was created
curl http://localhost:8080/api/scenarios/global
```

## Scope Levels

Scenarios operate at 5 scope levels with automatic precedence (highest to lowest):

1. **Device-specific** - Single device by serial number
1. **Device-type** - All devices of a type (color, multizone, extended_multizone, matrix, hev, infrared, basic)
1. **Location-specific** - All devices in a location
1. **Group-specific** - All devices in a group
1. **Global** - All devices as baseline

### Precedence Example

If you have:

- Global: `drop_packets: {101: 1.0}`
- Type (multizone): `response_delays: {502: 1.0}`
- Device (d073d5000001): `drop_packets: {102: 0.5}`

Then device d073d5000001 would:

- Drop packet 101 with 100% rate (from global)
- Drop packet 102 with 50% rate (from device-specific)
- Have 1.0s delay for packet type 502 (from type scenario)

## Configuration Properties

All scenarios can include the following optional properties:

### drop_packets

**Type:** Object mapping packet type to drop rate (0.0-1.0)

Silently drop (don't respond to) packets of specified types with given probability. 1.0 = always drop, 0.5 = drop 50%, 0.0 = never drop. Simulates packet loss.

```json
{"drop_packets": {"101": 1.0, "102": 0.5, "103": 0.3}}
```

### response_delays

**Type:** Object mapping packet type to delay in seconds

Add artificial delay before responding. Simulates latency.

```json
{"response_delays": {"101": 0.5, "116": 1.0}}
```

### malformed_packets

**Type:** Array of integers

Send truncated/corrupted response packets. Tests error handling.

```json
{"malformed_packets": [107, 506]}
```

### invalid_field_values

**Type:** Array of integers

Send response packets with all fields set to 0xFF (invalid). Tests validation.

```json
{"invalid_field_values": [107]}
```

### firmware_version

**Type:** Array [major, minor] or null

Override firmware version reported by device.

```json
{"firmware_version": [2, 60]}
```

### partial_responses

**Type:** Array of integers

Send incomplete multizone/tile data. Tests buffer handling.

```json
{"partial_responses": [506, 512]}
```

### send_unhandled

**Type:** Boolean

Send StateUnhandled (type 3) for unknown packet types.

```json
{"send_unhandled": true}
```

## REST Endpoints

### Global Scenarios

#### Get Global Scenario

```http
GET /api/scenarios/global
```

**Response (200):**

```json
{
  "scope": "global",
  "identifier": null,
  "scenario": {
    "drop_packets": [],
    "response_delays": {},
    "malformed_packets": [],
    "invalid_field_values": [],
    "firmware_version": null,
    "partial_responses": [],
    "send_unhandled": false
  }
}
```

**Example:**

```bash
curl http://localhost:8080/api/scenarios/global | jq
```

#### Set Global Scenario

```http
PUT /api/scenarios/global
Content-Type: application/json
```

**Request Body:**

```json
{
  "drop_packets": {"101": 1.0, "102": 0.6},
  "response_delays": {"101": 0.5, "116": 1.0},
  "malformed_packets": [],
  "invalid_field_values": [],
  "firmware_version": null,
  "partial_responses": [],
  "send_unhandled": false
}
```

**Response (200):** Returns the scenario that was set

**Example:**

```bash
curl -X PUT http://localhost:8080/api/scenarios/global \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 1.0}, "response_delays": {"116": 0.5}}'
```

#### Clear Global Scenario

```http
DELETE /api/scenarios/global
```

**Response (204):** No content

**Example:**

```bash
curl -X DELETE http://localhost:8080/api/scenarios/global
```

______________________________________________________________________

### Device-Specific Scenarios

#### Get Device Scenario

```http
GET /api/scenarios/devices/{serial}
```

**Path Parameters:**

- `serial`: Device serial (e.g., `d073d5000001`)

**Response (200):**

```json
{
  "scope": "device",
  "identifier": "d073d5000001",
  "scenario": {...}
}
```

**Response (404):** No scenario for this device

**Example:**

```bash
curl http://localhost:8080/api/scenarios/devices/d073d5000001 | jq
```

#### Set Device Scenario

```http
PUT /api/scenarios/devices/{serial}
Content-Type: application/json
```

**Path Parameters:**

- `serial`: Device serial

**Request Body:** Any scenario properties (partial update allowed)

**Response (200):** Returns the scenario that was set

**Response (404):** Device not found

**Example:**

```bash
# Set scenario for specific device (drop 100% of GetColor packets)
curl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 1.0}}'
```

#### Clear Device Scenario

```http
DELETE /api/scenarios/devices/{serial}
```

**Response (204):** No content

**Response (404):** No scenario for this device

**Example:**

```bash
curl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000001
```

______________________________________________________________________

### Type-Specific Scenarios

#### Get Type Scenario

```http
GET /api/scenarios/types/{device_type}
```

**Path Parameters:**

- `device_type`: One of `color`, `multizone`, `extended_multizone`, `matrix`, `hev`, `infrared`, `basic`

**Response (200):**

```json
{
  "scope": "type",
  "identifier": "multizone",
  "scenario": {...}
}
```

**Response (404):** No scenario for this type

**Example:**

```bash
curl http://localhost:8080/api/scenarios/types/multizone | jq
```

#### Set Type Scenario

```http
PUT /api/scenarios/types/{device_type}
Content-Type: application/json
```

**Path Parameters:**

- `device_type`: Device type

**Request Body:** Any scenario properties

**Response (200):** Returns the scenario

**Example:**

```bash
# All multizone devices will respond slowly to GetColorZones (502)
curl -X PUT http://localhost:8080/api/scenarios/types/multizone \
  -H "Content-Type: application/json" \
  -d '{"response_delays": {"502": 1.0}}'
```

#### Clear Type Scenario

```http
DELETE /api/scenarios/types/{device_type}
```

**Response (204):** No content

**Response (404):** No scenario for this type

**Example:**

```bash
curl -X DELETE http://localhost:8080/api/scenarios/types/multizone
```

______________________________________________________________________

### Location-Specific Scenarios

#### Get Location Scenario

```http
GET /api/scenarios/locations/{location}
```

**Path Parameters:**

- `location`: Location label (e.g., `Kitchen`, `Living Room`)

**Response (200):**

```json
{
  "scope": "location",
  "identifier": "Kitchen",
  "scenario": {...}
}
```

**Response (404):** No scenario for this location

#### Set Location Scenario

```http
PUT /api/scenarios/locations/{location}
Content-Type: application/json
```

**Path Parameters:**

- `location`: Location label

**Request Body:** Any scenario properties

**Response (200):** Returns the scenario

**Example:**

```bash
# All devices in Kitchen will have poor connectivity
curl -X PUT http://localhost:8080/api/scenarios/locations/Kitchen \
  -H "Content-Type: application/json" \
  -d '{"response_delays": {"116": 0.5}, "drop_packets": {"101": 0.3}}'
```

#### Clear Location Scenario

```http
DELETE /api/scenarios/locations/{location}
```

**Response (204):** No content

**Response (404):** No scenario for this location

______________________________________________________________________

### Group-Specific Scenarios

#### Get Group Scenario

```http
GET /api/scenarios/groups/{group}
```

**Path Parameters:**

- `group`: Group label (e.g., `Bedroom Lights`)

**Response (200):**

```json
{
  "scope": "group",
  "identifier": "Bedroom Lights",
  "scenario": {...}
}
```

**Response (404):** No scenario for this group

#### Set Group Scenario

```http
PUT /api/scenarios/groups/{group}
Content-Type: application/json
```

**Path Parameters:**

- `group`: Group label

**Request Body:** Any scenario properties

**Response (200):** Returns the scenario

**Example:**

```bash
# All devices in "Bedroom Lights" group will send corrupted responses
curl -X PUT http://localhost:8080/api/scenarios/groups/"Bedroom Lights" \
  -H "Content-Type: application/json" \
  -d '{"malformed_packets": [107]}'
```

#### Clear Group Scenario

```http
DELETE /api/scenarios/groups/{group}
```

**Response (204):** No content

**Response (404):** No scenario for this group

______________________________________________________________________

## Practical Examples

### Example 1: Test Packet Loss Handling

Test client retry logic by dropping GetColor packets:

```bash
# Drop GetColor (type 101) for all color lights - 100% drop rate
curl -X PUT http://localhost:8080/api/scenarios/types/color \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 1.0}}'

# Your client should:
# 1. Send GetColor request
# 2. Timeout waiting for response
# 3. Retry (with backoff if implemented)
# 4. Eventually fail after max retries

# Verify scenario is set
curl http://localhost:8080/api/scenarios/types/color | jq '.scenario.drop_packets'
# Output: {"101": 1.0}

# Clean up
curl -X DELETE http://localhost:8080/api/scenarios/types/color
```

### Example 2: Simulate Network Latency

Add realistic network delays:

```bash
# Simulate 500ms latency to all color light responses
curl -X PUT http://localhost:8080/api/scenarios/types/color \
  -H "Content-Type: application/json" \
  -d '{
    "response_delays": {
      "45": 0.5,
      "101": 0.5,
      "102": 0.5,
      "107": 0.5,
      "116": 0.5,
      "117": 0.5
    }
  }'
```

### Example 3: Test Firmware Compatibility

Override firmware version to test backward compatibility:

```bash
# Set device to old firmware version
curl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \
  -H "Content-Type: application/json" \
  -d '{"firmware_version": [2, 60]}'

# Get the device to verify firmware version is changed
curl http://localhost:8080/api/devices/d073d5000001 | jq '.version_major, .version_minor'
# Output: 2, 60
```

### Example 4: Simulate Problematic Device

Combine multiple scenarios to simulate a problematic device:

```bash
# Device sometimes drops responses, is slow, and sends bad data
curl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \
  -H "Content-Type: application/json" \
  -d '{
    "drop_packets": {"101": 1.0},
    "response_delays": {"102": 1.0, "116": 0.8},
    "malformed_packets": [107],
    "firmware_version": [2, 50]
  }'
```

### Example 5: Location-Based Testing

Test a group of devices with poor connectivity:

```bash
# All devices in Kitchen location have latency
curl -X PUT http://localhost:8080/api/scenarios/locations/Kitchen \
  -H "Content-Type: application/json" \
  -d '{"response_delays": {"116": 0.5}}'

# Override with specific device being worse
curl -X PUT http://localhost:8080/api/scenarios/devices/d073d5kitchen01 \
  -H "Content-Type: application/json" \
  -d '{"response_delays": {"116": 2.0}, "drop_packets": {"102": 0.5}}'

# Device d073d5kitchen01 will have 2.0s delay for 116 (device override wins)
# Other Kitchen devices will have 0.5s delay for 116 (location scenario)
```

### Example 6: Test Invalid Data Handling

Send packets with invalid field values:

```bash
# Device will send StateColor with all 0xFF bytes
curl -X PUT http://localhost:8080/api/scenarios/devices/d073d5000001 \
  -H "Content-Type: application/json" \
  -d '{"invalid_field_values": [107]}'

# Your client should:
# - Detect invalid values (hue=65535, saturation=65535, etc.)
# - Reject or sanitize the values
# - Not crash or use invalid values
```

### Example 7: Clear All Scenarios

```bash
# List all devices to find serial numbers
curl http://localhost:8080/api/devices | jq '.[] | .serial'

# Clear scenarios for specific devices
curl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000001
curl -X DELETE http://localhost:8080/api/scenarios/devices/d073d5000002

# Clear all type scenarios
for type in color multizone extended_multizone matrix hev infrared basic; do
  curl -X DELETE http://localhost:8080/api/scenarios/types/$type 2>/dev/null
done

# Clear global
curl -X DELETE http://localhost:8080/api/scenarios/global
```

## Shell Script Helpers

### Get All Scenarios

```bash
#!/bin/bash

echo "=== Global Scenario ==="
curl -s http://localhost:8080/api/scenarios/global | jq '.scenario'

echo -e "\n=== Device-Specific Scenarios ==="
curl -s http://localhost:8080/api/devices | jq -r '.[] | .serial' | while read serial; do
  echo -n "$serial: "
  curl -s http://localhost:8080/api/scenarios/devices/$serial 2>/dev/null | jq '.scenario.drop_packets // "none"'
done

echo -e "\n=== Type Scenarios ==="
for type in color multizone extended_multizone matrix hev infrared basic; do
  echo -n "$type: "
  curl -s http://localhost:8080/api/scenarios/types/$type 2>/dev/null | jq '.scenario.drop_packets // "none"'
done
```

### Test Scenario Workflow

```bash
#!/bin/bash

echo "1. Setting global scenario..."
curl -X PUT http://localhost:8080/api/scenarios/global \
  -H "Content-Type: application/json" \
  -d '{"drop_packets": {"101": 1.0}}' > /dev/null

echo "2. Verifying global scenario..."
curl -s http://localhost:8080/api/scenarios/global | jq '.scenario'

echo "3. Running test suite..."
pytest tests/

echo "4. Clearing scenario..."
curl -X DELETE http://localhost:8080/api/scenarios/global > /dev/null

echo "5. Verifying cleared..."
curl -s http://localhost:8080/api/scenarios/global | jq '.scenario'
```

## Python Client Examples

### Using requests Library

```python
import requests
import json

BASE_URL = "http://localhost:8080/api"

def get_global_scenario():
    """Get the global scenario configuration."""
    response = requests.get(f"{BASE_URL}/scenarios/global")
    return response.json()

def set_device_scenario(serial, scenario):
    """Set scenario for a specific device."""
    response = requests.put(
        f"{BASE_URL}/scenarios/devices/{serial}",
        json=scenario
    )
    return response.json()

def clear_device_scenario(serial):
    """Clear scenario for a device."""
    response = requests.delete(f"{BASE_URL}/scenarios/devices/{serial}")
    return response.status_code

# Usage
scenario = {
    "drop_packets": {"101": 1.0},
    "response_delays": {"102": 0.5}
}

result = set_device_scenario("d073d5000001", scenario)
print(f"Scenario set: {result}")

status = clear_device_scenario("d073d5000001")
print(f"Cleared: {status == 204}")
```

### Using httpx Library (Async)

```python
import httpx
import asyncio

BASE_URL = "http://localhost:8080/api"

async def test_scenario():
    """Test scenario management async."""
    async with httpx.AsyncClient() as client:
        # Get all devices
        devices = await client.get(f"{BASE_URL}/devices")

        for device in devices.json():
            serial = device["serial"]

            # Set scenario for device
            scenario = {"drop_packets": {"101": 1.0}}
            await client.put(
                f"{BASE_URL}/scenarios/devices/{serial}",
                json=scenario
            )

            # Verify it was set
            resp = await client.get(f"{BASE_URL}/scenarios/devices/{serial}")
            print(f"{serial}: {resp.json()['scenario']}")

            # Clear it
            await client.delete(f"{BASE_URL}/scenarios/devices/{serial}")

asyncio.run(test_scenario())
```

## Integration with Tests

### pytest Integration

```python
import pytest
import requests

API_URL = "http://localhost:8080/api"

@pytest.fixture(autouse=True)
def clear_scenarios():
    """Clear all scenarios before and after each test."""
    # Clear before
    requests.delete(f"{API_URL}/scenarios/global")
    yield
    # Clear after
    requests.delete(f"{API_URL}/scenarios/global")

def test_with_packet_loss():
    """Test client handles packet loss."""
    # Set scenario
    requests.put(
        f"{API_URL}/scenarios/types/color",
        json={"drop_packets": {"101": 1.0}}
    )

    # Run test that exercises retry logic
    client = YourLIFXClient()
    result = client.get_color("d073d5000001")

    # Should either retry successfully or timeout gracefully
    assert result is not None or client.last_error is not None

def test_with_latency():
    """Test client handles slow responses."""
    requests.put(
        f"{API_URL}/scenarios/types/color",
        json={"response_delays": {"101": 0.5}}
    )

    client = YourLIFXClient()
    import time
    start = time.time()
    result = client.get_color("d073d5000001")
    elapsed = time.time() - start

    assert elapsed >= 0.5
    assert result is not None
```

### GitHub Actions Integration

```yaml
name: Test with Scenarios

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-python@v4

      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install -r requirements-dev.txt

      - name: Start emulator
        run: |
          python -m lifx_emulator --api --color 2 --multizone 1 &
          sleep 2

      - name: Run tests (normal conditions)
        run: pytest tests/ -v

      - name: Configure packet loss scenario
        run: |
          curl -X PUT http://localhost:8080/api/scenarios/types/color \
            -H "Content-Type: application/json" \
            -d '{"drop_packets": {"101": 1.0}}'

      - name: Run tests (with packet loss)
        run: pytest tests/ -v -k "retry"

      - name: Configure latency scenario
        run: |
          curl -X PUT http://localhost:8080/api/scenarios/types/color \
            -H "Content-Type: application/json" \
            -d '{"response_delays": {"101": 0.5}}'

      - name: Run performance tests
        run: pytest tests/ -v -k "performance"
```

## Common Packet Types

| Type | Name                   | Description                   |
| ---- | ---------------------- | ----------------------------- |
| 45   | Acknowledgement        | Sent when ack_required is set |
| 101  | GetColor               | Request current color state   |
| 102  | SetColor               | Set device color              |
| 103  | GetWaveform            | Get waveform effect           |
| 104  | SetWaveform            | Set waveform effect           |
| 107  | StateColor             | Response with current color   |
| 116  | GetLightPower          | Request power state           |
| 117  | SetLightPower          | Set power state               |
| 502  | GetColorZones          | Request multizone colors      |
| 503  | SetColorZones          | Set multizone colors          |
| 506  | StateMultiZone         | Response with zone colors     |
| 512  | ExtendedStateMultiZone | Response with extended zones  |
| 701  | GetDeviceChain         | Get tile chain info           |
| 707  | Get64                  | Get tile pixel data           |
| 715  | Set64                  | Set tile pixel data           |

## Tips and Best Practices

1. **Test One Thing at a Time**: Set a single scenario property first, verify it works, then add more
1. **Use Realistic Values**: Network delays should be 0.1-2.0 seconds, not 10+ seconds
1. **Clean Up After Tests**: Always delete scenarios between test runs to avoid cross-contamination
1. **Monitor Activity**: Use the `/api/activity` endpoint to see actual packets being sent
1. **Start with Device-Level**: Test individual devices before testing by type/location/group
1. **Document Scenarios**: Add comments explaining why each scenario is configured in your tests
1. **Test Recovery**: Verify clients properly recover after scenario conditions clear

## See Also

- [Testing Scenarios Guide](../../guide/testing-scenarios/) - Programmatic scenario configuration
- [Integration Testing](../../guide/integration-testing/) - Using scenarios in test suites
- [Best Practices](../../guide/best-practices/) - Testing strategies
- [API Reference](../../api/) - Full API documentation
# Architecture

# Architecture

Deep dive into how the LIFX Emulator works internally.

## Overview

This section explains the internal architecture of the LIFX Emulator. Understanding this helps you:

- Debug issues more effectively
- Contribute to the project
- Extend the emulator for custom use cases
- Understand protocol implementation details

## Prerequisites

Before reading this section, you should:

- Have used the emulator in basic scenarios
- Understand LIFX device types
- Have basic knowledge of networking (UDP)
- Be familiar with Python async/await

## Learning Path

Read these pages in order from high-level to implementation details:

1. **[Architecture Overview](overview/)** - System design and component interaction
1. **[Packet Flow](packet-flow/)** - How packets are received and processed
1. **[Device State](device-state/)** - State management and capabilities
1. **[Protocol Details](protocol/)** - Binary protocol implementation

## Quick Concepts

### Layered Architecture

The emulator uses a layered architecture:

```text
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  LIFX Client        ‚îÇ  Your library/app
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
           ‚îÇ UDP
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Server Layer       ‚îÇ  Packet routing
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Device Layer       ‚îÇ  Device logic
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Protocol Layer     ‚îÇ  Binary packets
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  State Layer        ‚îÇ  Device state
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Key Components

- **EmulatedLifxServer**: UDP server that routes packets to devices
- **EmulatedLifxDevice**: Individual virtual device with state and logic
- **LifxHeader**: 36-byte packet header parser/generator
- **Packet Classes**: 44+ packet type implementations
- **DeviceState**: Dataclass holding device state

### Protocol Implementation

The LIFX LAN protocol is a binary UDP protocol. The emulator:

1. Receives UDP packets on port 56700
1. Parses the 36-byte header
1. Routes to target device(s) by serial
1. Unpacks payload to packet object
1. Executes device-specific handler
1. Generates response packet(s)
1. Sends UDP response(s)

## Next Steps

Start with the [Architecture Overview](overview/) for a high-level understanding, then progress through the other pages for deeper details.

# Architecture Overview

The LIFX Emulator is built with a layered architecture that mirrors real LIFX devices.

## High-Level Architecture

```
graph TB
    Client[LIFX Client Library]
    Server[EmulatedLifxServer]
    Device1[EmulatedLifxDevice]
    Device2[EmulatedLifxDevice]
    Device3[EmulatedLifxDevice]
    Protocol[Protocol Layer]
    State[DeviceState]

    Client -->|UDP Packets| Server
    Server -->|Route by Serial| Device1
    Server -->|Route by Serial| Device2
    Server -->|Route by Serial| Device3
    Device1 -->|Parse/Pack| Protocol
    Device2 -->|Parse/Pack| Protocol
    Device3 -->|Parse/Pack| Protocol
    Device1 -->|Read/Write| State
    Device2 -->|Read/Write| State
    Device3 -->|Read/Write| State
```

## Core Components

### 1. Server Layer (`EmulatedLifxServer`)

The server layer handles:

- UDP socket management
- Packet reception and sending
- Device routing by serial (encoded in target field)
- Broadcast packet distribution

**Key Responsibilities:**

- Listen on configured IP and port
- Parse packet headers to determine routing
- Forward packets to appropriate devices
- Send responses back to clients

### 2. Device Layer (`EmulatedLifxDevice`)

Each device instance represents a virtual LIFX device:

- Maintains device state
- Processes incoming packets
- Generates response packets
- Handles device-specific logic

**Key Responsibilities:**

- Process packet type routing
- Update state based on commands
- Generate appropriate responses
- Implement device capabilities

### 3. Protocol Layer

The protocol layer implements LIFX LAN protocol:

- Binary packet serialization/deserialization
- Header parsing and generation
- Packet type definitions
- Type conversions

**Components:**

- `LifxHeader` - 36-byte header structure
- Packet classes - 44+ packet type definitions
- `Serializer` - Binary packing/unpacking
- Protocol types - `LightHsbk`, `TileStateDevice`, etc.

### 4. State Layer (`DeviceState`)

Device state is stored in a dataclass:

- Device identity (serial, label, product)
- Capability flags (color, infrared, multizone, etc.)
- Light state (power, color, zones, tiles)
- Firmware version
- Network configuration

## Packet Flow

```
sequenceDiagram
    participant Client
    participant Server
    participant Device
    participant Protocol
    participant State

    Client->>Server: UDP Packet
    Server->>Protocol: Parse Header
    Protocol-->>Server: LifxHeader
    Server->>Device: Route by target serial
    Device->>Protocol: Unpack Payload
    Protocol-->>Device: Packet Object
    Device->>State: Update State
    Device->>Protocol: Generate Response
    Protocol-->>Device: Packed Response
    Device-->>Server: Response Packet(s)
    Server->>Client: UDP Response
```

### Detailed Flow

1. **Reception**
1. Client sends UDP packet to server
1. Server receives bytes on socket
1. **Header Parsing**
1. Extract 36-byte header
1. Parse: target (serial + padding), packet type, flags
1. Determine if broadcast or targeted
1. **Device Routing**
1. If broadcast (tagged=True or target=000000000000): forward to all devices
1. If targeted: find device by serial (encoded in target field)
1. If not found: ignore packet
1. **Packet Processing**
1. Device unpacks payload using packet class
1. Determines packet type (e.g., LightSetColor)
1. Routes to specific handler method
1. **State Update**
1. Handler reads current state
1. Applies command logic
1. Updates state fields
1. **Response Generation**
1. If `res_required=True`: generate state response
1. If `ack_required=True`: generate acknowledgment
1. Create response header with sequence number
1. **Response Sending**
1. Pack response packets to bytes
1. Send back to client via UDP

## Layer Details

### Server Layer

```python
class EmulatedLifxServer:
    """UDP server that routes packets to devices."""

    def __init__(self, devices, bind_address, port):
        self._devices = {d.state.serial: d for d in devices}
        self._bind_address = bind_address
        self._port = port

    async def start(self):
        """Start UDP server."""
        pass

    def handle_packet(self, data, addr):
        """Route incoming packet to device(s)."""
        # Parse header
        # Find target device(s)
        # Process and send responses
        pass
```

### Device Layer

```python
class EmulatedLifxDevice:
    """Virtual LIFX device with stateful behavior."""

    def __init__(self, state: DeviceState):
        self.state = state
        self.scenarios = {}  # Testing scenarios

    def process_packet(self, header, packet):
        """Process incoming packet and generate responses."""
        # Handle acknowledgments
        # Route to packet-specific handler
        # Generate response packets
        pass

    def _handle_light_set_color(self, packet):
        """Handle LightSetColor command."""
        # Update self.state.color
        # Return response if needed
        pass
```

### Protocol Layer

```python
class LifxHeader:
    """36-byte LIFX packet header."""

    def __init__(self, ...):
        self.target = target        # 6-byte serial + 2 null bytes
        self.source = source        # 4-byte identifier
        self.sequence = sequence    # 1-byte sequence number
        self.pkt_type = pkt_type    # Packet type number
        self.tagged = tagged        # tagged
        # ... more fields

    def pack(self) -> bytes:
        """Pack header to 36 bytes."""
        pass

    @classmethod
    def unpack(cls, data: bytes):
        """Parse 36 bytes to header."""
        pass
```

### State Layer

```python
@dataclass
class DeviceState:
    """Device state storage."""

    # Identity
    serial: str
    label: str
    vendor: int
    product: int

    # Capabilities
    has_color: bool
    has_infrared: bool
    has_multizone: bool
    has_matrix: bool
    has_hev: bool

    # Light state
    power_level: int
    color: LightHsbk
    zone_colors: list[LightHsbk]
    tile_devices: list[TileState]

    # ... more fields
```

## Capability Flags

Devices advertise capabilities through boolean flags:

| Flag                     | Capability     | Example Products       |
| ------------------------ | -------------- | ---------------------- |
| `has_color`              | Full RGB color | LIFX A19, LIFX Beam    |
| `has_infrared`           | IR brightness  | LIFX A19 Night Vision  |
| `has_multizone`          | Linear zones   | LIFX Z, LIFX Beam      |
| `has_extended_multizone` | >16 zones      | LIFX Beam              |
| `has_matrix`             | 2D pixel grid  | LIFX Tile, LIFX Candle |
| `has_hev`                | HEV cleaning   | LIFX Clean             |

## Packet Types

The emulator implements 44+ packet types across multiple domains:

### Device Domain (1-45)

- GetService (2) / StateService (3)
- GetVersion (32) / StateVersion (33)
- GetLabel (23) / StateLabel (25)
- SetLabel (24)
- GetPower (20) / StatePower (22)
- SetPower (21)

### Light Domain (100-122)

- LightGet (101) / LightState (107)
- LightSetColor (102)
- LightSetWaveform (103)
- LightGetInfrared (120) / LightStateInfrared (121)
- LightSetInfrared (122)

### MultiZone Domain (500-512)

- GetColorZones (502) / StateZone (503)
- StateMultiZone (506)
- SetColorZones (501)
- GetMultiZoneEffect (507) / StateMultiZoneEffect (508)
- SetMultiZoneEffect (509)
- SetExtendedColorZones (510)
- GetExtendedColorZones (511) / StateExtendedColorZones (512)

### Tile Domain (700-719)

- GetDeviceChain (701) / StateDeviceChain (702)
- SetUserPosition (703)
- GetTileState64 (707) / StateTileState64 (711)
- SetTileState64 (715)
- GetTileEffect (718) / StateTileEffect (719)

See [Protocol Layer](../protocol/) for complete packet documentation.

## Design Patterns

### Factory Pattern

Factory functions encapsulate device creation:

```python
def create_color_light(serial=None):
    """Create LIFX A19 with sensible defaults."""
    return create_device(27, serial=serial)
```

### Strategy Pattern

Packet handlers implement strategy pattern:

```python
def process_packet(self, header, packet):
    handler_map = {
        LightSetColor: self._handle_light_set_color,
        LightSetPower: self._handle_light_set_power,
        # ... more handlers
    }
    handler = handler_map.get(type(packet))
    if handler:
        return handler(packet)
```

### State Pattern

Device state changes based on received commands:

```python
def _handle_light_set_color(self, packet):
    self.state.color = packet.color
    self.state.power_level = packet.color.brightness
```

## Concurrency Model

The emulator uses Python's asyncio:

- **Single-threaded**: All operations run in the event loop
- **Non-blocking**: Uses async/await for I/O
- **Datagram protocol**: UDP doesn't maintain connections
- **Stateful devices**: Each device maintains independent state

```python
async with EmulatedLifxServer(devices, "127.0.0.1", 56700) as server:
    # Server runs in background tasks
    # Your test code runs concurrently
    await asyncio.sleep(1)
```

## Testing Architecture

The emulator supports advanced testing scenarios:

```python
device.scenarios = {
    'drop_packets': {101: 1.0},      # Drop all LightGet packets
    'response_delays': {102: 0.5},   # Delay SetColor by 500ms
    'malformed_packets': [107],      # Truncate StateLight
    'invalid_field_values': [22],    # Send invalid StatePower
    'partial_responses': [506],      # Incomplete multizone response
}
```

## Next Steps

- [Packet Flow](../packet-flow/) - Detailed packet processing
- [Protocol Layer](../protocol/) - Protocol implementation details
- [Device State](../device-state/) - State management
- [Server API](../../api/server/) - Server documentation

# Packet Flow

Coming soon.

# Protocol

Coming soon.

# Device State

Coming soon.
